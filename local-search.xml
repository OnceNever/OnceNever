<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记一次Error parsing HTTP request header问题解决</title>
    <link href="/2024/08/08/%E8%AE%B0%E4%B8%80%E6%AC%A1Error%20parsing%20HTTP%20request%20header%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/08/08/%E8%AE%B0%E4%B8%80%E6%AC%A1Error%20parsing%20HTTP%20request%20header%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>近期在做一个抓取网络数据包进行分析的项目，使用<code>springboot</code>框架，基于<code>pcap4j</code>实现，大致的逻辑就是抓取数据包，解析一些常用信息，然后收集所有<code>IP</code>，最后通过<code>nmap</code>主动嗅探给定范围主机的信息，包括操作系统以及端口开放情况，运行的服务等等。</p><p>前半段一切顺利，在对抓取到的<code>IP</code>使用<code>nmap</code>主动探测时，总是会在控制台打印一段错误日志：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex">2024-08-08 18:14:17.078  INFO 5460 --- [nio-8080-exec-5] o.apache.coyote.http11.Http11Processor   : Error parsing HTTP request header<br> Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.<br><br>java.lang.IllegalArgumentException: Invalid character found in the HTTP protocol [RTSP/1.00x0d0x0a0x0d0x0a...]<br>at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:570) ~[tomcat-embed-core-9.0.68.jar:9.0.68]<br>at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:271) ~[tomcat-embed-core-9.0.68.jar:9.0.68]<br>at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.68.jar:9.0.68]<br>at org.apache.coyote.AbstractProtocol<span class="hljs-built_in">$</span>ConnectionHandler.process(AbstractProtocol.java:893) [tomcat-embed-core-9.0.68.jar:9.0.68]<br>at org.apache.tomcat.util.net.NioEndpoint<span class="hljs-built_in">$</span>SocketProcessor.doRun(NioEndpoint.java:1789) [tomcat-embed-core-9.0.68.jar:9.0.68]<br>at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.68.jar:9.0.68]<br>at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) [tomcat-embed-core-9.0.68.jar:9.0.68]<br>at org.apache.tomcat.util.threads.ThreadPoolExecutor<span class="hljs-built_in">$</span>Worker.run(ThreadPoolExecutor.java:659) [tomcat-embed-core-9.0.68.jar:9.0.68]<br>at org.apache.tomcat.util.threads.TaskThread<span class="hljs-built_in">$</span>WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.68.jar:9.0.68]<br>at java.lang.Thread.run(Thread.java:748) [na:1.8.0<span class="hljs-built_in">_</span>301]<br></code></pre></td></tr></table></figure><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>由于此前从未遇到这个问题，所以首要目的是搞清楚这个问题意味着什么，对症下药才能彻底解决。</p><p>经过查询资料找到三个主要产生问题的原因。</p><h4 id="传入的HTTP标头比预期要大"><a href="#传入的HTTP标头比预期要大" class="headerlink" title="传入的HTTP标头比预期要大"></a>传入的HTTP标头比预期要大</h4><p>内置的<code>tomcat</code>服务器默认接受的<code>HTTP</code>最大标头为<strong>8k</strong>。</p><p>因为过大的标头会消耗更多的内存，可能会降低请求速度，甚至导致服务器崩溃。</p><p>所以限制标头的大小是一种安全的做法。</p><p>我们可以通过一行配置修改默认接受的最大标头大小：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.max-http-header-size</span>=<span class="hljs-string">64000</span><br></code></pre></td></tr></table></figure><p>我试着修改配置文件，但最终还是无法解决问题。</p><h4 id="服务器接收HTTP而客户端使用HTTPS"><a href="#服务器接收HTTP而客户端使用HTTPS" class="headerlink" title="服务器接收HTTP而客户端使用HTTPS"></a>服务器接收HTTP而客户端使用HTTPS</h4><p>服务的希望接收一个未加密的标头，如果客户端使用<code>HTTPS</code>请求服务器，服务器也会因为无法解析客户端加密的标头而提示错误。</p><p>但是在抓包的整个过程我没有主动使用<code>HTTPS</code>请求服务器。</p><h4 id="服务器接收到一个不符合HTTP标头规范的请求"><a href="#服务器接收到一个不符合HTTP标头规范的请求" class="headerlink" title="服务器接收到一个不符合HTTP标头规范的请求"></a>服务器接收到一个不符合HTTP标头规范的请求</h4><p>由于抓包中存在我本机<code>IP</code>，同时使用<code>nmap</code>对主机上所有常见端口进行扫描，这就包括了我的服务监听的<code>8080</code>端口，<code>nmap</code>通过发送<code>TCP SYN</code>包来监测端口是否开放，此时这个包并不符合<code>HTTP</code>标头规范，所以<code>tomcat</code>服务器尝试解析标头时出现错误。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>最终修改<code>nmap</code>的扫描命令，排除本地<code>8080</code>端口后报错消失。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ollama安装配置与使用</title>
    <link href="/2024/05/30/Ollama%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/05/30/Ollama%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><strong>Ollama</strong>是一个快速在本地启动并运行大型语言模型的脚手架，旨在简化大型语言模型本地部署和运行的工具。</p><p>官网：<a href="https://ollama.com/">ollama.com</a></p><p>Github：<a href="https://github.com/ollama/ollama">ollama</a></p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>以<em>Linux</em>为例，<em>ollama</em>提供了在线和离线安装两种方式。由于本人没有<code>GPU</code>资源，<em>ollama</em>默认将模型运行在<code>CPU</code>上。</p><h5 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -fsSL https://ollama.com/install.sh | sh<br></code></pre></td></tr></table></figure><h5 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h5><ol><li><p>下载<em>ollama</em>二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo curl -L https://ollama.com/download/ollama-linux-amd64 -o /usr/bin/ollama<br>sudo chmod +x /usr/bin/ollama<br></code></pre></td></tr></table></figure></li><li><p>将<em>ollama</em>作为启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo useradd -r -s /bin/false -m -d /usr/share/ollama ollama<br></code></pre></td></tr></table></figure><p>在<code>/etc/systemd/system/ollama.service</code>创建如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[Unit]</span><br><span class="hljs-attr">Description</span>=<span class="hljs-string">Ollama Service</span><br><span class="hljs-attr">After</span>=<span class="hljs-string">network-online.target</span><br><br><span class="hljs-attr">[Service]</span><br><span class="hljs-comment">## Environment=“OLLAMA_HOST=0.0.0.0:11434” ## 开启这行配置允许远程访问</span><br><span class="hljs-attr">ExecStart</span>=<span class="hljs-string">/usr/bin/ollama serve</span><br><span class="hljs-attr">User</span>=<span class="hljs-string">ollama</span><br><span class="hljs-attr">Group</span>=<span class="hljs-string">ollama</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-string">always</span><br><span class="hljs-attr">RestartSec</span>=<span class="hljs-string">3</span><br><br><span class="hljs-attr">[Install]</span><br><span class="hljs-attr">WantedBy</span>=<span class="hljs-string">default.target</span><br></code></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl enable ollama<br></code></pre></td></tr></table></figure></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们可以到官网的<a href="https://ollama.com/library">模型库</a>中查看可用的模型，<code>llama3</code>是目前比较受欢迎的开源模型之一，但由于其用于训练的中文语料较少，对中文的支持不够友好（说着说着变成英文），所以我这边选了一个中文微调后的<code>llama3</code><a href="https://ollama.com/wangshenzhi/llama3-8b-chinese-chat-ollama-q4">模型</a>。</p><p>直接执行<code>ollama run wangshenzhi/llama3-8b-chinese-chat-ollama-q4</code>，如果模型不存在会自动拉取并启动：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530112629454.png" alt="image-20240530112629454"></p><p>就是如此简单，我们就已经在本地部署好了一个大语言模型！</p><p>试着和它聊聊吧！</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530113113026.png" alt="image-20240530113113026"></p><p>不仅如此，<em>ollama</em>还提供了丰富的<em>API</em>供我们使用，例如：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530113455240.png" alt="image-20240530113455240"></p><p>默认是流式返回，也提供了多个参数供我们选择，这里不再赘述。</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530113711563.png" alt="image-20240530113711563"></p><p>搭配*<a href="https://github.com/open-webui/open-webui">open-webui</a>*可以实现类似<code>ChatGpt</code>官网页面的样式，使用<code>docker</code>一键部署就好，不详细说明。</p><p>web页面：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530114219449.png" alt="image-20240530114219449"></p><h4 id="微调模型"><a href="#微调模型" class="headerlink" title="微调模型"></a>微调模型</h4><p>在模型推理的过程中，我发现使用CPU进行推理时无法跑满机器上的所有逻辑核心（只使用一半的逻辑核心），查阅项目<a href="https://github.com/ollama/ollama/issues/2929">issue</a>得知有人遇到和我一样的问题。</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530115117395.png" alt="image-20240530115117395"></p><p>例如我的机器是8个物理核心16个逻辑核心，推理时无论如何也不会使用超过八个核心。</p><p>尽管让程序占用所有的核心可能会导致抖动和性能下降，但有时候就是如此任性：）</p><p><em>ollama</em>有一个<code>num_thread</code>参数用于设置推理线程数。</p><p>一种可行方式是在<strong>命令行</strong>中通过<code>SET</code>指令，显示设置推理线程数量：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530120156018.png" alt="image-20240530120156018"></p><p>再次推理，就能看到跑满所有核心：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530120330218.png" alt="image-20240530120330218"></p><p>但是，这种方式有一个问题，只在命令行中有用，只要重跑或者通过<em>API</em>调用的方式参数是不会生效的。</p><p>一种更好的方式是在构建模型时，将<code>num_thread</code>参数当作一部分内容传入，如此一来构建出来的模型就默认使用指定的线程数推理。</p><p>当然，我们在构建模型时可选择的参数还有很多。</p><h5 id="Modelfile"><a href="#Modelfile" class="headerlink" title="Modelfile"></a>Modelfile</h5><p>通过<code>Modelfile</code>来构建新的模型。</p><p>一个可能的示例如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> llama3<br><span class="hljs-comment"># sets the temperature to 1 [higher is more creative, lower is more coherent]</span><br>PARAMETER temperature 1<br><span class="hljs-comment"># sets the context window size to 4096, this controls how many tokens the LLM can use as context to generate the next token</span><br>PARAMETER num_ctx 4096<br><br><span class="hljs-comment"># sets a custom system message to specify the behavior of the chat assistant</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">SYSTEM </span>You are Mario <span class="hljs-keyword">from</span> super mario bros, acting as an assistant.<br></code></pre></td></tr></table></figure><p>如果你只想在一个已有的模型上稍作修改，可以使用<code>ollama show [modelName] --modelfile</code>来查看指定模型的<code>Modelfile</code></p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530141209313.png" alt="image-20240530141209313"></p><p>然后将这份文件内容复制出来，加入自己的一些参数或者对其中一些参数做适当调整，具体参数列表可以参考<a href="https://github.com/ollama/ollama/blob/main/docs/modelfile.md#valid-parameters-and-values">Valid Parameters and Values</a></p><p>为了测试我简单做了以下调整：新增了<code>num_thread</code>参数并且修改了SYSTEM部分内容。</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530142706131.png" alt="image-20240530142706131"></p><p>执行 <code>ollama create [guide-assistant] -f Modelfile</code> 创建新模型</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530143125333.png" alt="image-20240530143125333"></p><p>启动模型，并执行推理任务：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530143417344.png" alt="image-20240530143417344"></p><p>即使没有手动设置<code>num_thread</code>，也是跑满了16个CPU核心：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530143350868.png" alt="image-20240530143350868"></p><h5 id="发布模型"><a href="#发布模型" class="headerlink" title="发布模型"></a>发布模型</h5><p>需要在<em>ollama</em>官网上注册账号，执行<code>cat /usr/share/ollama/.ollama/id_ed25519.pub</code>命令获取公钥。</p><p>之后将获取到的公钥复制粘贴到下面红框内：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530143840189.png" alt="image-20240530143840189"></p><p>将模型复制到你的用户名的命名空间 <code>ollama cp &#123;modelName&#125; &#123;ollama account&#125;/&#123;modelName&#125;</code></p><p>然后推送模型<code>ollama push seeyourface/guide-assistant</code></p><p>然后就等推送完毕，就可以在我们刚才注册的账号下看到自己发布的模型。</p><h3 id="一键安装ollama与指定模型"><a href="#一键安装ollama与指定模型" class="headerlink" title="一键安装ollama与指定模型"></a>一键安装ollama与指定模型</h3><p>尽管<em>ollama</em>已经十分方便，但仍然需要我们去手动拉取模型，有没有一种方式可以一键安装<em>ollama</em>然后同时部署指定的模型。</p><p>因为<em>ollama</em> **暂时不支持 *<em>将模型推送到私有仓库，考虑到有些人或者被要求不允许访问境外网络，所以就无法通过直接拉取</em>ollama*模型仓库的方式来做。</p><p>我们可以通过将模型文件导出的方式，然后安装完成<em>ollama</em>后以重新创建模型的方式还原模型。</p><p>我是通过<code>docker-compose</code>的方式来实现这个功能：</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>文件结构如下：</p><p><img src="https://image.seeyourface.cn/2024/05/image-20240530150803918.png" alt="image-20240530150803918"></p><ul><li><p>Dockerfile：docker-compose运行时构建容器文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ollama/ollama <span class="hljs-comment">##基础镜像可以修改为自己私有仓库中的镜像，或者可以直接使用docker官方提供的ollama/ollama</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./run_ollama.sh /tmp/run_ollama.sh</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./Modelfile /tmp/Modelfile</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./sha256-242ac8dd3eabcb1e5fcd3d78912eaf904f08bb6ecfed8bac9ac9a0b7a837fcb8 /tmp/sha256-242ac8dd3eabcb1e5fcd3d78912eaf904f08bb6ecfed8bac9ac9a0b7a837fcb8</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /tmp</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> +x run_ollama.sh</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure></li><li><p>docker-compose：启动文件</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3.5&#x27;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">ollama</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">context</span><span class="hljs-punctuation">:</span> <span class="hljs-string">.</span><br>      <span class="hljs-attribute">dockerfile</span><span class="hljs-punctuation">:</span> <span class="hljs-string">./Dockerfile</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">ollama</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">ollama</span><br>    <span class="hljs-attribute">entrypoint</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/tmp/run_ollama.sh</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">8000:8000</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">OLLAMA_HOST=0.0.0.0:8000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">OLLAMA_MODELS=/data/models</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/models/:/data/models</span><br>    <span class="hljs-attribute">pull_policy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">tty</span><span class="hljs-punctuation">:</span> <span class="hljs-string">true</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure></li><li><p>Modelfile：模型构建文件</p></li><li><p>sha256-xxx：模型文件</p></li><li><p>run_ollama.sh：启动命令脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting Ollama server...&quot;</span><br>ollama serve<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;start create model...&quot;</span><br>ollama create dcas-assistant -f ./Modelfile<br>ollama run dcas-assistant<br></code></pre></td></tr></table></figure></li></ul><h4 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h4><p><img src="https://image.seeyourface.cn/2024/05/image-20240530153105574.png" alt="image-20240530153105574"></p><p>最终我们可以将这个构建好的镜像上传到私有仓库，到时只要拉取这个镜像就可以直接运行指定模型。</p><p>：）</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型</tag>
      
      <tag>AI</tag>
      
      <tag>docker</tag>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM类加载器和双亲委派模型</title>
    <link href="/2024/01/06/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/01/06/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>在了解类加载器之前首先我们需要知道在<code>JVM</code>中类加载的过程步骤为：<strong>加载 -&gt; 连接 -&gt; 初始化</strong>。</p><p>而连接过程又可以进一步细分为三步：<strong>验证 -&gt;  准备 -&gt; 解析</strong>。</p><p><img src="https://image.seeyourface.cn/2024/01/e756e4b0cdae0889ccd514ce59cfefac.png" alt="JVM类加载过程"></p><p><strong>加载</strong>是类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>根据官方文档对类加载器的介绍：</p><blockquote><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.</p><p>Every Class object contains a reference to the ClassLoader that defined it.</p><p>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.</p></blockquote><p>意思是：</p><blockquote><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，<strong>数组类不是通过 <code>ClassLoader</code> 创建的</strong>，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p></blockquote><p>从上面的介绍可以知道:</p><ul><li><p>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</p></li><li><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</p></li><li><p>数组类不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</p></li></ul><p>总而言之，<strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序（<code>.java</code>文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p><h4 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h4><p><code>JVM</code>启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p><p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于<strong>同一个类加载器来说</strong>，相同二进制名称的类只会被加载一次。</p><p>在<code>JVM</code>中，一个类的唯一性是需要这个类本身和类加载一起才能确定的，每个类加载器都有一个独立的命名空间。</p><p>不同的类加载器，即使是同一个类字节码文件，最后在<code>JVM</code>里的类对象也不是同一个，我们可以通过下面这段代码来验证这个结论：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException,<br>            InstantiationException &#123;<br><br>        <span class="hljs-comment">// 自定义ClassLoader</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">myLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoader</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> name.substring(name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.class&quot;</span>;<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> getClass().getResourceAsStream(fileName);<br>                <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.loadClass(name);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[inputStream.available()];<br>                    inputStream.read(b);<br>                    <span class="hljs-keyword">return</span> defineClass(name, b, <span class="hljs-number">0</span>, b.length);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 自定义类加载器加载</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">myClassLoaderTest</span> <span class="hljs-operator">=</span> myLoader.loadClass(<span class="hljs-string">&quot;cn.seeyourface.ClassLoaderTest&quot;</span>).newInstance();<br>        System.out.println(myClassLoaderTest.getClass());<br>        System.out.println(myClassLoaderTest <span class="hljs-keyword">instanceof</span> cn.seeyourface.ClassLoaderTest);<br><br>        <span class="hljs-type">ClassLoaderTest</span> <span class="hljs-variable">classLoaderTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoaderTest</span>();<br>        System.out.println(classLoaderTest.getClass());<br>        System.out.println(classLoaderTest <span class="hljs-keyword">instanceof</span> cn.seeyourface.ClassLoaderTest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cn</span>.seeyourface.ClassLoaderTest<br><span class="hljs-literal">false</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cn</span>.seeyourface.ClassLoaderTest<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>可以看出，代码中使用自定义类加载器（<code>myLoader</code>）加载的类和通过应用程序类加载器加载的类不是同一个类。综上，类加载器在<code>JVM</code>中的作用有：</p><ol><li>将类的字节码文件从<code>JVM</code>外部加载到内存中</li><li>确定一个类的唯一性</li><li>提供隔离特性，为中间件开发者提供便利，例如<code>Tomcat</code></li></ol><h4 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h4><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ul><li><p>**<code>BootstrapClassLoader</code>(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 <code>null</code>，并且没有父级，主要用来加载 <code>JDK</code> 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</p></li><li><p>**<code>ExtensionClassLoader</code>(扩展类加载器)**：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</p></li><li><p>**<code>AppClassLoader</code>(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用类路径 <code>classpath</code> 下的所有 <code>jar</code> 包和类。</p></li></ul><blockquote><p>**<code>rt.jar</code>**：rt 代表<code>“RunTime”</code>，<code>rt.jar</code>是 <code>Java</code> 基础类库，包含 <code>Java doc</code> 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</p><p>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p></blockquote><p><img src="https://image.seeyourface.cn/2024/01/0c2e2eb7811f32d0b10a98c93f34e390.png" alt="类加载器层次结构"></p><p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。这是因为<code>BootstrapClassLoader</code> 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p><p>通过下面例子来打印类加载器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoaderTest.class.getClassLoader();<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tab</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;|--&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needContinue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (needContinue)&#123;<br>            System.out.println(tab.toString() + classLoader);<br>            <span class="hljs-keyword">if</span>(classLoader == <span class="hljs-literal">null</span>)&#123;<br>                needContinue = <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                classLoader = classLoader.getParent();<br>                tab.append(<span class="hljs-string">&quot;--&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">|--sun.misc.Launcher$AppClassLoader@18b4aac2<br>|----sun.misc.Launcher$ExtClassLoader@511d50c0<br>|------<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>从输出结果可以看出：</p><ul><li>我们编写的 Java 类 <code>ClassLoaderTest</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li><li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是<code>ExtClassLoader</code>；</li><li><code>ExtClassLoader</code>的父<code>ClassLoader</code>是<code>Bootstrap ClassLoader</code>，因此输出结果为 null。</li></ul><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，也需要继承 <code>ClassLoader</code>抽象类。</p><p><code>ClassLoader</code> 类有两个关键的方法：</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li><li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><p>官方 API 文档中写到：</p><blockquote><p>Subclasses of <code>ClassLoader</code> are encouraged to override <code>findClass(String name)</code>, rather than this method.</p><p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p></blockquote><p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p><p>通过自定义类加载器我们可以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ <code>.class</code> 文件）进行加密，加载时再利用自定义的类加载器对其解密。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>光内置的类加载器就有三种之多，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？双亲委派模型会给你答案。</p><p>根据官网的介绍：</p><blockquote><p>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.</p></blockquote><p>翻译过来大概的意思是：</p><blockquote><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。每个 <code>ClassLoader</code> 实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。<br>虚拟机中被称为 “<code>bootstrap class loader</code>“的内置类加载器本身没有父类加载器，但是可以作为 <code>ClassLoader</code> 实例的父类加载器。</p></blockquote><p>从上面的介绍可以看出：</p><ul><li><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li><li><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li></ul><p>下图展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型(Parents Delegation Model)**”。</p><p><img src="https://image.seeyourface.cn/2024/01/0c2e2eb7811f32d0b10a98c93f34e390.png" alt="类加载器层次结构"></p><p><strong>注意 ⚠️</strong>：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p><p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>  ...<br>  <span class="hljs-comment">// 组合</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ClassLoader</span><span class="hljs-params">(ClassLoader parent)</span> &#123;<br>       <span class="hljs-built_in">this</span>(checkCreateClassLoader(), parent);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h4><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">//首先，检查该类是否已经加载过</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果 c 为 null，则说明该类没有被加载过</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span><br>                <span class="hljs-comment">//用户可通过覆写该方法，来自定义类加载器</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">//用于统计类加载器相关的信息</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            <span class="hljs-comment">//对类进行link操作</span><br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p><p>结合源码，简单总结一下双亲委派模型的执行流程：</p><ul><li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li><li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</li></ul><p>🌈 拓展：</p><blockquote><p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p></blockquote><h4 id="打破双亲委派的方法"><a href="#打破双亲委派的方法" class="headerlink" title="打破双亲委派的方法"></a>打破双亲委派的方法</h4><p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p><p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p><blockquote><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p></blockquote><p>重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。</p><p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p><p><img src="https://image.seeyourface.cn/2024/01/6c83c58cc5b97edca3ef2db2abe6ae7b.png" alt="tomcat-class-loader-parents-delegation-model"></p><p>Tomcat 这四个自定义的类加载器对应的目录如下：</p><ul><li><code>CommonClassLoader</code>对应<code>&lt;Tomcat&gt;/common/*</code></li><li><code>CatalinaClassLoader</code>对应<code>&lt;Tomcat &gt;/server/*</code></li><li><code>SharedClassLoader</code>对应 <code>&lt;Tomcat &gt;/shared/*</code></li><li><code>WebAppClassloader</code>对应 <code>&lt;Tomcat &gt;/webapps/&lt;app&gt;/WEB-INF/*</code></li></ul><p>从图中的委派关系中可以看出：</p><ul><li><code>CommonClassLoader</code>作为 <code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 的父加载器。<code>CommonClassLoader</code> 能加载的类都可以被 <code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 使用。因此，<code>CommonClassLoader</code> 是为了实现公共类库（可以被所有 Web 应用和 Tomcat 内部组件使用的类库）的共享和隔离。</li><li><code>CatalinaClassLoader</code> 和 <code>SharedClassLoader</code> 能加载的类则与对方相互隔离。<code>CatalinaClassLoader</code> 用于加载 Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web 应用的类。<code>SharedClassLoader</code> 作为 <code>WebAppClassLoader</code> 的父加载器，专门来加载 Web 应用之间共享的类比如 Spring、Mybatis。</li><li>每个 Web 应用都会创建一个单独的 <code>WebAppClassLoader</code>，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 <code>WebAppClassLoader</code>。各个 <code>WebAppClassLoader</code> 实例之间相互隔离，进而实现 Web 应用之间的类隔。</li></ul><p>单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。</p><p>比如，SPI 中，SPI 的接口（如 <code>java.sql.Driver</code>）是由 Java 核心库提供的，由<code>BootstrapClassLoader</code> 加载。而 SPI 的实现（如<code>com.mysql.cj.jdbc.Driver</code>）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载 SPI 的接口的类加载器（<code>BootstrapClassLoader</code>）也会用来加载 SPI 的实现。按照双亲委派模型，<code>BootstrapClassLoader</code> 是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。</p><p>再比如，假设我们的项目中有 Spring 的 jar 包，由于其是 Web 应用之间共享的，因此会由 <code>SharedClassLoader</code> 加载（Web 服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了 Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring 的类加载器（也就是 <code>SharedClassLoader</code>）也会用来加载这些业务类。但是业务类在 Web 应用目录下，不在 <code>SharedClassLoader</code> 的加载路径下，所以 <code>SharedClassLoader</code> 无法找到业务类，也就无法加载它们。</p><p>如何解决这个问题呢？ 这个时候就需要用到 <strong>线程上下文类加载器（<code>ThreadContextClassLoader</code>）</strong> 了。</p><p>拿 Spring 这个例子来说，当 Spring 需要加载业务类的时候，它不是用自己的类加载器，而是用当前线程的上下文类加载器。还记得我上面说的吗？每个 Web 应用都会创建一个单独的 <code>WebAppClassLoader</code>，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 <code>WebAppClassLoader</code>。这样就可以让高层的类加载器（<code>SharedClassLoader</code>）借助子类加载器（ <code>WebAppClassLoader</code>）来加载业务类，破坏了 Java 的类加载委托机制，让应用逆向使用类加载器。</p><p>线程线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用。这个类加载器通常是由应用程序或者容器（如 Tomcat）设置的。</p><p><code>Java.lang.Thread</code> 中的<code>getContextClassLoader()</code>和 <code>setContextClassLoader(ClassLoader cl)</code>分别用来获取和设置线程的上下文类加载器。如果没有通过<code>setContextClassLoader(ClassLoader cl)</code>进行设置的话，线程将继承其父线程的上下文类加载器。</p><p>Spring 获取线程线程上下文类加载器的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cl = Thread.currentThread().getContextClassLoader();<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>深入分析 Java ClassLoader 原理：<a href="https://blog.csdn.net/xyang81/article/details/7292380">https://blog.csdn.net/xyang81/article/details/7292380</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Java 类加载器(ClassLoader)：<a href="http://gityuan.com/2016/01/24/java-classloader/">http://gityuan.com/2016/01/24/java-classloader/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Class ClassLoader - Oracle 官方文档：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html">https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://javaguide.cn/java/jvm/classloader.html">https://javaguide.cn/java/jvm/classloader.html</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>类加载器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>类加载器</tag>
      
      <tag>双亲委派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次Spring boot本地启动报IllegalAccessError异常原因</title>
    <link href="/2024/01/05/%E8%AE%B0%E4%B8%80%E6%AC%A1Spring%20boot%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E6%8A%A5IllegalAccessError%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0/"/>
    <url>/2024/01/05/%E8%AE%B0%E4%B8%80%E6%AC%A1Spring%20boot%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E6%8A%A5IllegalAccessError%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>最近项目接入公司一个 <code>SSO</code> 统一身份认证组件，这里简单说明一下：</p><p>组件提供的自动配置类启动时如果 <code>UserCenterActivated</code> 这个<code>Bean</code>不存在的话会使用组件默认的用户激活组件，然后我是在项目中实现了自己的一个用户激活类并继承了<code>UserCenterActivated</code>抽象类。</p><p><img src="https://image.seeyourface.cn/2024/01/image-20240105162049473.png" alt="image-20240105162049473"></p><p>项目启动时奇怪的出现了以下错误：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">class xxx.sso.support.<span class="hljs-built_in">$</span>Proxy130 cannot access its superinterface xxx.sso.support.AppRegistryInfo<br></code></pre></td></tr></table></figure><p>并且该情况只在本地出现，打包部署到服务器并未出现问题。</p><p>所以我判断肯能与本地的<code>maven</code>插件有关，因为有些<code>maven</code>插件只有在开发中生效。</p><p>最终定位到是由于<code>spring-boot-devtools</code>这个插件导致的。</p><h3 id="热部署插件"><a href="#热部署插件" class="headerlink" title="热部署插件"></a>热部署插件</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><code>spring-boot-devtools</code>插件支持在<code>spring-boot</code>开发中对项目修改的代码进行快速部署，而无需重启<code>JVM</code>的一款工具。</p><p>使用<code>spring-boot-devtools</code>，可以实现指定目录（默认为<code>classpath</code>路径）下的文件进行更改后，项目自动重启，更改后的代码自动生效。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>根据官方的定义：<code>spring-boot-devtools</code>使用了两个类加载器<code>ClassLoader</code>，一个<code>ClassLoader</code>加载不会发生更改的类（<strong>第三方jar包</strong>）一般是应用类加载器，我们暂且叫他 <code>base ClassLoader</code>，另一个<code>ClassLoader</code>（<code>restart ClassLoader</code>）加载会更改的类（<strong>自定义的类</strong>）。</p><p>默认情况下，<code>IDE</code> 中的任何打开项目都使用<code>restart</code>类加载器加载，而普通的<code>jar</code> 文件则使用<code>base</code>类加载器加载。如果使用 <code>mvn spring-boot:run</code> 或 <code>gradle bootRun</code>，情况也是如此: 包含 <code>@SpringBootApplication</code> 的项目使用<code>restart</code>类加载器加载，其他所有内容使用<code>base</code>类加载器加载。</p><p><img src="https://image.seeyourface.cn/2024/01/image-20240105173751969.png" alt="image-20240105173751969"></p><p>这就导致我项目中的代码都是由<code>restart ClassLoader</code>加载器加载的，而我引入的组件<code>jar</code>包是由<code>app ClassLoader</code>加载的，这就可能会导致一些类加载问题，特别是在多模块项目中。</p><p><code>SSO</code>组件在第三方<code>jar</code>包中，这将导致<code>DevTools</code>的重新启动类加载器出现问题。代理对象是由<code>restart</code>类加载器加载的，但被代理对象本身是由应用类加载器加载，因此会导致<code>IllegalAccessError</code>。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>大力出奇迹，删掉或者注释掉<code>spring-boot-devtools</code>插件。</li><li>在<code>META-INF/spring-devtools.properties</code>中设置<code>restart.include.projectcommon=被代理对象所在的jar</code>，保证代理对象和被代理对象使用同一个类加载器。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using.devtools.diagnosing-classloading-issues">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using.devtools.diagnosing-classloading-issues</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双亲委派</tag>
      
      <tag>热部署</tag>
      
      <tag>devtools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将白嫖进行到底——记一次网站服务迁移国外服务器流程</title>
    <link href="/2023/11/30/%E5%B0%86%E7%99%BD%E5%AB%96%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E8%BF%81%E7%A7%BB%E5%9B%BD%E5%A4%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/11/30/%E5%B0%86%E7%99%BD%E5%AB%96%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E8%BF%81%E7%A7%BB%E5%9B%BD%E5%A4%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>先简单介绍一下这个网站吧，域名是几年前在阿里云买的，当时也入手了个服务器用于部署毕设项目，为了能正常访问网站也是备案过一次，服务器到期之后就没管了，但一直有在续域名。</p><p>两个月前用域名搭了一个博客，服务器白嫖的<code>Github Page</code>，图床使用的阿里云的<code>OSS</code>。（重点：公开访问！）</p><p>运行了小两月都没什么事情，直到在<code>V2</code>看到有人<code>OSS</code>存储被盗刷，损失好几千，吓得我赶紧开通了阿里的<code>CDN</code>服务，把<code>Bucket</code>私有化，然后用<code>CND</code>回源到<code>OSS</code>存储，给<code>CND</code>加上了各种流量控制，访问控制。</p><p>正当我以为一切都是如此美妙的时候，阿里云给我发来了信息，不到一个小时就把<code>CND</code>域名下线了…</p><p><img src="https://image.seeyourface.cn/2023/11/2831f367c963dcf89ec44173f06a6e3.jpg" alt="2831f367c963dcf89ec44173f06a6e3"></p><p>总之，只要将域名解析到了国内的空间就需要备案，否则就会限制域名无法访问。</p><p>无奈于备案流程实在繁琐冗长，况且我这小小网站根本没有国内服务器，备案还需要另外花费金币购买服务码，既然如此，那就将白嫖进行到底！</p><p>经过一番搜寻，我选择使用 <code>Backblzae b2</code> 作为图床，使用 <code>Cloudflare</code> 域名服务商做<code>DNS</code>解析和<code>CDN</code>代理工作。</p><h3 id="Backblaze"><a href="#Backblaze" class="headerlink" title="Backblaze"></a>Backblaze</h3><h4 id="为什么选择B2"><a href="#为什么选择B2" class="headerlink" title="为什么选择B2"></a>为什么选择B2</h4><p>最主要的原因是它免费、便宜！</p><p>存储前<code>10GB</code>内容完全免费，超过<code>10GB</code>的部分收取<code>6$/month</code>的费用。</p><p>对于我来说<code>10GB</code>的存储容量绝对是够够的。</p><h4 id="创建Bucket"><a href="#创建Bucket" class="headerlink" title="创建Bucket"></a>创建Bucket</h4><p>首先你需要注册一个账号，然后点击创建桶，填写<code>Bucket</code>名称，注意这个名称必须是唯一的。</p><p>桶的访问权限设置为<code>Public</code>，剩余参数全部默认即可。</p><p><img src="https://image.seeyourface.cn/2023/11/image-20231130171713075.png" alt="image-20231130171713075"></p><p>创建完之后CORS规则选择’与所有HTTPS来源共享此存储桶中的所有内容’。</p><p><img src="https://image.seeyourface.cn/2023/11/image-20231130174423601.png" alt="image-20231130174423601"></p><p>桶设定默认是不缓存，我们可以设置资源过期时间：</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201092749937.png" alt="image-20231201092749937"></p><p>点击上传&#x2F;下载按钮，随便上传一张图片，查看图片信息：</p><p><img src="https://image.seeyourface.cn/2023/11/image-20231130174840316.png" alt="image-20231130174840316"></p><p>现在我们可以直接通过友好URL访问这张图片。</p><p>记住友好URL中的域名部分，后续<code>Cloudflare</code>代理时需要用到。</p><h4 id="Picgo配置默认图床"><a href="#Picgo配置默认图床" class="headerlink" title="Picgo配置默认图床"></a>Picgo配置默认图床</h4><p>如果不想每次上传文件都打开<code>Backblaze</code>网站，可以使用<code>Pigco</code>软件配置默认图床上传。</p><h4 id="添加应用密钥"><a href="#添加应用密钥" class="headerlink" title="添加应用密钥"></a>添加应用密钥</h4><p>进入页面左侧<code>Application keys</code>点击 <code>Add a new Application Key</code>创建一个应用密钥，随便填写一个密钥名字然后选择要授权的<code>Bucket</code>和读写权限。</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201142023112.png" alt="image-20231201142023112"></p><h4 id="配置Picgo"><a href="#配置Picgo" class="headerlink" title="配置Picgo"></a>配置Picgo</h4><p>插件设置中搜索<code>S3</code>下载安装<code>amazon s3 uploader</code>插件，填写刚才生成的应用密钥和ID，地区填写你的<code>Bucket Endpoint</code>第二部分的内容，例如我这里是<code>us-east-005</code>。自定义节点填写<code>Endpoint</code>，自定义域名可以帮助我们上传成功后将Endpoint的域名替换为我们自己的域名。</p><p>配置完成就可以上传图片了。</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201142431185.png" alt="image-20231201142431185"></p><h3 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h3><p>通过<code>Cloudflare</code>访问<code>Backblaze</code>的流量是完全免费的，只不过不绑定卡的话每天只有2500次免费请求。</p><h4 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h4><p>如果你没有域名，可以购买一个域名，如果你已经有一个域名了，在页面左侧的<code>website</code>添加你的顶级域名到<code>Cloudflare</code>，然后在你的域名注册商将你的域名服务器修改为<code>Cloudflare</code>提供的服务器（一般是在域名管理中）。</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201144323838.png" alt="image-20231201144323838"></p><h4 id="添加域名解析记录"><a href="#添加域名解析记录" class="headerlink" title="添加域名解析记录"></a>添加域名解析记录</h4><p>第一个表示将二级域名<code>image.seeyourface.cn</code>解析到<code>Backblaze</code>的图床节点，第二三条表示将<code>seeyourface.cn</code>和<code>www.seeyourface.cn</code>解析到<code>github page</code>。</p><p>右边黄色的云朵表示<code>Cloudflare</code>将代理你的请求，例如做一些缓存策略等等。</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201144613653.png" alt="image-20231201144613653"></p><h4 id="开启严格的SSL加密模式"><a href="#开启严格的SSL加密模式" class="headerlink" title="开启严格的SSL加密模式"></a>开启严格的SSL加密模式</h4><p>完成上面的步骤后，你可能无法访问你的图片和网站，因为图床是使用<code>https</code>访问的，<code>github page</code>如果开启了强制<code>https</code>访问，你可能会收到<code>301 Moved Permanently</code>的错误信息。</p><p>这时候需要点击左侧的<code>SSL/TLS</code>页面，开启严格加密模式。第三个选项表示接受自签名证书，第四个表示只接受受信任的证书。</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201145728771.png" alt="image-20231201145728771"></p><p>这时你才可以使用<code>https://image.yourdomain.com/file/&#123;bucketName&#125;/default.png</code>所示格式来访问你的图片。</p><p>这种URL会暴露我们的<code>BucketName</code>，<code>Cloudflare</code>提供了<code>URL Path</code>的规则转换。</p><h4 id="请求路径转换"><a href="#请求路径转换" class="headerlink" title="请求路径转换"></a>请求路径转换</h4><p>选择左侧：Rules -&gt; Transform Rules -&gt; Rewrite URL -&gt; Create Rule</p><p>自定义过滤条件：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">(http.host eq &quot;image.seeyourface.cn&quot; and http.request.uri.path ne &quot;/file/&#123;bucketName&#125;&quot;)<br></code></pre></td></tr></table></figure><p>匹配成功则动态重写为：concat(“&#x2F;file&#x2F;{bucketName}”,http.request.uri.path)</p><p>替换为你自己的域名和bucket名称</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201151642557.png" alt="image-20231201151642557"></p><p>然后就可以通过你的域名 + 图片存储路径来访问你的图片，这样就隐藏了你的<code>Bucket</code>名称。</p><h4 id="清除响应头"><a href="#清除响应头" class="headerlink" title="清除响应头"></a>清除响应头</h4><p>相同的页面选择<code>Modify Response header</code>页签，添加一条规则：</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201153943747.png" alt="image-20231201153943747"></p><p>再添加一条规则，让你的<code>URL</code>可以在外部任意访问：</p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201154051058.png" alt="image-20231201154051058"></p><p><img src="https://image.seeyourface.cn/2023/12/image-20231201154115816.png" alt="image-20231201154115816"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>恭喜你，你已经完成所有操作，可以愉快访问你的网站了！</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.backblaze.com/blog/free-image-hosting-with-cloudflare-transform-rules-and-backblaze-b2/#:~:text=Backblaze%20only%20supports%20secure%20HTTPS%20connections%2C%20so%20the,Backblaze%20via%20HTTPS%2C%20and%20requires%20a%20CA-issued%20certificate">https://www.backblaze.com/blog/free-image-hosting-with-cloudflare-transform-rules-and-backblaze-b2/#:~:text=Backblaze%20only%20supports%20secure%20HTTPS%20connections%2C%20so%20the,Backblaze%20via%20HTTPS%2C%20and%20requires%20a%20CA-issued%20certificate</a>.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://developers.cloudflare.com/ssl/troubleshooting/too-many-redirects/">https://developers.cloudflare.com/ssl/troubleshooting/too-many-redirects/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>网站</category>
      
      <category>迁移</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDN</tag>
      
      <tag>图床</tag>
      
      <tag>DNS</tag>
      
      <tag>迁移</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅切换联表查询表格所使用的Schema</title>
    <link href="/2023/11/16/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%88%87%E6%8D%A2%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2%E8%A1%A8%E6%A0%BC%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84Schema/"/>
    <url>/2023/11/16/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%88%87%E6%8D%A2%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2%E8%A1%A8%E6%A0%BC%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84Schema/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>前面提到过通过动态数据源实现多个数据源之间的连接，本以为能够实现我的多版本知识库切换需求。</p><p>但是！如果不出意外肯定就要出意外了！</p><p>项目中存在大量联表查询语句，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> t1<br>         <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2 <span class="hljs-keyword">on</span> t1.template_id <span class="hljs-operator">=</span> t2.id<br>         <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t3 <span class="hljs-keyword">on</span> t3.template_id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure><p>对于知识库版本的切换需求，<code>t2</code>、<code>t3</code> 是知识库中的表，它们需要根据知识库的更新而使用不同版本的表，而 <code>t1</code> 则是项目中的主表（可以理解为作业表）。</p><p>如果使用动态数据源的方式来实现这个需求，因为动态数据源切换连接时整个 <code>sql</code> 所处的环境都会被切换，所以就需要将项目中所有这种联表查询给拆出来，容易遗漏不说，还十分麻烦。</p><p>通过多数据源来实现知识版本库的切换行不通，那我们可以尝试通过多 <code>Schema</code> 来实现，因为 <code>SQL</code> 是可以跨 <code>Schema</code> 执行的。</p><p>所以最终的方案主体逻辑为：</p><ul><li>客户端新建作业时绑定知识库版本</li><li>客户端更新知识库时，新建一个 <code>Schema</code> 保存新版本的知识库表</li><li>执行 <code>SQL</code> 时根据作业 <code>id</code> 获取对应知识库版本，将查询表替换为指定 <code>Schema</code> 中的表</li></ul><h3 id="服务端调整"><a href="#服务端调整" class="headerlink" title="服务端调整"></a>服务端调整</h3><p>相较于原来备份时的 <code>TRUNCATE TABLE</code> 命令，调整为服务端给当前知识库版本打标签时，备份出当前知识库表和数据，并添加创建 <code>Schema</code> 命令。</p><h4 id="组装SQL"><a href="#组装SQL" class="headerlink" title="组装SQL"></a>组装SQL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@RequiredArgsConstructor</span><br>public class LibraryDumpHandler &#123;<br>    private <span class="hljs-keyword">final</span> Environment environment;<br>    private <span class="hljs-keyword">final</span> DcasProperties properties;<br><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 核心线程数<br>    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> CORE_THREADS <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors() <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>    private <span class="hljs-keyword">final</span> ReentrantLock mainLock <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    public String dump(String version) &#123;<br>        mainLock.lock();<br>        ExecutorService executorService <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>                CORE_THREADS, CORE_THREADS,<br>                <span class="hljs-number">0</span>,<br>                TimeUnit.MILLISECONDS,<br>                <span class="hljs-keyword">new</span> LinkedBlockingQueue<span class="hljs-operator">&lt;&gt;</span>(<span class="hljs-number">100</span>),<br>                <span class="hljs-keyword">new</span> ThreadFactoryBuilder().setNameFormat(&quot;dump-async-name-%d&quot;).setDaemon(<span class="hljs-literal">true</span>).build());<br>        try &#123;<br>            <span class="hljs-keyword">Set</span><span class="hljs-operator">&lt;</span>TableBean<span class="hljs-operator">&gt;</span> tableBeans <span class="hljs-operator">=</span> buildDumpTables();<br>            <span class="hljs-keyword">final</span> DataSource dataSource <span class="hljs-operator">=</span> getDataSource();<br>            Assert.notEmpty(tableBeans);<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 创建异步任务并使用自定义线程池执行<br>            List<span class="hljs-operator">&lt;</span>CompletableFuture<span class="hljs-operator">&lt;</span>StrBuilder<span class="hljs-operator">&gt;&gt;</span> futureList <span class="hljs-operator">=</span> tableBeans.stream().map(bean <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><br>                    CompletableFuture.supplyAsync(() <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> tableDump(dataSource, bean, version), executorService)<br>            ).<span class="hljs-keyword">collect</span>(Collectors.toList());<br>            CompletableFuture<span class="hljs-operator">&lt;</span>Void<span class="hljs-operator">&gt;</span> allFutures <span class="hljs-operator">=</span> CompletableFuture.allOf(futureList.toArray(<span class="hljs-keyword">new</span> CompletableFuture[<span class="hljs-number">0</span>]));<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 等待所有异步任务完成<br>            allFutures.join();<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 合并所有异步任务结果<br>            CompletableFuture<span class="hljs-operator">&lt;</span>StrBuilder<span class="hljs-operator">&gt;</span> mergedFuture <span class="hljs-operator">=</span> allFutures.thenApply(voidResult <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> &#123;<br>                StrBuilder mergedResult <span class="hljs-operator">=</span> StrBuilder.create();<br>                <span class="hljs-keyword">for</span> (CompletableFuture<span class="hljs-operator">&lt;</span>StrBuilder<span class="hljs-operator">&gt;</span> future : futureList) &#123;<br>                    try &#123;<br>                        mergedResult.append(future.get());<br>                    &#125; catch (InterruptedException <span class="hljs-operator">|</span> ExecutionException e) &#123;<br>                        log.error(e.getMessage());<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> mergedResult;<br>            &#125;);<br>            StrBuilder tableSqlBuilder <span class="hljs-operator">=</span> mergedFuture.get();<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 创建schema <span class="hljs-keyword">sql</span><br>            StrBuilder schemaSqlBuilder <span class="hljs-operator">=</span> schemaBuilder(version);<br>            StrBuilder sqlBuilder <span class="hljs-operator">=</span> schemaSqlBuilder.append(StrUtil.LF).append(StrUtil.LF).append(tableSqlBuilder);<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 导出文件<br>            String path <span class="hljs-operator">=</span> properties.getDumpPath();<br>            FileUtil.mkdir(path);<br>            String fileName <span class="hljs-operator">=</span> String.format(&quot;contentLibrary-%s.sql&quot;, version);<br>            String absolutePath <span class="hljs-operator">=</span> Func.wrapFilePath(path) <span class="hljs-operator">+</span> fileName;<br>            File file <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> File(absolutePath);<br>            FileWriter sqlFile <span class="hljs-operator">=</span> FileWriter.create(file);<br>            sqlFile.write(sqlBuilder.toString());<br><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 前面的步骤正常执行再打包图片、<span class="hljs-keyword">sql</span>权限查询文件<br>            CompletableFuture.supplyAsync(() <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> zipFolder(properties.getSqlPath(), properties.getDumpPath(),&quot;sql.zip&quot;), executorService);<br>            CompletableFuture.supplyAsync(() <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> zipFolder(properties.getImagePath(), properties.getDumpPath(),&quot;images.zip&quot;), executorService);<br><br>            <span class="hljs-keyword">return</span> absolutePath;<br>        &#125; catch (Exception e) &#123;<br>            throw <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125; finally &#123;<br>            executorService.shutdown();<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打包文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param targetPath 需要打包的文件目录</span><br><span class="hljs-comment">     * @param destPath 压缩文件存放路径</span><br><span class="hljs-comment">     * @param zipName 压缩文件名</span><br><span class="hljs-comment">     */</span><br>    private String zipFolder(String targetPath, String destPath, String zipName) &#123;<br>        FileUtil.mkdir(targetPath);<br>        log.info(&quot;[知识库备份] 开始备份文件夹，path:&#123;&#125;&quot;, targetPath);<br>        try (FileOutputStream fos <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> FileOutputStream(destPath <span class="hljs-operator">+</span> StrUtil.SLASH <span class="hljs-operator">+</span> zipName);<br>             ZipOutputStream zos <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ZipOutputStream(fos)) &#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> addTemplate files <span class="hljs-keyword">to</span> the ZIP file<br>            File directory <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> File(targetPath);<br>            File[] files <span class="hljs-operator">=</span> directory.listFiles();<br>            if (Objects.isNull(files) <span class="hljs-operator">||</span> files.length <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>) &#123;<br>                log.info(&quot;[知识库备份] 无需备份文件，targetPath:&#123;&#125;&quot;, targetPath);<br>                <span class="hljs-keyword">return</span> zipName;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (File file : files) &#123;<br>                if (<span class="hljs-operator">!</span>file.isDirectory()) &#123;<br>                    ZipEntry zipEntry <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ZipEntry(file.getName());<br>                    zos.putNextEntry(zipEntry);<br><br>                    FileInputStream fis <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> FileInputStream(file);<br>                    byte[] buffer <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> byte[<span class="hljs-number">4096</span>];<br>                    <span class="hljs-type">int</span> length;<br>                    while ((length <span class="hljs-operator">=</span> fis.read(buffer)) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>) &#123;<br>                        zos.write(buffer, <span class="hljs-number">0</span>, length);<br>                    &#125;<br>                    fis.close();<br>                    zos.closeEntry();<br>                    log.info(&quot;[知识库备份] 文件&#123;&#125;导出成功&quot;, file.getName());<br>                &#125;<br>            &#125;<br>        &#125; catch (IOException ex) &#123;<br>           log.error(&quot;Error creating ZIP file: &#123;&#125;&quot;, ex.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> zipName;<br>    &#125;<br><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 创建 Schema<br>    private StrBuilder schemaBuilder(String schema) &#123;<br>        StrBuilder sqlBuilder <span class="hljs-operator">=</span> StrBuilder.create();<br>        sqlBuilder.append(&quot;CREATE SCHEMA IF NOT EXISTS &quot;).append(&quot;\&quot;&quot;).append(schema).append(&quot;\&quot;&quot;).append(CommonConst.SEMICOLON);<br>        <span class="hljs-keyword">return</span> sqlBuilder;<br>    &#125;<br><br>    private StrBuilder tableDump(DataSource ds, TableBean <span class="hljs-keyword">table</span>, String schema) &#123;<br>        Db db <span class="hljs-operator">=</span> DbUtil.use(ds);<br>        StrBuilder sqlBuilder <span class="hljs-operator">=</span> StrBuilder.create();<br>        try &#123;<br>            String tableName <span class="hljs-operator">=</span> table.getTableName();<br>            if (table.isNeedTruncate()) &#123;<br>                sqlBuilder.append(&quot;TRUNCATE &quot;).append(schema).append(StrUtil.DOT).append(tableName);<br>                sqlBuilder.append(CommonConst.SEMICOLON <span class="hljs-operator">+</span> StrUtil.LF);<br>            &#125;<br>            if (table.isNeedCreate()) &#123;<br>                <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 这里注意，由于项目使用的是Pgsql，没有MySQL那种<span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>命令，所以自定义了一个命令根据表名获取建表语句<br>                Entity createEntity <span class="hljs-operator">=</span> db.queryOne(&quot;SELECT show_create_table(&#x27;&quot; <span class="hljs-operator">+</span> tableName <span class="hljs-operator">+</span> &quot;&#x27;)&quot;);<br>                String showCreateTable <span class="hljs-operator">=</span> (String) createEntity.get(&quot;show_create_table&quot;);<br>                String oldTable <span class="hljs-operator">=</span> &quot;\&quot;&quot; + tableName + &quot;\&quot;&quot;;<br>                String newTable <span class="hljs-operator">=</span> &quot;\&quot;&quot; + schema + &quot;\&quot;.\&quot;&quot; + tableName + &quot;\&quot;&quot;;<br>                String createTableSql <span class="hljs-operator">=</span> StrUtil.replace(showCreateTable, oldTable, newTable);<br>                sqlBuilder.append(createTableSql);<br>                sqlBuilder.append(StrUtil.LF);<br>            &#125;<br>            if (table.isNeedInsert()) &#123;<br>                List<span class="hljs-operator">&lt;</span>Entity<span class="hljs-operator">&gt;</span> dataEntities <span class="hljs-operator">=</span> db.query(&quot;SELECT * FROM &quot; <span class="hljs-operator">+</span> tableName);<br>                <span class="hljs-keyword">for</span> (Entity dataEntity : dataEntities) &#123;<br>                    StrBuilder field <span class="hljs-operator">=</span> StrBuilder.create();<br>                    StrBuilder data <span class="hljs-operator">=</span> StrBuilder.create();<br>                    dataEntity.forEach((fieldName, fieldValue) <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> &#123;<br>                        String valueStr <span class="hljs-operator">=</span> StrUtil.toStringOrNull(fieldValue);<br>                        field.append(fieldName).append(&quot;, &quot;);<br>                        if (ObjectUtil.isNotNull(valueStr)) &#123;<br>                            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 值包含 <span class="hljs-string">&#x27; 转义处理</span><br><span class="hljs-string">                            valueStr = StrUtil.replace(valueStr, &quot;&#x27;</span>&quot;, &quot;<span class="hljs-string">&#x27;&#x27;</span>&quot;);<br>                            data.append(&quot;<span class="hljs-string">&#x27;&quot;).append(valueStr).append(&quot;&#x27;</span>&quot;);<br>                        &#125; else &#123;<br>                            data.append(&quot;<span class="hljs-keyword">NULL</span>&quot;);<br>                        &#125;<br>                        data.append(&quot;, &quot;);<br>                    &#125;);<br><br>                    sqlBuilder.append(&quot;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> &quot;).append(&quot;\&quot;&quot;).append(schema).append(&quot;\&quot;&quot;).append(StrUtil.DOT).append(tableName).append(&quot;(&quot;);<br>                    // 去掉最后的逗号和空格<br>                    String fieldStr = field.subString(0, field.length() - 2);<br>                    sqlBuilder.append(fieldStr);<br>                    sqlBuilder.append(&quot;) <span class="hljs-keyword">VALUES</span> (&quot;);<br>                    String dataStr = data.subString(0, data.length() - 2);<br>                    sqlBuilder.append(dataStr);<br>                    sqlBuilder.append(&quot;);&quot;);<br>                    sqlBuilder.append(StrUtil.LF);<br>                &#125;<br>            &#125;<br>            sqlBuilder.append(StrUtil.LF);<br>            sqlBuilder.append(StrUtil.LF);<br>            sqlBuilder.append(StrUtil.LF);<br>        &#125; catch (SQLException e) &#123;<br>            log.error(&quot;数据表&#123;&#125;导出失败，msg:&#123;&#125;&quot;, table.getTableName(), e.getMessage());<br>            throw new RuntimeException(e);<br>        &#125;<br>        log.debug(&quot;数据表&#123;&#125;导出成功&quot;, table.getTableName());<br>        return sqlBuilder;<br>    &#125;<br><br>    // 获取系统数据源<br>    private DataSource getDataSource() &#123;<br>        DataSource ds;<br>        Assert.notNull(properties);<br>        try &#123;<br>            // 优先使用db.setting配置<br>            ds = DSFactory.get();<br>        &#125; catch (Exception e) &#123;<br>            // 通过自己的配置创建数据源连接池<br>            Setting setting = new Setting();<br>            setting.put(&quot;url&quot;, environment.getProperty(&quot;spring.datasource.url&quot;));<br>            setting.put(&quot;username&quot;, environment.getProperty(&quot;spring.datasource.username&quot;));<br>            setting.put(&quot;password&quot;, environment.getProperty(&quot;spring.datasource.password&quot;));<br>            try &#123;<br>                DSFactory dsFactory = DSFactory.create(setting);<br>                // 设置全局数据源工厂，下次获取无需重新创建<br>                DSFactory.setCurrentDSFactory(dsFactory);<br>                return DSFactory.get();<br>            &#125; catch (Exception ex) &#123;<br>                log.error(&quot;通过配置创建数据源失败&quot;);<br>                throw new RuntimeException(ex);<br>            &#125;<br>        &#125;<br>        return ds;<br>    &#125;<br><br>    // 从项目配置文件中获取需要备份的表封装成Bean<br>    private Set&lt;TableBean&gt; buildDumpTables() &#123;<br>        SqlDumpProperties sqlDumpProperties = properties.getSqlDump();<br>        Assert.notNull(sqlDumpProperties);<br>        return Arrays.stream(sqlDumpProperties.getTables().split(StrUtil.COMMA)).map(table -&gt;<br>            TableBean.builder()<br>                    .tableName(table.trim())<br>                    .needCreate(sqlDumpProperties.isCreate())<br>                    .needInsert(sqlDumpProperties.isInsert())<br>                    .needTruncate(sqlDumpProperties.isTruncate())<br>                    .build()<br>        ).collect(Collectors.toSet());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义查询PGSQL建表方法"><a href="#自定义查询PGSQL建表方法" class="headerlink" title="自定义查询PGSQL建表方法"></a>自定义查询PGSQL建表方法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> show_create_table(in_table_name <span class="hljs-type">character</span> <span class="hljs-type">varying</span>) <span class="hljs-keyword">returns</span> text<br>    <span class="hljs-keyword">language</span> plpgsql<br><span class="hljs-keyword">as</span><br>$$<br><span class="hljs-keyword">DECLARE</span><br>    <span class="hljs-comment">-- the ddl we&#x27;re building</span><br>    v_table_ddl text;<br><br>    <span class="hljs-comment">-- data about the target table</span><br>    v_table_oid <span class="hljs-type">int</span>;<br><br>    v_table_type <span class="hljs-type">char</span>;<br>    v_partition_key <span class="hljs-type">varchar</span>;<br>    v_namespace <span class="hljs-type">varchar</span>;<br>    v_table_comment <span class="hljs-type">varchar</span>;<br><br>    <span class="hljs-comment">-- records for looping</span><br>    v_column_record record;<br>    v_constraint_record record;<br>    v_index_record record;<br>    v_column_comment_record record;<br>    v_index_comment_record record;<br>    v_constraint_comment_record record;<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">-- grab the oid of the table;</span><br><span class="hljs-keyword">SELECT</span> c.oid, c.relkind, n.nspname <span class="hljs-keyword">INTO</span> v_table_oid, v_table_type, v_namespace<br><span class="hljs-keyword">FROM</span> pg_catalog.pg_class c<br>         <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> pg_catalog.pg_namespace n <span class="hljs-keyword">ON</span> n.oid <span class="hljs-operator">=</span> c.relnamespace<br><span class="hljs-keyword">WHERE</span> c.relkind <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>)<br>  <span class="hljs-keyword">AND</span> c.relname <span class="hljs-operator">=</span> in_table_name <span class="hljs-comment">-- the table name</span><br>  <span class="hljs-keyword">AND</span> pg_catalog.pg_table_is_visible(c.oid); <span class="hljs-comment">-- the schema</span><br><br><span class="hljs-comment">-- throw an error if table was not found</span><br>IF (v_table_oid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">THEN</span><br>        RAISE EXCEPTION <span class="hljs-string">&#x27;table does not exist&#x27;</span>;<br><span class="hljs-keyword">END</span> IF;<br><br>    <span class="hljs-comment">-- start the create definition</span><br>    v_table_ddl :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CREATE TABLE &quot;&#x27;</span> <span class="hljs-operator">||</span> in_table_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; (&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-comment">-- define all of the columns in the table;</span><br><span class="hljs-keyword">FOR</span> v_column_record <span class="hljs-keyword">IN</span><br><span class="hljs-keyword">SELECT</span><br>    c.column_name,<br>    c.data_type,<br>    c.character_maximum_length,<br>    c.is_nullable,<br>    c.column_default<br><span class="hljs-keyword">FROM</span> information_schema.columns c<br><span class="hljs-keyword">WHERE</span> table_name <span class="hljs-operator">=</span> in_table_name <span class="hljs-keyword">and</span> table_schema <span class="hljs-operator">=</span> v_namespace<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ordinal_position<br>    LOOP<br>            v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;  &#x27;</span> <span class="hljs-comment">-- <span class="hljs-doctag">note:</span> two char spacer to start, to indent the column</span><br>                               <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot;&#x27;</span> <span class="hljs-operator">||</span> v_column_record.column_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; &#x27;</span><br>                               <span class="hljs-operator">||</span> v_column_record.data_type <span class="hljs-operator">||</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> v_column_record.character_maximum_length <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span> (<span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-operator">||</span> v_column_record.character_maximum_length <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">END</span> <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; &#x27;</span><br>                               <span class="hljs-operator">||</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> v_column_record.is_nullable <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;NO&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;NOT NULL&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;NULL&#x27;</span> <span class="hljs-keyword">END</span><br>                               <span class="hljs-operator">||</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> v_column_record.column_default <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">THEN</span> (<span class="hljs-string">&#x27; DEFAULT &#x27;</span> <span class="hljs-operator">||</span> v_column_record.column_default) <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">END</span><br>                               <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">END</span> LOOP;<br><br>    <span class="hljs-comment">-- define all the constraints in the;</span><br><span class="hljs-keyword">FOR</span> v_constraint_record <span class="hljs-keyword">IN</span><br><span class="hljs-keyword">SELECT</span><br>    con.conname <span class="hljs-keyword">as</span> constraint_name,<br>    con.contype <span class="hljs-keyword">as</span> constraint_type,<br>    <span class="hljs-keyword">CASE</span><br>        <span class="hljs-keyword">WHEN</span> con.contype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;p&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- primary key constraint</span><br>        <span class="hljs-keyword">WHEN</span> con.contype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;u&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">2</span> <span class="hljs-comment">-- unique constraint</span><br>        <span class="hljs-keyword">WHEN</span> con.contype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">3</span> <span class="hljs-comment">-- foreign key constraint</span><br>        <span class="hljs-keyword">WHEN</span> con.contype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">4</span><br>        <span class="hljs-keyword">ELSE</span> <span class="hljs-number">5</span><br>        <span class="hljs-keyword">END</span> <span class="hljs-keyword">as</span> type_rank,<br>    pg_get_constraintdef(con.oid) <span class="hljs-keyword">as</span> constraint_definition<br><span class="hljs-keyword">FROM</span> pg_catalog.pg_constraint con<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_class rel <span class="hljs-keyword">ON</span> rel.oid <span class="hljs-operator">=</span> con.conrelid<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_namespace nsp <span class="hljs-keyword">ON</span> nsp.oid <span class="hljs-operator">=</span> connamespace<br><span class="hljs-keyword">WHERE</span> rel.relname <span class="hljs-operator">=</span> in_table_name<br>  <span class="hljs-keyword">AND</span> pg_catalog.pg_table_is_visible(rel.oid)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> type_rank<br>    LOOP<br>            IF v_constraint_record.constraint_type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;p&#x27;</span> <span class="hljs-keyword">THEN</span><br>                v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;  &#x27;</span><br>                                   <span class="hljs-operator">||</span> v_constraint_record.constraint_definition<br>                                   <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">ELSE</span><br>                v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;  &#x27;</span> <span class="hljs-comment">-- <span class="hljs-doctag">note:</span> two char spacer to start, to indent the column</span><br>                                   <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;CONSTRAINT&#x27;</span> <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; &#x27;</span><br>                                   <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot;&#x27;</span> <span class="hljs-operator">||</span> v_constraint_record.constraint_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; &#x27;</span><br>                                   <span class="hljs-operator">||</span> v_constraint_record.constraint_definition<br>                                   <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">END</span> IF;<br><span class="hljs-keyword">END</span> LOOP;<br><br>    <span class="hljs-comment">-- drop the last comma before ending the create statement</span><br>    v_table_ddl <span class="hljs-operator">=</span> substr(v_table_ddl, <span class="hljs-number">0</span>, length(v_table_ddl) <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-comment">-- end the create definition</span><br>    v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;)&#x27;</span>;<br><br>    IF v_table_type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;p&#x27;</span> <span class="hljs-keyword">THEN</span><br><span class="hljs-keyword">SELECT</span> pg_get_partkeydef(v_table_oid) <span class="hljs-keyword">INTO</span> v_partition_key;<br>IF v_partition_key <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span><br>            v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; PARTITION BY &#x27;</span> <span class="hljs-operator">||</span> v_partition_key;<br><span class="hljs-keyword">END</span> IF;<br><span class="hljs-keyword">END</span> IF;<br><br>    v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;;&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-comment">-- suffix create statement with all of the indexes on the table</span><br><span class="hljs-keyword">FOR</span> v_index_record <span class="hljs-keyword">IN</span><br><span class="hljs-keyword">SELECT</span> regexp_replace(idx.indexdef, <span class="hljs-string">&#x27; &quot;?&#x27;</span> <span class="hljs-operator">||</span> idx.schemaname <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot;?\.&#x27;</span> <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot;?&#x27;</span> <span class="hljs-operator">||</span> idx.tablename <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot;?&#x27;</span>, <span class="hljs-string">&#x27; &quot;&#x27;</span> <span class="hljs-operator">||</span> idx.tablename <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; &#x27;</span>) <span class="hljs-keyword">AS</span> indexdef<br><span class="hljs-keyword">FROM</span> pg_indexes idx<br>         <span class="hljs-keyword">JOIN</span> (<br>    <span class="hljs-keyword">SELECT</span> ns.nspname, cls.relname<br>    <span class="hljs-keyword">FROM</span> pg_catalog.pg_class cls<br>             <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> pg_catalog.pg_namespace ns <span class="hljs-keyword">ON</span> ns.oid <span class="hljs-operator">=</span> cls.relnamespace<br>    <span class="hljs-keyword">WHERE</span> pg_catalog.pg_table_is_visible(cls.oid)<br>) t <span class="hljs-keyword">ON</span> idx.schemaname <span class="hljs-operator">=</span> t.nspname <span class="hljs-keyword">AND</span> idx.tablename <span class="hljs-operator">=</span> t.relname<br><span class="hljs-keyword">WHERE</span> idx.tablename <span class="hljs-operator">=</span> in_table_name<br>  <span class="hljs-keyword">AND</span> idx.indexname <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">select</span> con.conname<br>    <span class="hljs-keyword">FROM</span> pg_catalog.pg_constraint con<br>             <span class="hljs-keyword">JOIN</span> pg_catalog.pg_class rel <span class="hljs-keyword">ON</span> rel.oid <span class="hljs-operator">=</span> con.conrelid<br>             <span class="hljs-keyword">JOIN</span> pg_catalog.pg_namespace nsp <span class="hljs-keyword">ON</span> nsp.oid <span class="hljs-operator">=</span> connamespace<br>    <span class="hljs-keyword">WHERE</span> rel.relname <span class="hljs-operator">=</span> in_table_name<br>      <span class="hljs-keyword">AND</span> pg_catalog.pg_table_is_visible(rel.oid)<br>)<br>    LOOP<br>            v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl<br>                               <span class="hljs-operator">||</span> v_index_record.indexdef<br>                               <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;;&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">END</span> LOOP;<br><br>    <span class="hljs-comment">-- comment on table</span><br><span class="hljs-keyword">SELECT</span> description <span class="hljs-keyword">INTO</span> v_table_comment<br><span class="hljs-keyword">FROM</span> pg_catalog.pg_description<br><span class="hljs-keyword">WHERE</span> objoid <span class="hljs-operator">=</span> v_table_oid <span class="hljs-keyword">AND</span> objsubid <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>IF v_table_comment <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span><br>        v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;COMMENT ON TABLE &quot;&#x27;</span> <span class="hljs-operator">||</span> in_table_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; IS &#x27;&#x27;&#x27;</span> <span class="hljs-operator">||</span> replace(v_table_comment, <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&#x27;&#x27;;&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">END</span> IF;<br><br>    <span class="hljs-comment">-- comment on column</span><br><span class="hljs-keyword">FOR</span> v_column_comment_record <span class="hljs-keyword">IN</span><br><span class="hljs-keyword">SELECT</span> col.column_name, d.description<br><span class="hljs-keyword">FROM</span> information_schema.columns col<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_class c <span class="hljs-keyword">ON</span> c.relname <span class="hljs-operator">=</span> col.table_name<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_namespace nsp <span class="hljs-keyword">ON</span> nsp.oid <span class="hljs-operator">=</span> c.relnamespace <span class="hljs-keyword">AND</span> col.table_schema <span class="hljs-operator">=</span> nsp.nspname<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_description d <span class="hljs-keyword">ON</span> d.objoid <span class="hljs-operator">=</span> c.oid <span class="hljs-keyword">AND</span> d.objsubid <span class="hljs-operator">=</span> col.ordinal_position<br><span class="hljs-keyword">WHERE</span> c.oid <span class="hljs-operator">=</span> v_table_oid<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col.ordinal_position<br>    LOOP<br>            v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;COMMENT ON COLUMN &quot;&#x27;</span> <span class="hljs-operator">||</span> in_table_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot;.&quot;&#x27;</span><br>                               <span class="hljs-operator">||</span> v_column_comment_record.column_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; IS &#x27;&#x27;&#x27;</span><br>                               <span class="hljs-operator">||</span> replace(v_column_comment_record.description, <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&#x27;&#x27;;&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">END</span> LOOP;<br><br>    <span class="hljs-comment">-- comment on index</span><br><span class="hljs-keyword">FOR</span> v_index_comment_record <span class="hljs-keyword">IN</span><br><span class="hljs-keyword">SELECT</span> c.relname, d.description<br><span class="hljs-keyword">FROM</span> pg_catalog.pg_index idx<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_class c <span class="hljs-keyword">ON</span> idx.indexrelid <span class="hljs-operator">=</span> c.oid<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_description d <span class="hljs-keyword">ON</span> idx.indexrelid <span class="hljs-operator">=</span> d.objoid<br><span class="hljs-keyword">WHERE</span> idx.indrelid <span class="hljs-operator">=</span> v_table_oid<br>    LOOP<br>            v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;COMMENT ON INDEX &quot;&#x27;</span><br>                               <span class="hljs-operator">||</span> v_index_comment_record.relname <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; IS &#x27;&#x27;&#x27;</span><br>                               <span class="hljs-operator">||</span> replace(v_index_comment_record.description, <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&#x27;&#x27;;&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">END</span> LOOP;<br><br>    <span class="hljs-comment">-- comment on constraint</span><br><span class="hljs-keyword">FOR</span> v_constraint_comment_record <span class="hljs-keyword">IN</span><br><span class="hljs-keyword">SELECT</span><br>    con.conname,<br>    pg_description.description<br><span class="hljs-keyword">FROM</span> pg_catalog.pg_constraint con<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_class rel <span class="hljs-keyword">ON</span> rel.oid <span class="hljs-operator">=</span> con.conrelid<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_namespace nsp <span class="hljs-keyword">ON</span> nsp.oid <span class="hljs-operator">=</span> connamespace<br>         <span class="hljs-keyword">JOIN</span> pg_catalog.pg_description <span class="hljs-keyword">ON</span> pg_description.objoid <span class="hljs-operator">=</span> con.oid<br><span class="hljs-keyword">WHERE</span> rel.oid <span class="hljs-operator">=</span> v_table_oid<br>    LOOP<br>            v_table_ddl :<span class="hljs-operator">=</span> v_table_ddl <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;COMMENT ON CONSTRAINT &quot;&#x27;</span><br>                               <span class="hljs-operator">||</span> v_constraint_comment_record.conname <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; ON &quot;&#x27;</span> <span class="hljs-operator">||</span> in_table_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&quot; IS &#x27;&#x27;&#x27;</span><br>                               <span class="hljs-operator">||</span> replace(v_constraint_comment_record.description, <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;&#x27;&#x27;;&#x27;</span> <span class="hljs-operator">||</span> E<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">END</span> LOOP;<br><br>    <span class="hljs-comment">-- return the ddl</span><br><span class="hljs-keyword">RETURN</span> v_table_ddl;<br><span class="hljs-keyword">END</span><br>$$;<br><br><span class="hljs-comment">-- 替换为你的用户</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">function</span> show_create_table(<span class="hljs-type">varchar</span>) owner <span class="hljs-keyword">to</span> your_user;<br></code></pre></td></tr></table></figure><h3 id="客户端调整"><a href="#客户端调整" class="headerlink" title="客户端调整"></a>客户端调整</h3><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>内部维护了一个栈结构保存知识库版本用于处理 <code>Schema</code> 切换的嵌套情况，例如：</p><ol><li>在某个业务逻辑中需要切换到<code>Schema A</code>。</li><li>在这个业务逻辑的某个方法内部调用了另一个方法，这个方法需要切换到<code>Schema B</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicSchemaContextHolder</span> &#123;<br><br>    <span class="hljs-comment">// 保存知识库版本</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Deque&lt;String&gt;&gt; SCHEME_KEY_HOLDER = TransmittableThreadLocal.withInitial(ArrayDeque::<span class="hljs-keyword">new</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DynamicSchemaContextHolder</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SCHEME_KEY_HOLDER.get().peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(String ds)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">schemeKeyStr</span> <span class="hljs-operator">=</span> StrUtil.isEmpty(ds) ? StrUtil.EMPTY : ds;<br>        SCHEME_KEY_HOLDER.get().push(schemeKeyStr);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        Deque&lt;String&gt; deque = SCHEME_KEY_HOLDER.get();<br>        deque.poll();<br>        <span class="hljs-keyword">if</span> (deque.isEmpty()) &#123;<br>            SCHEME_KEY_HOLDER.remove();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        SCHEME_KEY_HOLDER.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h4><p>使用一个 <code>Manager</code> 管理以下属性：</p><ul><li>默认 <code>Schema</code> ，根据版本号无法找到对应 <code>Schema</code> 时切换到默认 <code>Schema</code></li><li>知识库表，动态切换 <code>Schema</code> 时需要判断表是否存在该集合中，存在即替换，否则默认使用<code>public Schema</code></li><li>知识库版本对应的 <code>Schema</code> 名称</li><li>知识库版本对应的作业（一对多）</li></ul><p>这个类的主要作用是更新知识库时，将添加的知识库和Schema保存起来，拦截器中根据版本号获取<code>Schema</code> 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicSchemaManager</span> &#123;<br>    <span class="hljs-comment">// 默认schema</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_SCHEMA</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;public&quot;</span>;<br><br>    <span class="hljs-comment">// 最新版本知识库</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">LATEST_VERSION</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;public&quot;</span>;<br>    <span class="hljs-comment">// 保存知识库相关的表，用于在sql中判断是否需要切换schema，存在此集合中的表需要切换schema</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; SYNC_TABLE_NAMES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-comment">// key: version, value: schemaName</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; SCHEME_KEY_MAP = Maps.newConcurrentMap();<br>    <span class="hljs-comment">// key:version, value:operationId</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Multimap&lt;String, String&gt; VERSION_WORK = Multimaps.newMultimap(Maps.newHashMap(), HashSet::<span class="hljs-keyword">new</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CoOperationMapper coOperationMapper;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LibrarySyncConfigMapper librarySyncConfigMapper;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LibrarySyncTablesMapper librarySyncTablesMapper;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        List&lt;LibrarySyncConfig&gt; configs = librarySyncConfigMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;());<br>        <span class="hljs-keyword">if</span> (CollUtil.isNotEmpty(configs))<br>            configs.forEach(config -&gt; &#123;<br>                SCHEME_KEY_MAP.put(config.getVersion(), config.getSchemaName());<br>                log.info(<span class="hljs-string">&quot;dynamic-schema - add a schema named [&#123;&#125;] success&quot;</span>, config.getSchemaName());<br>                <span class="hljs-keyword">if</span> (config.getIsLatest()) &#123;<br>                    LATEST_VERSION = config.getVersion();<br>                    log.info(<span class="hljs-string">&quot;dynamic-schema - set the latest schema named [&#123;&#125;] success&quot;</span>, config.getSchemaName());<br>                &#125;<br>            &#125;);<br>        Set&lt;String&gt; librarySyncTables = librarySyncTablesMapper.selectSyncTableNames();<br>        SYNC_TABLE_NAMES.addAll(librarySyncTables);<br>        List&lt;Pair&lt;String, String&gt;&gt; pairs = coOperationMapper.selectLibraryVersion();<br>        <span class="hljs-keyword">if</span> (CollUtil.isNotEmpty(pairs))<br>            pairs.forEach(pair -&gt; VERSION_WORK.put(pair.getKey(), pair.getValue()));<br>        log.info(<span class="hljs-string">&quot;dynamic-schema - init success&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 根据版本号获取schema</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getSchema</span><span class="hljs-params">(String version)</span> &#123;<br>        <span class="hljs-keyword">if</span> (StrUtil.isEmpty(version)) &#123;<br>            <span class="hljs-keyword">return</span> determineDefaultSchema();<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">schemaName</span> <span class="hljs-operator">=</span> SCHEME_KEY_MAP.get(version);<br>        <span class="hljs-keyword">if</span> (StrUtil.isEmpty(schemaName)) &#123;<br>            schemaName = determineDefaultSchema();<br>            log.warn(<span class="hljs-string">&quot;dynamic-schema - can not find the schema named [&#123;&#125;], switch to the default schema [&#123;&#125;]&quot;</span>, version, schemaName);<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;dynamic-schema - switch to the schema named [&#123;&#125;]&quot;</span>, schemaName);<br>        <span class="hljs-keyword">return</span> schemaName;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 选择默认schema</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">determineDefaultSchema</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> DEFAULT_SCHEMA;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 添加schema</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSchema</span><span class="hljs-params">(String version, String schemaName)</span> &#123;<br>        SCHEME_KEY_MAP.put(version, schemaName);<br>        log.info(<span class="hljs-string">&quot;dynamic-schema - add a schema named [&#123;&#125;] success&quot;</span>, schemaName);<br>        LATEST_VERSION = version;<br>        log.info(<span class="hljs-string">&quot;dynamic-schema - set the latest schema named [&#123;&#125;] success&quot;</span>, schemaName);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 删除schema</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSchema</span><span class="hljs-params">(String version)</span> &#123;<br>        SCHEME_KEY_MAP.remove(version);<br>        log.info(<span class="hljs-string">&quot;dynamic-schema - remove a schema named [&#123;&#125;] success&quot;</span>, version);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 判断sql中是否包含需要切换schema的表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isContainsSyncTable</span><span class="hljs-params">(String sql)</span> &#123;<br>        <span class="hljs-keyword">return</span> SYNC_TABLE_NAMES.stream().map(String::toLowerCase).anyMatch(sql::contains);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 获取需要切换schema的表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; <span class="hljs-title function_">getSyncTableNames</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SYNC_TABLE_NAMES;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 获取版本号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getVersion</span><span class="hljs-params">(String operationId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!VERSION_WORK.containsValue(operationId))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Collection&lt;String&gt;&gt; entry : VERSION_WORK.asMap().entrySet()) &#123;<br>            Collection&lt;String&gt; values = entry.getValue();<br>            <span class="hljs-keyword">if</span> (values.contains(operationId))<br>                <span class="hljs-keyword">return</span> entry.getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 获取最新版本号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">getLatestVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LATEST_VERSION;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 添加版本号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addVersion</span><span class="hljs-params">(String version, String operationId)</span> &#123;<br>        VERSION_WORK.put(version, operationId);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 删除版本号中的作业id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeVersionWork</span><span class="hljs-params">(String operationId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!VERSION_WORK.containsValue(operationId))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Collection&lt;String&gt;&gt; entry : VERSION_WORK.asMap().entrySet()) &#123;<br>            Collection&lt;String&gt; values = entry.getValue();<br>            <span class="hljs-keyword">if</span> (values.contains(operationId)) &#123;<br>                values.remove(operationId);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义切换注解"><a href="#自定义切换注解" class="headerlink" title="自定义切换注解"></a>自定义切换注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SchemaSwitch &#123;<br><br>    <span class="hljs-comment">// 指定包含作业id的类，作业id用于查找知识库版本</span><br>    Class&lt;?&gt; value() <span class="hljs-keyword">default</span> LatestVersion.class;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><p>获取注解上配置的 <code>Class</code>，因为该<code>Class</code> 配置为包含作业 <code>id</code> 的类。</p><p>通过反射获取作业 <code>id</code>，通过作业 <code>id</code> 获取对应的知识库版本，如果版本号不为空，则放入到当前线程的本地线程变量中。</p><p>这里注意方法执行完之后要调用 <code>clear()</code> 清理，防止内存溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchemaAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.dcas.common.annotation.SchemaSwitch)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">switchSchema</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Around(&quot;switchSchema()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pointcut)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">operationId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature)pointcut.getSignature();<br>        <span class="hljs-type">SchemaSwitch</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> signature.getMethod().getAnnotation(SchemaSwitch.class);<br>        Class&lt;?&gt; clazz = annotation.value();<br>        <span class="hljs-keyword">if</span> (clazz == LatestVersion.class) &#123;<br>            <span class="hljs-comment">// 默认切换最新版本知识库</span><br>            version = DynamicSchemaManager.getLatestVersion();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Object[] args = pointcut.getArgs();<br>            <span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>                <span class="hljs-keyword">if</span> (arg.getClass() != clazz)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JSONObject.parseObject(JSON.toJSONString(arg), clazz);<br>                <span class="hljs-keyword">if</span> (clazz == String.class || clazz == Integer.class) &#123;<br>                    operationId = obj.toString();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    operationId = ReflectUtil.getFieldValue(obj, <span class="hljs-string">&quot;operationId&quot;</span>).toString();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (StrUtil.isEmpty(operationId))<br>                    <span class="hljs-keyword">continue</span>;<br>                version = DynamicSchemaManager.getVersion(operationId);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (StrUtil.isNotEmpty(version))<br>            DynamicSchemaContextHolder.push(version);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> pointcut.proceed();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            DynamicSchemaContextHolder.clear();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态替换"><a href="#动态替换" class="headerlink" title="动态替换"></a>动态替换</h3><p>前面所有的操作都是为了接下来的这一步做铺垫，要动态切换知识库相关表所在的<code>Schema</code>，我们现在已经将知识库版本放入到了本地线程变量，只需要通过 <code>DynamicSchemaManager</code> 的 <code>getSchema(String version)</code> 方法获取版本对应的 <code>schema</code> 名称，然后将名称设置到 <code>sql </code>的表名前面。</p><h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>很容易想到的一种方法就是在 <code>xxxMapper.xml</code> 文件中需要动态切换 <code>Schema</code> 的表名前面加上占位符，然后将 <code>Schema</code> 名称通过参数传入。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">T <span class="hljs-title function_">methodA</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;schema&quot;)</span> String schema)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> t1<br>         <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> #&#123;schema&#125;.t2 <span class="hljs-keyword">on</span> t1.template_id <span class="hljs-operator">=</span> t2.id<br>         <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> #&#123;schema&#125; <span class="hljs-keyword">on</span> t3.template_id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure><p>额。。。兄弟，前面都挺好的，怎么到你这这么拉了？</p><p>这种方法无疑有大量的改动，而且对于每次新增方法也要同步修改，别说你们我都忍不了。</p><p>难道还有更好的办法？</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p><code>org.apache.ibatis.plugin.Interceptor</code> 是 <code>MyBatis</code> 提供的拦截器接口，可以用于在 <code>MyBatis</code> 执行 <code>SQL</code> 语句的各个阶段进行拦截和干预。</p><p>通过实现这个接口，我们可以在 <code>SQL</code> 语句执行前后，以及执行期间做一些额外的处理。</p><p>由于我的项目中使用了 <code>MybatisPlus</code>, 已经实现了拦截器接口，另外做了一层封装，提供了<code>InnerInterceptor</code> 接口，只需要实现这个接口就可以对待执行的 <code>SQL</code> 进行一些修改逻辑。</p><p><img src="https://image.seeyourface.cn/migrate/image-20231116175130355.png" alt="image-20231116175130355"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchemaSelectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InnerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeQuery</span><span class="hljs-params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> boundSql.getSql();<br>        <span class="hljs-comment">// 简单判断sql中是否包含涉及的知识库表，不包含的话就不用解析了</span><br>        <span class="hljs-keyword">if</span> (!isContainsSyncTable(sql)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> DynamicSchemaContextHolder.peek();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">schema</span> <span class="hljs-operator">=</span> DynamicSchemaManager.getSchema(version);<br>        <span class="hljs-type">PGSQLStatementParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PGSQLStatementParser</span>(sql);<br>        <span class="hljs-type">SQLStatement</span> <span class="hljs-variable">sqlStatement</span> <span class="hljs-operator">=</span> parser.parseStatement();<br>        <span class="hljs-comment">// 访问器</span><br>        <span class="hljs-type">SchemaSwitchVisitorAdapter</span> <span class="hljs-variable">visitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SchemaSwitchVisitorAdapter</span>(schema, DynamicSchemaManager.getSyncTableNames());<br>        sqlStatement.accept(visitor);<br>        PluginUtils.mpBoundSql(boundSql).sql(SQLUtils.toSQLString(sqlStatement, DbType.postgresql));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isContainsSyncTable</span><span class="hljs-params">(String sql)</span> &#123;<br>        <span class="hljs-keyword">return</span> DynamicSchemaManager.isContainsSyncTable(sql.toLowerCase());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在能拦截执行前的 <code>SQL</code>，现在剩下的首要任务就是将需要替换<code>schema</code>的表正确替换，考虑到有一些表有很相似的名称，不能简单进行 <code>replace</code>。</p><p>这里我使用了阿里 <code>Druid</code> 数据源提供的 <code>SQL</code> 解析器 <code>PGSQLStatementParser</code>，我们先大概判断有没有需要替换的表，没有的话就没必要进行解析了。</p><p>然后自定义一个 <code>AST</code> 节点访问器 <code>SchemaSwitchVisitorAdapter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchemaSwitchVisitorAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PGASTVisitorAdapter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DOUBLE_QUOTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\&quot;&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String schema;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; syncTables;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(SQLExprTableSource x)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> StrUtil.removeAll(x.getExpr().toString(), DOUBLE_QUOTE);<br>        <span class="hljs-keyword">if</span> (syncTables.stream().anyMatch(tableName::equalsIgnoreCase))<br>            x.setExpr(DOUBLE_QUOTE + schema + DOUBLE_QUOTE + StrUtil.DOT + tableName);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过构造函数传入待替换的 <code>Schema</code> 和知识库的表，判断当前访问的表是否存在于知识库表中，如果是的话就在前面加上要替换的 <code>Schema</code>。</p><p>通过这种操作，我们无需修改原先的任何 <code>SQL</code>。</p><p>最后不要忘记在配置类中加入我们自定义的拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableTransactionManagement(proxyTargetClass = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-comment">// schema选择组件</span><br>        interceptor.addInnerInterceptor(schemaSelectInterceptor());<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * schema选择组件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> SchemaSelectInterceptor <span class="hljs-title function_">schemaSelectInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SchemaSelectInterceptor</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">18:03:23.208 [http-nio-8080-exec-55] DEBUG c.d.s.m.DynamicSchemaManager - [getSchema,80] - dynamic-schema - switch to the schema named [20231115171241]<br>18:03:23.213 [http-nio-8080-exec-55] DEBUG c.d.s.m.A.qryByTemplateType - [debug,137] - ==&gt;  Preparing: SELECT t1.&quot;name&quot;, t4.bp<span class="hljs-built_in">_</span>code, t4.&quot;stage&quot;, t4.&quot;process&quot;, t4.dimension , t4.&quot;content&quot;, t4.&quot;level&quot;, t6.id AS itemId FROM &quot;20231115171241&quot;.analysis<span class="hljs-built_in">_</span>template t1 INNER JOIN &quot;20231115171241&quot;.standard<span class="hljs-built_in">_</span>template<span class="hljs-built_in">_</span>relevance t2 ON t1.&quot;id&quot; = t2.template<span class="hljs-built_in">_</span>id INNER JOIN &quot;20231115171241&quot;.standard t3 ON t2.standard<span class="hljs-built_in">_</span>id = t3.&quot;id&quot; AND t3.&quot;enable&quot; = true INNER JOIN &quot;20231115171241&quot;.standard<span class="hljs-built_in">_</span>item t4 ON t3.&quot;id&quot; = t4.standard<span class="hljs-built_in">_</span>id LEFT JOIN &quot;20231115171241&quot;.clause<span class="hljs-built_in">_</span>item<span class="hljs-built_in">_</span>relevance t5 ON t4.&quot;id&quot; = t5.clause<span class="hljs-built_in">_</span>id LEFT JOIN &quot;20231115171241&quot;.item t6 ON t5.item<span class="hljs-built_in">_</span>id = t6.id AND t6.status = 0 WHERE t1.&quot;type&quot; = ? AND t4.&quot;level&quot; = ?<br>18:03:23.213 [http-nio-8080-exec-55] DEBUG c.d.s.m.A.qryByTemplateType - [debug,137] - ==&gt; Parameters: 1(Integer), 3(Integer)<br>18:03:23.255 [http-nio-8080-exec-55] DEBUG c.d.s.m.A.qryByTemplateType - [debug,137] - &lt;==      Total: 385<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>动态数据源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态数据源</tag>
      
      <tag>Schema</tag>
      
      <tag>联表查询切换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态数据源实现多版本内容库切换</title>
    <link href="/2023/11/10/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%89%88%E6%9C%AC%E5%86%85%E5%AE%B9%E5%BA%93%E5%88%87%E6%8D%A2/"/>
    <url>/2023/11/10/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%89%88%E6%9C%AC%E5%86%85%E5%AE%B9%E5%BA%93%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>最近有一个基于C&#x2F;S（客户&#x2F;服务端）结构的多版本内容控制的需求。服务端为所有客户端提供知识库内容支持，客户端可以通过前台页面在线更新服务端的知识库内容，客户端需要使用知识库的内容进行一系列的操作，具体做什么操作不是重点。</p><p>现在问题是产品需要支持在旧版本的知识库创建的作业更新后任然使用旧版本知识库内容，而创建新作业时使用更新的知识库内容</p><p>经过需求分析之后决定使用动态数据源来处理不同作业访问不同知识库内容的方式从而解决这个问题。</p><h3 id="数据源连接"><a href="#数据源连接" class="headerlink" title="数据源连接"></a>数据源连接</h3><p>在 <code>Spring</code> 框架中，我们通常使用 <code>DataSource</code> 对象来管理数据库连接。<code>javax.sql.DataSource</code> 是一个 <code>Java</code> 接口，它提供了与数据库连接相关的方法和功能。它是连接数据库的一种方式，可以通过这个接口来获取数据库连接，执行 <code>SQL</code> 查询和更新等操作。</p><p>传统的 <code>JDBC</code> 访问数据库技术，每次访问数据库都需要通过数据库驱动器 <code>Driver</code> 和数据库名称以及密码等等资源建立数据库连接。频繁的建立数据库连接与断开数据库，这样会消耗大量的系统资源和时间，降低性能，需要一定的内存和 CPU 开销。</p><p>通过建立数据库连接池，将这些数据库连接保存在数据连接池中，访问数据库时，只需要从数据库连接池中获取空闲的数据库连接，当程序员访问数据库结束时，数据连接会放回数据库连接池中，从而大大提高系统性能。</p><h3 id="SpringBoot官方提供的动态数据源"><a href="#SpringBoot官方提供的动态数据源" class="headerlink" title="SpringBoot官方提供的动态数据源"></a>SpringBoot官方提供的动态数据源</h3><p><code>AbstractRoutingDataSource</code> 是 <code>springboot</code> 官方提供给我们的多数据源切换策略，下面介绍一下该类中的核心属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    <span class="hljs-comment">// 目标数据源，也就是所有需要进行切换的所有数据源保存在这个map中</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;<br><br>    <span class="hljs-comment">// 默认的数据源，无任何切换操作时使用默认数据库及事物上下文</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> Object defaultTargetDataSource;<br><br>    <span class="hljs-comment">// 当切换的数据库不存在时是否回退到默认数据库</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lenientFallback</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 通过JNDI寻找数据源的默认实现</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">DataSourceLookup</span> <span class="hljs-variable">dataSourceLookup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JndiDataSourceLookup</span>();<br><br>    <span class="hljs-comment">// 将targetDataSources转化为DataSource</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> DataSource resolvedDefaultDataSource;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 实现InitializingBean类的方法，初始化bean后会调用，将targetDataSources转化为resolvedDataSources</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.targetDataSources == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Property &#x27;targetDataSources&#x27; is required&quot;</span>);<br>&#125;<br><span class="hljs-built_in">this</span>.resolvedDataSources = CollectionUtils.newHashMap(<span class="hljs-built_in">this</span>.targetDataSources.size());<br><span class="hljs-built_in">this</span>.targetDataSources.forEach((key, value) -&gt; &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">lookupKey</span> <span class="hljs-operator">=</span> resolveSpecifiedLookupKey(key);<br><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> resolveSpecifiedDataSource(value);<br><span class="hljs-built_in">this</span>.resolvedDataSources.put(lookupKey, dataSource);<br>&#125;);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.defaultTargetDataSource != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.resolvedDefaultDataSource = resolveSpecifiedDataSource(<span class="hljs-built_in">this</span>.defaultTargetDataSource);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 根据key获取数据源，key一般存放在当前线程的ThreadLoacl中</span><br><span class="hljs-keyword">protected</span> DataSource <span class="hljs-title function_">determineTargetDataSource</span><span class="hljs-params">()</span> &#123;<br>Assert.notNull(<span class="hljs-built_in">this</span>.resolvedDataSources, <span class="hljs-string">&quot;DataSource router not initialized&quot;</span>);<br>        <span class="hljs-comment">// 获取当前线程对应数据源的标识key</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">lookupKey</span> <span class="hljs-operator">=</span> determineCurrentLookupKey();<br>        <span class="hljs-comment">// 从数据源集合中获取数据源对象</span><br><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resolvedDataSources.get(lookupKey);<br>        <span class="hljs-comment">// 如果数据源不存在，则回退到默认数据源</span><br><span class="hljs-keyword">if</span> (dataSource == <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-built_in">this</span>.lenientFallback || lookupKey == <span class="hljs-literal">null</span>)) &#123;<br>dataSource = <span class="hljs-built_in">this</span>.resolvedDefaultDataSource;<br>&#125;<br>        <span class="hljs-comment">// 如果数据源不存在，则抛出异常</span><br><span class="hljs-keyword">if</span> (dataSource == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="hljs-string">&quot;]&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> dataSource;<br>&#125;<br><br>    <span class="hljs-comment">// 这个方法是让我们实现返回当前要切换的数据源的key</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">determineCurrentLookupKey</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>所以使用 <code>spring boot</code> 官方提供的多数据源切换策略只需要实现 <code>AbstractRoutingDataSource</code> 类然后重写 <code>determineCurrentLookupKey()</code> 方法即可。</p><p>官方提供的多数据源切换策略相对较简单，还有一种第三方提供的动态数据源也是下面重点要介绍的。</p><h3 id="苞米豆动态数据源"><a href="#苞米豆动态数据源" class="headerlink" title="苞米豆动态数据源"></a>苞米豆动态数据源</h3><p>一般的实现方式是通过 <code>ThreadLocal</code> 和注解，通过 <code>AOP</code> 切面在需要切换数据源的地方设置需要切换的数据源的key即可，注意 <code>ThreadLocal</code> 设置使用完后需要清理，否则可能造成内存溢出。</p><p>这里主要介绍通过 <code>baomidou</code> 的 <code>dynamic-datasource</code> 来配置多数据源切换操作，自定义配置数据来源以及动态增减数据源。 </p><p>由于项目中使用了 <code>Druid</code> 做数据库连接池，所以会一并介绍 <code>Druid</code> 和 <code>dynamic-datasource</code> 的整合方式。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># 数据源配置</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-comment"># druid的全局配置</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-attr">filter:</span><br>        <span class="hljs-attr">stat:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-comment"># 慢SQL记录</span><br>          <span class="hljs-attr">log-slow-sql:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">slow-sql-millis:</span> <span class="hljs-number">1000</span><br>          <span class="hljs-attr">merge-sql:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">wall:</span><br>          <span class="hljs-attr">config:</span><br>            <span class="hljs-attr">multi-statement-allow:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">webStatFilter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">statViewServlet:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-comment"># 设置白名单，不填则允许所有访问</span><br>        <span class="hljs-attr">allow:</span><br>        <span class="hljs-attr">url-pattern:</span> <span class="hljs-string">/druid/*</span><br>        <span class="hljs-comment"># 控制台管理用户名和密码</span><br>        <span class="hljs-attr">login-username:</span> <span class="hljs-string">admin</span><br>        <span class="hljs-attr">login-password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">dynamic:</span><br>      <span class="hljs-attr">primary:</span> <span class="hljs-string">master</span><br>      <span class="hljs-attr">strict:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">datasource:</span><br>        <span class="hljs-attr">master:</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>          <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:postgresql://ip:port/database_1?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&amp;reWriteBatchedInserts=true</span><br>          <span class="hljs-attr">username:</span> <span class="hljs-string">user_1</span><br>          <span class="hljs-attr">password:</span> <span class="hljs-string">password</span><br>          <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">org.postgresql.Driver</span><br><span class="hljs-comment">#        slave:</span><br><span class="hljs-comment">#          type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-comment">#          url: jdbc:postgresql://ip:port/database_2?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&amp;reWriteBatchedInserts=true</span><br><span class="hljs-comment">#          username: user_2</span><br><span class="hljs-comment">#          password: password</span><br>      <span class="hljs-attr">druid:</span><br>        <span class="hljs-comment"># 初始连接数</span><br>        <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span><br>        <span class="hljs-comment"># 最小连接池数量</span><br>        <span class="hljs-attr">minIdle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-comment"># 最大连接池数量</span><br>        <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span><br>        <span class="hljs-comment"># 配置获取连接等待超时的时间</span><br>        <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>        <span class="hljs-comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br>        <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>        <span class="hljs-comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br>        <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>        <span class="hljs-comment"># 配置一个连接在池中最大生存的时间，单位是毫秒</span><br>        <span class="hljs-attr">maxEvictableIdleTimeMillis:</span> <span class="hljs-number">900000</span><br>        <span class="hljs-comment"># 配置检测连接是否有效</span><br>        <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-string">version()</span><br>        <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>到这一步其实我们就可以通过 <code>@DS (&quot;配置的数据库名称&quot;)</code>  注解来切换数据源了。</p><p>注解可以配置在类和方法上面，配置在方法上面的注解优先级大于配置在类上面的注解。</p><h3 id="自定义数据源配置来源"><a href="#自定义数据源配置来源" class="headerlink" title="自定义数据源配置来源"></a>自定义数据源配置来源</h3><p>有时候我们并不固定数据源的加载位置。例如在上述场景中，每次更新一次知识库都需要创建一个数据源连接，然后将这个连接存入 <code>master</code> 库，我们不可能每次新增一个连接就将数据源连接配置到<code>yml</code> 文件中，所以就需要系统启动时主动从别的地方获取数据源连接，这里我从 <code>master</code> 库获取。</p><p>我们先来看它的核心类 <code>DynamicRoutingDataSource</code> 的源码 ，除了 <code>springboot</code> 官方提供的多数据源切换操作之外，它还扩展提供了数据源分组、动态新增或删除数据源连接等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>, DisposableBean &#123;<br>    <span class="hljs-comment">// 其他属性和方法删除，只保留核心方法属性</span><br>    <span class="hljs-comment">// 所有数据库</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, DataSource&gt; dataSourceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 分组数据库</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, GroupDataSource&gt; groupDataSources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 数据源加载接口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;DynamicDataSourceProvider&gt; providers;<br>    <br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 检查开启了配置但没有相关依赖</span><br>        checkEnv();<br>        <span class="hljs-comment">// 添加并分组数据源</span><br>        Map&lt;String, DataSource&gt; dataSources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">for</span> (DynamicDataSourceProvider provider : providers) &#123;<br>            Map&lt;String, DataSource&gt; dsMap = provider.loadDataSources();<br>            <span class="hljs-keyword">if</span> (dsMap != <span class="hljs-literal">null</span>) &#123;<br>                dataSources.putAll(dsMap);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, DataSource&gt; dsItem : dataSources.entrySet()) &#123;<br>            addDataSource(dsItem.getKey(), dsItem.getValue());<br>        &#125;<br>        <span class="hljs-comment">// 检测默认数据源是否设置</span><br>        <span class="hljs-keyword">if</span> (groupDataSources.containsKey(primary)) &#123;<br>            log.info(<span class="hljs-string">&quot;dynamic-datasource initial loaded [&#123;&#125;] datasource,primary group datasource named [&#123;&#125;]&quot;</span>, dataSources.size(), primary);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataSourceMap.containsKey(primary)) &#123;<br>            log.info(<span class="hljs-string">&quot;dynamic-datasource initial loaded [&#123;&#125;] datasource,primary datasource named [&#123;&#125;]&quot;</span>, dataSources.size(), primary);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.warn(<span class="hljs-string">&quot;dynamic-datasource initial loaded [&#123;&#125;] datasource,Please add your primary datasource or check your configuration&quot;</span>, dataSources.size());<br>        &#125;<br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><p>注意 <code>afterPropertiesSet()</code> 方法中循环遍历了 <code>providers</code> 这个实例变量，并将<code>loadDataSources()</code> 方法返回的数据源添加到 <code>dataSourceMap</code> 中。</p><p>所以我们可以猜测 <code>DynamicDataSourceProvider</code> 是用来加载数据源连接的接口。</p><p><img src="https://image.seeyourface.cn/migrate/image-20231113102320148.png" alt="image-20231113102320148"></p><p>果然，不出我们所料。它有一个默认的实现类从 <code>yml</code> 配置文件中读取数据源连接。</p><p><img src="https://image.seeyourface.cn/migrate/image-20231113102557770.png" alt="image-20231113102557770"></p><p>这个默认的实现类中具体是如何创建数据源的不是我们关注的重点，我们主要看它是何时加载的，弄明白这一点那我们就可以自定义一个数据源加载类，加载我们所需要的数据源连接。</p><p>我们从引入的 <code>starter</code> 出发，在 <code>META_INF/spring.factories</code> 文件中可以看到自动配置类。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">com.baomidou.dynamic.datasource.spring.boot.autoconfigure.DynamicDataSourceAutoConfiguration</span><br></code></pre></td></tr></table></figure><p>点进去这个配置类，可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(DynamicDataSourceProperties.class)</span><br><span class="hljs-meta">@AutoConfigureBefore(value = DataSourceAutoConfiguration.class, name = &quot;com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure&quot;)</span><br><span class="hljs-meta">@Import(&#123;DruidDynamicDataSourceConfiguration.class, DynamicDataSourceCreatorAutoConfiguration.class, DynamicDataSourceAopConfiguration.class, DynamicDataSourceAssistConfiguration.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = DynamicDataSourceProperties.PREFIX, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicDataSourceAutoConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DynamicDataSourceProperties properties;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;DynamicDataSourcePropertiesCustomizer&gt; dataSourcePropertiesCustomizers;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicDataSourceAutoConfiguration</span><span class="hljs-params">(</span><br><span class="hljs-params">            DynamicDataSourceProperties properties,</span><br><span class="hljs-params">            ObjectProvider&lt;List&lt;DynamicDataSourcePropertiesCustomizer&gt;&gt; dataSourcePropertiesCustomizers)</span> &#123;<br>        <span class="hljs-built_in">this</span>.properties = properties;<br>        <span class="hljs-built_in">this</span>.dataSourcePropertiesCustomizers = dataSourcePropertiesCustomizers.getIfAvailable();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(List&lt;DynamicDataSourceProvider&gt; providers)</span> &#123;<br>        <span class="hljs-type">DynamicRoutingDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicRoutingDataSource</span>(providers);<br>        dataSource.setPrimary(properties.getPrimary());<br>        dataSource.setStrict(properties.getStrict());<br>        dataSource.setStrategy(properties.getStrategy());<br>        dataSource.setP6spy(properties.getP6spy());<br>        dataSource.setSeata(properties.getSeata());<br>        dataSource.setGraceDestroy(properties.getGraceDestroy());<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(dataSourcePropertiesCustomizers)) &#123;<br>            <span class="hljs-keyword">for</span> (DynamicDataSourcePropertiesCustomizer customizer : dataSourcePropertiesCustomizers) &#123;<br>                customizer.customize(properties);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到初始化 <code>dataSource</code> 中传入了入参 <code>providers</code> ，那这个 <code>providers</code> 是从哪来的呢？我们可以发现配置类上面有一个 <code>@Import</code> 注解，引入了其他配置，进入最后一个 <code>DynamicDataSourceAssistConfiguration</code> 配置类，可以发现在这里注入了默认的 <code>yml provider</code></p><p><img src="https://image.seeyourface.cn/migrate/image-20231113104316481.png" alt="image-20231113104316481"></p><p>所以我们也定义一个自动配置类，然后将我们自己的 <code>provider</code> 交给 <code>spring</code> 容器管理。</p><p>同时这里默认实现了一个抽象类 <code>provider</code> 供我们使用，我们不必去实现 <code>DynamicDataSourceProvider</code> 接口，只需要实现这个抽象类然后重写 <code>executeStmt()</code> 方法通过默认数据源执行 <code>SQL</code> 获取数据库中的连接即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDynamicDataSourceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractJdbcDataSourceProvider</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">PATTERN</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;/([^/]+)\\?&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSourceProperty dataSourceProperty;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomDynamicDataSourceProvider</span><span class="hljs-params">(DefaultDataSourceCreator defaultDataSourceCreator, DataSourceProperty dataSourceProperty)</span> &#123;<br>        <span class="hljs-built_in">super</span>(defaultDataSourceCreator, dataSourceProperty.getDriverClassName(),<br>                dataSourceProperty.getUrl(), dataSourceProperty.getUsername(), dataSourceProperty.getPassword());<br>        <span class="hljs-built_in">this</span>.dataSourceProperty = dataSourceProperty;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Map&lt;String, DataSourceProperty&gt; <span class="hljs-title function_">executeStmt</span><span class="hljs-params">(Statement statement)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        Map&lt;String, DataSourceProperty&gt; dataSourcePropertiesMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(<span class="hljs-string">&quot;select * from library_sync_config where is_used = true&quot;</span>);<br>        <span class="hljs-keyword">if</span> (Objects.nonNull(resultSet)) &#123;<br>            <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                <span class="hljs-type">DataSourceProperty</span> <span class="hljs-variable">newProperty</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(dataSourceProperty, DataSourceProperty.class);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;version&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">configName</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;config_name&quot;</span>);<br>                <span class="hljs-comment">// 替换url中的数据库名称，其他属性都和master一致</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> replaceDatabaseName(dataSourceProperty.getUrl(), configName);<br>                newProperty.setPoolName(version);<br>                dataSourcePropertiesMap.put(version, newProperty);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dataSourcePropertiesMap;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">replaceDatabaseName</span><span class="hljs-params">(String url, String newDatabaseName)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">oldDatabaseName</span> <span class="hljs-operator">=</span> parseDatabaseName(url);<br>        <span class="hljs-keyword">return</span> url.replaceFirst(<span class="hljs-string">&quot;(?i)&quot;</span> + oldDatabaseName, newDatabaseName);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">parseDatabaseName</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-comment">// 使用正则表达式提取数据库名</span><br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> PATTERN.matcher(url);<br><br>        <span class="hljs-keyword">if</span> (matcher.find()) &#123;<br>            <span class="hljs-keyword">return</span> matcher.group(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里因为我是通过更新知识库操作再创建一个同级别的数据库，所以除了库名其他信息都是一致的，新连接只需要替换库名即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;DynamicDataSourceProperties.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicDataSourceConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DynamicDataSourceProperties properties;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicDataSourceConfig</span><span class="hljs-params">(DynamicDataSourceProperties properties)</span> &#123;<br>        <span class="hljs-built_in">this</span>.properties = properties;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-keyword">public</span> DynamicDataSourceProvider <span class="hljs-title function_">dynamicDataSourceProvider</span><span class="hljs-params">(DefaultDataSourceCreator defaultDataSourceCreator)</span> &#123;<br>        Map&lt;String, DataSourceProperty&gt; datasource = <span class="hljs-built_in">this</span>.properties.getDatasource();<br>        <span class="hljs-comment">// 必须配置master数据源，通过master数据源创建其他连接添加至数据库连接池</span><br>        <span class="hljs-type">DataSourceProperty</span> <span class="hljs-variable">master</span> <span class="hljs-operator">=</span> datasource.get(<span class="hljs-string">&quot;master&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDynamicDataSourceProvider</span>(defaultDataSourceCreator, master);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过控制台打印的日志我们也可以看到，虽然配置文件只配置了一个数据连接，但系统启动时通过其它地方新增了一个配置连接。</p><p><img src="https://image.seeyourface.cn/migrate/image-20231113110534993.png" alt="image-20231113110534993"></p><h3 id="自定义处理逻辑"><a href="#自定义处理逻辑" class="headerlink" title="自定义处理逻辑"></a>自定义处理逻辑</h3><p>动态数据源通过拦截添加了 <code>@DS(xxx)</code> 注解的类或方法，根据注解设置的值选取对应数据源连接。</p><p>通过配置类 <code>DynamicDataSourceAopConfiguration</code> 发现有两个主要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造数据源处理器，默认会创建三个processor，并以执行链的方式设置好执行顺序</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> DsProcessor <span class="hljs-title function_">dsProcessor</span><span class="hljs-params">(BeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-type">DsProcessor</span> <span class="hljs-variable">headerProcessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DsHeaderProcessor</span>();<br>    <span class="hljs-type">DsProcessor</span> <span class="hljs-variable">sessionProcessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DsSessionProcessor</span>();<br>    <span class="hljs-type">DsSpelExpressionProcessor</span> <span class="hljs-variable">spelExpressionProcessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DsSpelExpressionProcessor</span>();<br>    spelExpressionProcessor.setBeanResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryResolver</span>(beanFactory));<br>    headerProcessor.setNextProcessor(sessionProcessor);<br>    sessionProcessor.setNextProcessor(spelExpressionProcessor);<br>    <span class="hljs-keyword">return</span> headerProcessor;<br>&#125;<br><br><span class="hljs-comment">//创建Advisor对象，指定拦截器和需要拦截的注解</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = DynamicDataSourceProperties.PREFIX + &quot;.aop&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> Advisor <span class="hljs-title function_">dynamicDatasourceAnnotationAdvisor</span><span class="hljs-params">(DsProcessor dsProcessor)</span> &#123;<br>    <span class="hljs-type">DynamicDatasourceAopProperties</span> <span class="hljs-variable">aopProperties</span> <span class="hljs-operator">=</span> properties.getAop();<br>    <span class="hljs-type">DynamicDataSourceAnnotationInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicDataSourceAnnotationInterceptor</span>(aopProperties.getAllowedPublicOnly(), dsProcessor);<br>    <span class="hljs-type">DynamicDataSourceAnnotationAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicDataSourceAnnotationAdvisor</span>(interceptor, DS.class);<br>    advisor.setOrder(aopProperties.getOrder());<br>    <span class="hljs-keyword">return</span> advisor;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DsProcessor</code> 是一个处理器的抽象类，我们只需要实现何时匹配这个处理器，以及根据传入的key决定要匹配哪个数据源连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DsProcessor</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下一个执行器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> DsProcessor nextProcessor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置下一个执行器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dsProcessor 执行器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextProcessor</span><span class="hljs-params">(DsProcessor dsProcessor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nextProcessor = dsProcessor;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 抽象匹配条件 匹配才会走当前执行器否则走下一级执行器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key DS注解里的内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否匹配</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(String key)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 决定数据源</span><br><span class="hljs-comment">     * &lt;pre&gt;</span><br><span class="hljs-comment">     *     调用底层doDetermineDatasource，</span><br><span class="hljs-comment">     *     如果返回的是null则继续执行下一个，否则直接返回</span><br><span class="hljs-comment">     * &lt;/pre&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> invocation 方法执行信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key        DS注解里的内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 数据源名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">determineDatasource</span><span class="hljs-params">(MethodInvocation invocation, String key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matches(key)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">datasource</span> <span class="hljs-operator">=</span> doDetermineDatasource(invocation, key);<br>            <span class="hljs-keyword">if</span> (datasource == <span class="hljs-literal">null</span> &amp;&amp; nextProcessor != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> nextProcessor.determineDatasource(invocation, key);<br>            &#125;<br>            <span class="hljs-keyword">return</span> datasource;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nextProcessor != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> nextProcessor.determineDatasource(invocation, key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 抽象最终决定数据源</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> invocation 方法执行信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key        DS注解里的内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 数据源名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">doDetermineDatasource</span><span class="hljs-params">(MethodInvocation invocation, String key)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们只需要在配置文件中创建自己的 <code>Processor</code> 即可自定义数据源的处理逻辑，当然，我们也可以定义多个 <code>Processor</code> 形成一条执行链。</p><p>我们定义好自己的 <code>Processor</code> 之后因为 <code>@ConditionalOnMissingBean</code> 注解默认的处理器就不会生效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DsProcessor <span class="hljs-title function_">dsProcessor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyProcessor</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DsProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 定义何时匹配这个处理器</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doDetermineDatasource</span><span class="hljs-params">(MethodInvocation invocation, String key)</span> &#123;<br>        <span class="hljs-comment">// 自己的处理逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态增减数据源"><a href="#动态增减数据源" class="headerlink" title="动态增减数据源"></a>动态增减数据源</h3><p><code>DynamicRoutingDataSource</code> 组件中提供了 <code>addDataSource()</code> 和 <code>removeDataSource()</code> 两个方法，使用时只需要注入该组件调用指定方法即可，十分方便。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>动态数据源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态数据源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂+责任链模式实现任务完整性校验</title>
    <link href="/2023/10/27/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82+%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%AA%8C/"/>
    <url>/2023/10/27/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82+%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>现在有这样一个场景：</p><p>作业结项时需要对每个 <code>Label</code> 中的数据完整性进行校验。你可以将 <code>Label</code> 理解为不同的标签，每个标签中都需要完成特定的内容，一个作业可以配置多个 <code>Label</code> 。</p><p>看到这个需求，我们二话不说，直接在作业结项接口中新增代码，对每个 <code>Label</code> 进行校验操作。</p><p>这样有问题吗？当然没问题！（你看着被代码塞满的类心虚的说到）</p><p>一顿操作猛如虎，代码 <code>Review</code> 骂成狗 ~</p><p>作为一名优雅（自认为）的程序员，绝不允许这种情况出现！</p><p>这时候我们就需要考虑使用设计模式来应对了。</p><p>使用了设计模式，我们可以做到在结项方法中只新增一行代码即可实现需求（歪嘴战神）~</p><h3 id="怎么选择设计模式"><a href="#怎么选择设计模式" class="headerlink" title="怎么选择设计模式"></a>怎么选择设计模式</h3><p>使用设计模式的难点往往在于如何选用，因为只有选对了方法才能事半功倍。</p><p>这里我们对每个 <code>Label</code> 都有不同的处理，所以我们需要为每个 <code>Label</code> 都需要新建一个 <code>handler</code> ，将每个 <code>Label</code> 的校验操作解耦和隔离，使它们互不影响，将来要对其中某个 <code>Label</code> 修改时，也可以做尽量少的操作。 </p><p>同时我们可以将所有 <code>Label</code> 的校验操作串成一条执行链条，只要某个节点校验到不满足条件即可提前退出，而不需要再执行后续操作。对于满足条件的节点则进入下一个节点继续校验。直到所有 <code>Label</code> 校验完毕。</p><p>都说到这个份上了，想必大家也知道什么设计模式适合实现这个需求了，没错，就是简单工厂模式和责任链模式。</p><p>本文不对上述两个模式做详细介绍，直接上代码。</p><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>我们需要对不同的 <code>Label</code> 获取不同的 <code>handler</code> 处理类，一般我们可以通过策略模式 + 简单工厂的方式来根据 <code>Label</code> 标签类型来创建 <code>handler</code> 处理类。</p><p>这里我通过将所有 <code>handler</code> 实现类交由 <code>spring</code> 容器管理，再根据需要通过 <code>Label</code> 类型获取，而不必每次获取都去创建。</p><h4 id="定义所有处理类的超类"><a href="#定义所有处理类的超类" class="headerlink" title="定义所有处理类的超类"></a>定义所有处理类的超类</h4><p>首先我们需要定义一个被所有 <code>Label</code> 继承的超类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationResultHandler</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> OperationResultHandler handler;<br><br>    <span class="hljs-comment">// 设置下一个执行节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuperior</span><span class="hljs-params">(OperationResultHandler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回当前实现类的type</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> LabelEnum <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 执行具体的校验操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Pair&lt;Boolean, LabelEnum&gt; <span class="hljs-title function_">handler</span><span class="hljs-params">(DutyRequest request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定义各个Label的实现类"><a href="#定义各个Label的实现类" class="headerlink" title="定义各个Label的实现类"></a>定义各个Label的实现类</h4><p>由于 <code>Label</code> 数量比较多，这里只列举一个实现类，所有实现类除具体校验逻辑外均一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrganizeVerifyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OperationResultHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> QuestionnaireMapper questionnaireMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LabelEnum <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LabelEnum.ZZDY;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Pair&lt;Boolean, LabelEnum&gt; <span class="hljs-title function_">handler</span><span class="hljs-params">(DutyRequest request)</span> &#123;<br>        <span class="hljs-comment">// 如果作业包含当前节点才对当前节点校验，否则进入下一个节点</span><br>        <span class="hljs-keyword">if</span> (request.getServiceIds().contains(getType().getCode())) &#123;<br>            <span class="hljs-comment">// 具体的校验逻辑，不满足直接跳出，满足且下一个节点不为空继续校验</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> questionnaireMapper.selectCount(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Questionnaire&gt;()<br>                    .eq(<span class="hljs-string">&quot;operation_id&quot;</span>, request.getOperationId())<br>                    .eq(<span class="hljs-string">&quot;object_id&quot;</span>, getType().getCode())<br>                    .eq(<span class="hljs-string">&quot;finished&quot;</span>, <span class="hljs-literal">false</span>));<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(Boolean.FALSE, getType());<br>        &#125;<br>        <span class="hljs-comment">// 下一个流程链不为空继续校验，否则为最后一个节点，返回true校验通过</span><br>        <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> handler.handler(request);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(Boolean.TRUE, getType());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Spring容器管理"><a href="#Spring容器管理" class="headerlink" title="Spring容器管理"></a>Spring容器管理</h3><p>我们可以将所有 <code>Label</code> 的实现类交给 <code>Spring</code> 容器管理， 包括生产 <code>handler</code> 的工厂，需要使用时再通过 <code>getHandler()</code> 方法传入入参 <code>Label</code> 的类型获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationResultHandlerFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>, ApplicationContextAware &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;LabelEnum, Supplier&lt;OperationResultHandler&gt;&gt; BEAN_MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据label标签获取对应的处理器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type &#123;<span class="hljs-doctag">@see</span> LabelEnum&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> return handler with type, null if not found</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> OperationResultHandler <span class="hljs-title function_">getHandler</span><span class="hljs-params">(LabelEnum type)</span> &#123;<br>        Supplier&lt;OperationResultHandler&gt; supplier = BEAN_MAP.get(type);<br>        <span class="hljs-keyword">return</span> Objects.isNull(supplier) ? <span class="hljs-literal">null</span> : supplier.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>        applicationContext.getBeansOfType(OperationResultHandler.class).values()<br>                .forEach(bean -&gt; BEAN_MAP.put(bean.getType(), () -&gt; bean));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        OperationResultHandlerFactory.applicationContext = applicationContext;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><h4 id="各节点公共入参"><a href="#各节点公共入参" class="headerlink" title="各节点公共入参"></a>各节点公共入参</h4><p>定义每个 Label 实现类需要用的公共参数，随着责任链一直传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DutyRequest</span> &#123;<br><br>    <span class="hljs-comment">// 作业id</span><br>    <span class="hljs-keyword">private</span> String operationId;<br><br>    <span class="hljs-comment">// 当前作业包含的label类型</span><br>    <span class="hljs-keyword">private</span> Set&lt;Long&gt; serviceIds;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DutyRequest</span><span class="hljs-params">(String operationId, Set&lt;Long&gt; serviceIds)</span> &#123;<br>        <span class="hljs-built_in">this</span>.operationId = operationId;<br>        <span class="hljs-built_in">this</span>.serviceIds = serviceIds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构建责任链"><a href="#构建责任链" class="headerlink" title="构建责任链"></a>构建责任链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationAbilityHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CoOperationMapper coOperationMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据作业id获取作业执行列表构建作业检测链，按顺序检测所有标签是否完成（是否有数据）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operation 作业id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abilityChainVerify</span><span class="hljs-params">(String operation)</span>&#123;<br>        <span class="hljs-comment">// 作业执行列表</span><br>        <span class="hljs-type">CoOperation</span> <span class="hljs-variable">coOperation</span> <span class="hljs-operator">=</span> coOperationMapper.selectById(operation);<br>        <span class="hljs-keyword">if</span> (Objects.isNull(coOperation))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(<span class="hljs-string">&quot;作业不存在&quot;</span>);<br>        Set&lt;Long&gt; serviceIds = StrUtil.split(coOperation.getServiceContent(), StrUtil.COMMA).stream().map(Long::parseLong).collect(Collectors.toSet());<br>        serviceIds.add(LabelEnum.XTDY.getCode());<br>        <span class="hljs-type">DutyRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DutyRequest</span>(operation, serviceIds);<br><br>        <span class="hljs-comment">// 标签列表（有序）</span><br>        List&lt;LabelEnum&gt; labels = Arrays.stream(LabelEnum.values()).filter(l -&gt; l.getPCode() != <span class="hljs-number">0L</span>).collect(Collectors.toList());<br><br>        <span class="hljs-type">OperationResultHandler</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">OperationResultHandler</span> <span class="hljs-variable">currentHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 构建作业检测链</span><br>        <span class="hljs-keyword">for</span> (LabelEnum label : labels) &#123;<br>            <span class="hljs-type">OperationResultHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> OperationResultHandlerFactory.getHandler(label);<br><br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (currentHandler == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果当前处理程序为空，表示这是责任链的第一个节点</span><br>                    head = handler;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 将当前处理程序的下一个节点设置为新的处理程序</span><br>                    currentHandler.setSuperior(handler);<br>                &#125;<br>                currentHandler = handler;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">assert</span> head != <span class="hljs-literal">null</span>;<br>        Pair&lt;Boolean, LabelEnum&gt; pair = head.handler(request);<br>        <span class="hljs-keyword">if</span> (!pair.getKey())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(String.format(<span class="hljs-string">&quot;作业结果校验不通过，[%s]功能未完成&quot;</span>, pair.getValue().getName()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注入检测代码"><a href="#注入检测代码" class="headerlink" title="注入检测代码"></a>注入检测代码</h3><p>然后我们只需要在原方法中合适位置引入一行代码即可完成作业的完整性校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">operationAbilityHandler.abilityChainVerify(operation.getOperationId());<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用设计模式，我们将各个模块的耦合度降到最低，有利于后续的维护和迭代工作。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简单工厂模式</tag>
      
      <tag>责任链模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL Generated Columns</title>
    <link href="/2023/10/26/MySQL%20Generated%20Columns/"/>
    <url>/2023/10/26/MySQL%20Generated%20Columns/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><code>MySQL 5.7</code> 引入了生成列（<code>Generated Columns</code> 还有一种虚拟列的叫法）的支持。生成列中的值由列定义的表达式计算得出。</p><h3 id="创建生成列"><a href="#创建生成列" class="headerlink" title="创建生成列"></a>创建生成列</h3><p>创建生成的列语法定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">col_name data_type [GENERATED ALWAYS] <span class="hljs-keyword">AS</span> (expr)<br>  [VIRTUAL <span class="hljs-operator">|</span> STORED] [<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>]<br>  [<span class="hljs-keyword">UNIQUE</span> [KEY]] [[<span class="hljs-keyword">PRIMARY</span>] KEY]<br>  [COMMENT <span class="hljs-string">&#x27;string&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>AS (expr)</code> 表示生成列的同时定义用于计算生成列值的表达式。</p><p><code>AS</code> 前面可以选择性的加上 <code>GENERATED ALWAYS</code>，使列的生成性质更加明确。</p><p>关键字 <code>VIRTUAL</code> 或 <code>STORED</code> 表示列值的存储方式，它对列的使用有影响：</p><ul><li><code>VIRTUAL</code> : 列值不会被存储，不占用任何存储空间。而是在读取行时计算，同时在执行触发器（特别是 BEFORE 触发器，它们在插入、更新或删除操作之前执行）之后，虚拟列的值会被计算。这是因为虚拟列的值通常<strong>依赖于其他列的值或特定的表达式</strong>，而这些值可能会在触发器中进行修改。因此，虚拟列的值需要在触发器执行之后计算，以确保它们反映最新的数据。<code>InnoDB</code> 支持虚拟列上的二级索引。</li><li><code>STORED</code> : 插入或更新行时，会计算并存储列值。存储列需要存储空间，并可编制索引。</li></ul><p>如果以上两个关键字都未指定，则默认为 <code>VIRTUAL</code>。</p><p>允许在表中混合使用 <code>VIRTUAL</code> 列和 <code>STORED</code> 列。</p><p>还可以给出其他属性，例如生成列是否需要建立索引或是否可以为 <code>NULL</code>，以及提供列注释等。</p><p>对于 <code>CREATE TABLE ...LIKE</code>，目标表会<strong>保留</strong>原始表中生成的列信息。</p><p>对于 <code>CREATE TABLE ...SELECT</code> ，目标表<strong>不保留</strong>关于选自表中的列是否为生成列的信息。语句的 SELECT 部分不能为目标表中的生成列赋值。</p><p>下面这个简单的例子创建了一个表，该表存储了 <code>sidea</code> 和 <code>sidb</code> 列中直角三角形边的长度，并计算<code>sidec</code> 中斜边的长度（其他两边的平方和的平方根）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> triangle (<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>   sidea <span class="hljs-keyword">DOUBLE</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>   sideb <span class="hljs-keyword">DOUBLE</span>,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>   sidec <span class="hljs-keyword">DOUBLE</span> <span class="hljs-keyword">AS</span> (<span class="hljs-built_in">SQRT</span>(sidea <span class="hljs-operator">*</span> sidea <span class="hljs-operator">+</span> sideb <span class="hljs-operator">*</span> sideb))<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.12</span> sec)<br></code></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> triangle (sidea, sideb) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">6</span>,<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>从该表中查询会得到以下结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> triangle;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+-------+--------------------+</span><br><span class="hljs-operator">|</span> sidea <span class="hljs-operator">|</span> sideb <span class="hljs-operator">|</span> sidec              <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+-------+--------------------+</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">1.4142135623730951</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span>                  <span class="hljs-number">5</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-number">6</span> <span class="hljs-operator">|</span>     <span class="hljs-number">8</span> <span class="hljs-operator">|</span>                 <span class="hljs-number">10</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+-------+--------------------+</span><br></code></pre></td></tr></table></figure><p>任何使用 <code>triangle</code> 表的应用程序都可以直接访问斜边值，而无需指定计算斜边值的表达式。</p><h3 id="生成列表达式规则"><a href="#生成列表达式规则" class="headerlink" title="生成列表达式规则"></a>生成列表达式规则</h3><p>如果表达式中包含不被允许的结构，则会发生错误，所以生成的列表达式必须遵守以下规则：</p><ul><li>允许使用字面量、确定性内置函数和运算符。<strong>如果在表格数据相同的情况下，多次调用只会产生相同的结果，而与所连接的用户无关，那么这个函数就是确定的</strong>。</li><li>不允许使用存储函数和可加载函数。</li><li>不允许使用存储过程和函数参数。</li><li>不允许使用变量（包括系统变量、用户定义变量和存储的程序局部变量）。</li><li>不允许使用子查询。</li><li>生成列的定义<strong>可以引用其他生成列，但只能引用表定义中较早出现的生成列</strong>。生成的列定义可以引用表中的<strong>任何基础（非生成）列</strong>，无论其定义出现的时间是早还是晚。</li><li>生成的列定义中不能使用 <code>AUTO_INCREMENT</code> 属性。</li><li>在生成列定义中，<code>AUTO_INCREMENT</code> 列不能被作为基列。</li><li>如果表达式求值导致截断或为函数提供了不正确的输入，则 <code>CREATE TABLE</code> 语句将以错误结束，<code>DDL</code> 操作将被拒绝。</li></ul><blockquote><p>注意：如果表达式求值的数据类型与声明的列类型不同，则会根据 <code>MySQL</code> 默认的隐式类型转换规则强制转换为声明的类型。</p><p>表达式计算使用计算时有效的 <code>SQL</code> 模式。如果表达式定义的任何部分依赖于 <code>SQL</code> 模式，那么除非在所有使用过程中 <code>SQL</code> 模式都相同，否则不同的表格使用过程中可能会出现不同的结果。</p></blockquote><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul><li>存储生成列上的外键约束不能使用 <code>CASCADE</code>、<code>SET NULL</code> 或 <code>SET DEFAULT</code> 作为 <code>ON UPDATE</code> 引用操作，也不能使用 <code>SET NULL</code> 或 <code>SET DEFAULT</code> 作为 <code>ON DELETE</code> 引用操作。</li><li>存储生成列的基列上的外键约束不能使用 <code>CASCADE</code>、<code>SET NULL</code> 或 <code>SET DEFAULT</code> 作为 <code>ON UPDATE</code> 或 <code>ON DELETE</code> 引用操作。</li><li>外键约束不能引用虚拟生成的列。</li><li>对于 <code>INSERT</code>、<code>REPLACE</code> 和 <code>UPDATE</code>，如果生成的列被明确插入、替换或更新，则唯一允许的值是 <code>DEFAULT</code>。</li></ul><p>视图中的生成列被认为是可更新的，因为可以对其进行赋值。但是，如果要显式更新该列，则唯一允许的值是 <code>DEFAULT</code>。</p><h3 id="生成列使用场景"><a href="#生成列使用场景" class="headerlink" title="生成列使用场景"></a>生成列使用场景</h3><p>生成列有几种使用情况，比如下面这些：</p><ul><li>虚拟生成列可以用来简化和统一查询。一个复杂的条件可以定义为一个生成列，并在表的多个查询中引用，以确保所有查询都使用完全相同的条件。</li><li>存储生成的列可用作物化缓存，用于处理计算成本较高的复杂条件。</li><li>生成列可以模拟函数式索引：使用生成的列来定义函数表达式并为其建立索引。这对于处理无法直接建立索引的列类型（如 <code>JSON</code> 列）非常有用。对于存储生成列，这种方法的缺点是要存储两次值，一次是生成列的值，另一次是索引中的值。</li><li>如果生成的列有索引，优化器会识别与列定义相匹配的查询表达式，即使查询没有直接引用列名，查询执行过程中也会酌情使用列索引。</li></ul><p>举例：</p><p>假设表 <code>t1</code> 包含名和姓两列，应用程序经常使用这样的表达式来构造全名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CONCAT(first_name,<span class="hljs-string">&#x27; &#x27;</span>,last_name) <span class="hljs-keyword">AS</span> full_name <span class="hljs-keyword">FROM</span> t1;<br></code></pre></td></tr></table></figure><p>避免写出表达式的一种方法是在 <code>t1</code> 上创建视图 <code>v1</code>，这样就可以直接选择 <code>full_name</code>，而无需使用表达式，从而简化了应用程序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> v1 <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, CONCAT(first_name,<span class="hljs-string">&#x27; &#x27;</span>,last_name) <span class="hljs-keyword">AS</span> full_name <span class="hljs-keyword">FROM</span> t1;<br><br><span class="hljs-keyword">SELECT</span> full_name <span class="hljs-keyword">FROM</span> v1;<br></code></pre></td></tr></table></figure><p>生成列还能让应用程序直接选择 <code>full_name</code>，而无需定义视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1 (<br>  first_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br>  last_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br>  full_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">AS</span> (CONCAT(first_name,<span class="hljs-string">&#x27; &#x27;</span>,last_name))<br>);<br><br><span class="hljs-keyword">SELECT</span> full_name <span class="hljs-keyword">FROM</span> t1;<br></code></pre></td></tr></table></figure><h3 id="生成列使用索引"><a href="#生成列使用索引" class="headerlink" title="生成列使用索引"></a>生成列使用索引</h3><p>上一篇文章所提到，<code>JSON</code> 列无法直接建立索引。要创建间接引用此类列的索引，可以定义一个生成列来提取应被索引的信息，然后在生成列上创建索引。</p><p>下面的例子我们将在生成列上创建间接引用 <code>JSON</code> 列的索引：</p><p>首先我们创建一个班级表，<code>student</code> 保存学生信息，<code>g</code> 表示引用 <code>student</code> 中的 <code>id</code> 生成的虚拟列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> CLASS (<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>          student JSON,    <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>          g <span class="hljs-type">INT</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> (student <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> &quot;$.id&quot;),<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>          INDEX i (g)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.33</span> sec)<br></code></pre></td></tr></table></figure><p>往表中插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> CLASS(student) <span class="hljs-keyword">VALUES</span> <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>          (<span class="hljs-string">&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;小王&quot;&#125;&#x27;</span>), (<span class="hljs-string">&#x27;&#123;&quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;小李&quot;&#125;&#x27;</span>), <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>          (<span class="hljs-string">&#x27;&#123;&quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;老张&quot;&#125;&#x27;</span>), (<span class="hljs-string">&#x27;&#123;&quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;老赵&quot;&#125;&#x27;</span>); <br>Query OK, <span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p>查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> student<span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span>&quot;$.name&quot; <span class="hljs-keyword">AS</span> NAME  <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>          <span class="hljs-keyword">FROM</span> CLASS <span class="hljs-keyword">WHERE</span> g <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;   <br><span class="hljs-operator">+</span><span class="hljs-comment">------+</span><br><span class="hljs-operator">|</span> NAME <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+</span><br><span class="hljs-operator">|</span> 老张 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> 老赵 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+</span><br></code></pre></td></tr></table></figure><p>然后来看一下这条 <code>SQL</code> 语句的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> student<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.name&quot; <span class="hljs-keyword">AS</span> NAME <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>          <span class="hljs-keyword">FROM</span> CLASS <span class="hljs-keyword">WHERE</span> g <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> CLASS <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">|</span> i             <span class="hljs-operator">|</span> i    <span class="hljs-operator">|</span> <span class="hljs-number">5</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+</span><br></code></pre></td></tr></table></figure><p>可以看到，这条查询语句使用到了索引 <code>i</code> , 也就是说我们可以通过对生成列中引用 <code>JSON</code> 中的属性并建立索引间接达到对 <code>JSON</code> 中的属性建立索引的效果。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL JSON Data Type</title>
    <link href="/2023/10/17/MySQL%20JSON%20Data%20Type/"/>
    <url>/2023/10/17/MySQL%20JSON%20Data%20Type/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><code>MySQL</code> 在 <code>5.7.8</code> 版本中首次引入 <code>JSON</code> 数据类型。这使得我们可以更好地处理和操作 <code>JSON</code> 数据，包括存储、查询和索引 <code>JSON</code> 数据。在此之前，要处理 <code>JSON</code> 数据，通常需要将其存储为文本，并使用字符串函数进行操作。程序中我们也无法直接使用从数据库获取的 <code>JSON</code> 数据，需要进一步转化，十分不方便。</p><p><code>JSON</code> 数据类型相对于将 <code>JSON</code> 格式字符串存储在字符串列中具有以下优势：</p><ul><li>在 <code>JSON</code> 列中存储的 <code>JSON</code> 文档会自动进行验证，<strong>无效的文档会引发错误</strong>。</li><li>经过优化的存储格式。存储在 <code>JSON</code> 列中的 <code>JSON</code> 文档被转换为内部格式，允许快速读取文档元素。当服务器需要读取存储在二进制格式中的 <code>JSON</code> 值时，<strong>无需从文本表示中解析该值</strong>。二进制格式被构造成允许服务器<strong>直接通过键或数组索引查找子对象或嵌套值</strong>，而不需要读取文档中它们之前或之后的所有值。</li></ul><p>随着 <code>MySQL</code> 的版本更新，<code>JSON</code> 数据类型的功能和性能也得到了改进。接下来我们就以 <code>MySQL 8.0.26</code> 版本中 <code>InnoDB</code> 存储引擎为例探讨一下 <code>JSON</code> 格式的数据类型。</p><h3 id="创建JSON值"><a href="#创建JSON值" class="headerlink" title="创建JSON值"></a>创建JSON值</h3><p>在 <code>MySQL</code> 中，<code>JSON</code> 值将被写为字符串。<code>MySQL</code>解析任何在需要 <code>JSON</code> 值的上下文中使用的字符串，如果它不是有效的 <code>JSON</code>，则会产生错误。</p><p>这些上下文包括将值插入具有 <code>JSON</code> 数据类型的列中，并将参数传递给期望 <code>JSON</code> 值的函数（通常在<code>MySQL JSON</code> 函数的文档中显示为 <code>json_doc</code> 或 <code>json_val</code> ），如下例所示：</p><ul><li><p>如果值是有效的 <code>JSON</code> 值，则尝试将值插入 <code>JSON</code> 列会成功，否则，便会失败：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> json_test<br>(<br>    id        <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;主键&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    json_info json <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;json格式信息&#x27;</span><br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> json_test(json_info) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot;: 18, &quot;sex&quot; : 1&#125;&#x27;</span>);<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> affected <span class="hljs-keyword">in</span> <span class="hljs-number">52</span> ms<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> json_test(json_info) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;小红&quot;, &quot;age&quot;: 20, &quot;sex&quot;&#125;&#x27;</span>);<br>Data truncation: Invalid JSON text: &quot;Missing a colon after a name of object member.&quot; <span class="hljs-keyword">at</span> position <span class="hljs-number">35</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;json_test.json_info&#x27;</span>.<br></code></pre></td></tr></table></figure></li><li><p><code>JSON_TYPE()</code> 函数需要一个 <code>JSON</code> 参数，并尝试将其解析为 <code>JSON</code> 值。如果有效，它会返回值的 <code>JSON</code> 类型，否则会产生错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_TYPE(<span class="hljs-string">&#x27;[&quot;吃饭&quot;, false, 20]&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------+</span><br><span class="hljs-operator">|</span> JSON_TYPE(<span class="hljs-string">&#x27;[&quot;吃饭&quot;, false, 20]&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">ARRAY</span>                            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------+</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_TYPE(<span class="hljs-string">&#x27;&quot;你好&quot;&#x27;</span>);              <br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><br><span class="hljs-operator">|</span> JSON_TYPE(<span class="hljs-string">&#x27;&quot;你好&quot;&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><br><span class="hljs-operator">|</span> STRING              <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_TYPE(<span class="hljs-string">&#x27;你好&#x27;</span>);   <br>ERROR <span class="hljs-number">3141</span> (<span class="hljs-number">22032</span>): Invalid JSON text <span class="hljs-keyword">in</span> argument <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">function</span> json_type: &quot;Invalid value.&quot; <span class="hljs-keyword">at</span> position <span class="hljs-number">0.</span><br></code></pre></td></tr></table></figure></li></ul><p>手动输入 <code>JSON</code> 格式字符串非常容易出错，<code>MySQL</code> 为我们提供了一些方法作为代替方案：</p><ul><li><p><code>JSON_ARRAY()</code> 获取一个（可能为空）值列表，并返回一个包含这些值的 <code>JSON</code> 数组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">JSON_ARRAY</span>(<span class="hljs-string">&#x27;数组&#x27;</span>, <span class="hljs-number">123</span>, NOW()); <br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">JSON_ARRAY</span>(<span class="hljs-string">&#x27;数组&#x27;</span>, <span class="hljs-number">123</span>, NOW())              <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------+</span><br><span class="hljs-operator">|</span> [&quot;数组&quot;, <span class="hljs-number">123</span>, &quot;2023-10-18 11:30:59.000000&quot;] <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------+</span><br></code></pre></td></tr></table></figure></li><li><p><code>JSON_OBJECT()</code> 获取键值对的列表（可能为空），并返回包含这些键值对的 <code>JSON</code> 对象：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">JSON_OBJECT</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;sex&#x27;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">JSON_OBJECT</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;sex&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------+</span><br><span class="hljs-operator">|</span> &#123;&quot;age&quot;: <span class="hljs-number">20</span>, &quot;sex&quot;: <span class="hljs-number">0</span>, &quot;name&quot;: &quot;小红&quot;&#125;            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------+</span><br></code></pre></td></tr></table></figure></li><li><p><code>JSON_MERGE_PRESERVE()</code> 获取两个或多个 <code>JSON</code> 文档并返回组合结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_MERGE_PRESERVE(<span class="hljs-string">&#x27;[&quot;你好&quot;, true]&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;李四&quot;&#125;&#x27;</span>);  <br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_MERGE_PRESERVE(<span class="hljs-string">&#x27;[&quot;你好&quot;, true]&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;李四&quot;&#125;&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------------------+</span><br><span class="hljs-operator">|</span> [&quot;你好&quot;, <span class="hljs-literal">true</span>, &#123;&quot;name&quot;: &quot;李四&quot;&#125;]                          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------------------+</span><br></code></pre></td></tr></table></figure></li><li><p><code>JSON</code> 值可以分配给用户定义的变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-variable">@j</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">JSON_OBJECT</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;老李&#x27;</span>); <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@j</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-variable">@j</span>               <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+</span><br><span class="hljs-operator">|</span> &#123;&quot;name&quot;: &quot;老李&quot;&#125; <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+</span><br></code></pre></td></tr></table></figure><p>然而，用户定义的变量不能是 <code>JSON</code> 数据类型，因此尽管前面示例中的 <code>@j</code> 看起来像 <code>JSON</code> 值，并且具有与 <code>JSON</code> 值相同的字符集和排序规则，但它没有 <code>JSON</code> 数据类型。相反，<code>JSON_OBJECT()</code> 的结果在分配给变量时会<strong>转换为字符串</strong>。</p><p>通过转换 <code>JSON</code> 值生成的字符串具有 <code>utf8mb4</code> 字符集和 <code>utf8mb4_bin</code>排序规则；由于 <code>utf8mb4_bin </code>是二进制排序规则，<strong>因此 <code>JSON</code> 值的比较区分大小写</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> CHARSET(<span class="hljs-variable">@j</span>), <span class="hljs-keyword">COLLATION</span>(<span class="hljs-variable">@j</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+---------------+</span><br><span class="hljs-operator">|</span> CHARSET(<span class="hljs-variable">@j</span>) <span class="hljs-operator">|</span> <span class="hljs-keyword">COLLATION</span>(<span class="hljs-variable">@j</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+---------------+</span><br><span class="hljs-operator">|</span> utf8mb4     <span class="hljs-operator">|</span> utf8mb4_bin   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+---------------+</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">JSON_ARRAY</span>(<span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-operator">=</span> <span class="hljs-built_in">JSON_ARRAY</span>(<span class="hljs-string">&#x27;X&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">JSON_ARRAY</span>(<span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-operator">=</span> <span class="hljs-built_in">JSON_ARRAY</span>(<span class="hljs-string">&#x27;X&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------+</span><br><span class="hljs-operator">|</span>                                 <span class="hljs-number">0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------+</span><br></code></pre></td></tr></table></figure></li></ul><p>有时，我们需要在 <code>JSON</code> 文档中插入引号字符（“ 或 ”）。</p><p>例如，我们希望将这行字符串以 <code>key/value</code> 键值对的方式插入到 <code>JSON</code> 文档中。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">mascot: The MySQL mascot is a dolphin named &quot;Sakila&quot;.<br></code></pre></td></tr></table></figure><p>其中一种作为 <code>JSON</code> 对象插入表中的一种方法是使用 <code>MySQL JSON_object()</code> 函数。在这种情况下，必须使用反斜杠对每个引号字符进行转义，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> json_test(json_info) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">JSON_OBJECT</span>(&quot;mascot&quot;, &quot;Our mascot is a dolphin named \&quot;Sakila\&quot;.&quot;));<br></code></pre></td></tr></table></figure><p>如果将值作为 <code>JSON</code> 对象文字插入，则此操作的方式与此不同，在这种情况下，必须使用双反斜杠转义序列，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> json_test(json_info) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;&#123;&quot;mascot&quot;: &quot;Our mascot is a dolphin named \\&quot;Sakila\\&quot;.&quot;&#125;&#x27;</span>);<br></code></pre></td></tr></table></figure><p>使用双反斜杠可以防止 <code>MySQL</code> 执行转义序列处理，而是将字符串文本传递给存储引擎进行处理。以刚才显示的任何一种方式插入 <code>JSON</code> 对象后，通过执行简单的 <code>SELECT</code> 查询，我们可以看到 <code>JSON</code> 列值中存在反斜杠，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> json_info <span class="hljs-keyword">from</span> json_test;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> json_info                                               <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> &#123;&quot;mascot&quot;: &quot;Our mascot is a dolphin named \&quot;Sakila\&quot;.&quot;&#125; <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>我们可以使用列路径操作符 <code>-&gt;</code> 来查找这个使用 <code>mascot</code> 作为关键字的特定句子，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> json_info<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.mascot&quot; <span class="hljs-keyword">FROM</span> json_test; <br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------+</span><br><span class="hljs-operator">|</span> json_info<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.mascot&quot;                       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------+</span><br><span class="hljs-operator">|</span> &quot;Our mascot is a dolphin named \&quot;Sakila\&quot;.&quot; <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>这将会保留反斜杠以及周围的引号。要使用吉祥物作为键显示所需的值，但不包括周围的引号或任何转义符，可以使用内联路径运算符 <code>-&gt;&gt;</code>，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> json_info<span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span>&quot;$.mascot&quot; <span class="hljs-keyword">FROM</span> json_test; <br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span><br><span class="hljs-operator">|</span> json_info<span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span>&quot;$.mascot&quot;                  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span><br><span class="hljs-operator">|</span> Our mascot <span class="hljs-keyword">is</span> a dolphin named &quot;Sakila&quot;. <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span><br></code></pre></td></tr></table></figure><blockquote><p>如果启用了 <code>NO_BACKSLASH_ESCAPES</code> 服务器 <code>SQL</code> 模式，则上一个示例将无法正常工作。如果设置了此模式，则可以使用单个反斜杠而不是双反斜杠来插入 <code>JSON</code> 对象文字，并保留反斜杠。如果在执行插入时使用 <code>JSON_OBJECT()</code> 函数，并且设置了此模式，则必须交替使用单引号和双引号，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> json_test(json_info) <span class="hljs-keyword">VALUES</span> (<span class="hljs-built_in">JSON_OBJECT</span>(<span class="hljs-string">&#x27;mascot&#x27;</span>, <span class="hljs-string">&#x27;Our mascot is a dolphin named &quot;Sakila&quot;.&#x27;</span>));<br></code></pre></td></tr></table></figure></blockquote><h3 id="JSON-值的规范化、合并和自动包装"><a href="#JSON-值的规范化、合并和自动包装" class="headerlink" title="JSON 值的规范化、合并和自动包装"></a>JSON 值的规范化、合并和自动包装</h3><h4 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h4><p>当一个字符串被解析为一个有效的 <code>JSON</code> 文档时，同时也会被规范化。这意味着，从左到右读取时，与文档后面重复的键会被丢弃。所以下面的 <code>JSON_OBJECT()</code> 调用产生的对象值只包含第二个 <code>key1</code> 元素。</p><blockquote><p>RFC 7159 建议采用这种 “最后一个重复键获胜 “的行为，大多数 JavaScript 解析器都采用了这种行为。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">JSON_OBJECT</span>(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">JSON_OBJECT</span>(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------+</span><br><span class="hljs-operator">|</span> &#123;&quot;key1&quot;: &quot;def&quot;, &quot;key2&quot;: &quot;abc&quot;&#125;                       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------+</span><br><br><span class="hljs-comment">-- 这对于在 `JSON` 列中插入值同样有效。</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> json_test(json_info) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;&#123;&quot;x&quot;: 17, &quot;x&quot;: &quot;red&quot;&#125;&#x27;</span>), (<span class="hljs-string">&#x27;&#123;&quot;x&quot;: 17, &quot;x&quot;: &quot;red&quot;, &quot;x&quot;: [3, 5, 7]&#125;&#x27;</span>);<br>Query OK, <span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.04</span> sec)<br>Records: <span class="hljs-number">2</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> json_info <span class="hljs-keyword">from</span> json_test;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> json_info                                               <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> &#123;&quot;x&quot;: &quot;red&quot;&#125;                                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> &#123;&quot;x&quot;: [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]&#125;                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：在 <code>MySQL 8.0.3</code> 之前的版本中，重复键的处理策略与上面恰好相反，也就是执行 <code>first duplicate key wins</code> 的规范化处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">JSON_OBJECT</span>(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">JSON_OBJECT</span>(<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------+</span><br><span class="hljs-operator">|</span> &#123;&quot;key1&quot;: <span class="hljs-number">1</span>, &quot;key2&quot;: &quot;abc&quot;&#125;                           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------+</span><br><br><span class="hljs-comment">-- 这对于在 `JSON` 列中插入值同样有效。</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> json_test(json_info) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;&#123;&quot;x&quot;: 17, &quot;x&quot;: &quot;red&quot;&#125;&#x27;</span>), (<span class="hljs-string">&#x27;&#123;&quot;x&quot;: 17, &quot;x&quot;: &quot;red&quot;, &quot;x&quot;: [3, 5, 7]&#125;&#x27;</span>);<br>Query OK, <span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.04</span> sec)<br>Records: <span class="hljs-number">2</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> json_info <span class="hljs-keyword">from</span> json_test;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> json_info                                               <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> &#123;&quot;x&quot;: <span class="hljs-number">17</span>&#125;                                               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> &#123;&quot;x&quot;: <span class="hljs-number">17</span>&#125;                                               <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br></code></pre></td></tr></table></figure></blockquote><p><code>MySQL</code> 还会丢弃原始 <code>JSON</code> 文档中键、值或元素之间的多余空白，为了<strong>提高可读性</strong>会在显示时，在每个逗号（,）或冒号（:）后保留（或在必要时插入）一个空格。我们日常开发时在符号和逗号后面保留一个空格也是为了提高可读性。</p><p><strong>对于使用 <code>MySQL</code> 函数生成的 <code>JSON</code> 值总是返回规范化的处理。</strong></p><p>为了提高查找效率，<code>MySQL</code> 还会对 <code>JSON</code> 对象的键进行排序。需要注意的是，这种排序的结果可能会发生变化，而且不能保证在不同版本中保持一致。</p><h4 id="JSON值合并"><a href="#JSON值合并" class="headerlink" title="JSON值合并"></a>JSON值合并</h4><p><code>MySQL 8.0.3</code>（及更高版本）支持两种合并算法，由函数 <code>JSON_MERGE_PRESERVE()</code> 和 <code>JSON_MERGE_PATCH()</code> 实现</p><p>它们在处理重复键的方式上有所不同：</p><ul><li><code>JSON_MERGE_PRESERVE()</code> 会保留重复键的值。</li><li><code>JSON_MERGE_PATCH()</code> 会丢弃除最后一个值以外的所有重复值。</li></ul><blockquote><p><code>JSON_MERGE_PRESERVE()</code> 与 <code>MySQL</code> 以前版本中的 <code>JSON_MERGE()</code> 函数相同（<code>MySQL 8.0.3</code> 中重新命名）。在 <code>MySQL 8.0</code> 中，<code>JSON_MERGE()</code> 作为 <code>JSON_MERGE_PRESERVE()</code> 的别名仍受支持，但已被弃用，并可能在未来的版本中删除。</p></blockquote><h5 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h5><p>在由多个数组组合的上下文中，这些数组会合并为一个数组。</p><ul><li><p><code>JSON_MERGE_PRESERVE()</code> 通过将后面命名的数组连接到第一个数组的末尾来实现这一功能。也就是从左往右，将多个数组中的元素首尾相连，最终合并为一个数组。</p></li><li><p><code>JSON_MERGE_PATCH()</code> <strong>将每个数组视为由单个元素组成的数组</strong>（因此每个数组的索引为 0），然后应用 <code>last duplicate key wins</code> 逻辑，只选择最后一个数组。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> JSON_MERGE_PRESERVE(<span class="hljs-string">&#x27;[1, 2]&#x27;</span>, <span class="hljs-string">&#x27;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#x27;</span>, <span class="hljs-string">&#x27;[true, false]&#x27;</span>) <span class="hljs-keyword">AS</span> Preserve,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> JSON_MERGE_PATCH(<span class="hljs-string">&#x27;[1, 2]&#x27;</span>, <span class="hljs-string">&#x27;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#x27;</span>, <span class="hljs-string">&#x27;[true, false]&#x27;</span>) <span class="hljs-keyword">AS</span> Patch;<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------+---------------+</span><br><span class="hljs-operator">|</span> Preserve                           <span class="hljs-operator">|</span> Patch         <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------+---------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>] <span class="hljs-operator">|</span> [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>] <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------+---------------+</span><br></code></pre></td></tr></table></figure><h5 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h5><p>多个对象合并后产生一个对象。</p><ul><li><code>JSON_MERGE_PRESERVE()</code> 在处理具有相同键的多个对象时，会将该键的所有唯一值组合并到一个数组中，被当作结果中该键的值。</li><li><code>JSON_MERGE_PATCH()</code> 会从左到右丢弃键值重复的值，因此结果只包含该键值的最后一个值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> JSON_MERGE_PRESERVE(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;c&quot;: 3, &quot;a&quot;: 4&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;c&quot;: 5, &quot;d&quot;: 3&#125;&#x27;</span>) <span class="hljs-keyword">AS</span> Preserve,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> JSON_MERGE_PATCH(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: 3, &quot;b&quot;: 2&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;c&quot;: 3, &quot;a&quot;: 4&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;c&quot;: 5, &quot;d&quot;: 3&#125;&#x27;</span>) <span class="hljs-keyword">AS</span> Patch;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> Preserve                                   <span class="hljs-operator">|</span> Patch                            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+----------------------------------+</span><br><span class="hljs-operator">|</span> &#123;&quot;a&quot;: [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>], &quot;b&quot;: <span class="hljs-number">2</span>, &quot;c&quot;: [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>], &quot;d&quot;: <span class="hljs-number">3</span>&#125; <span class="hljs-operator">|</span> &#123;&quot;a&quot;: <span class="hljs-number">4</span>, &quot;b&quot;: <span class="hljs-number">2</span>, &quot;c&quot;: <span class="hljs-number">5</span>, &quot;d&quot;: <span class="hljs-number">3</span>&#125; <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+----------------------------------+</span><br></code></pre></td></tr></table></figure><h5 id="合并元素"><a href="#合并元素" class="headerlink" title="合并元素"></a>合并元素</h5><p>在需要数组值的上下文中使用的非数组值将被自动封装，然后将其转化为由 <code>[</code> 和 <code>]</code>字符包围的数组。</p><p>在下面的例子中，每个参数都被自动封装为一个数组（[1], [2]），与前两种情况一样，<code>JSON_MERGE_PRESERVE()</code> 会合并具有相同键值的值，而 <code>JSON_MERGE_PATCH()</code> 则会丢弃除最后一个键值外的所有重复键值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> JSON_MERGE_PRESERVE(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>) <span class="hljs-keyword">AS</span> Preserve,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> JSON_MERGE_PATCH(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>) <span class="hljs-keyword">AS</span> Patch;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------+-------+</span><br><span class="hljs-operator">|</span> Preserve <span class="hljs-operator">|</span> Patch <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+-------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]   <span class="hljs-operator">|</span> <span class="hljs-number">2</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+-------+</span><br></code></pre></td></tr></table></figure><h5 id="数组和对象合并"><a href="#数组和对象合并" class="headerlink" title="数组和对象合并"></a>数组和对象合并</h5><p>数组和对象值的合并方式是将对象自动封装为数组，并根据选择的合并函数（<code>JSON_MERGE_PRESERVE()</code> 或  <code>JSON_MERGE_PATCH()</code> ），分别通过合并值或 “最后一个重复键获胜”的方式合并数组，如本示例所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> JSON_MERGE_PRESERVE(<span class="hljs-string">&#x27;[10, 20]&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;&#125;&#x27;</span>) <span class="hljs-keyword">AS</span> Preserve,<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> JSON_MERGE_PATCH(<span class="hljs-string">&#x27;[10, 20]&#x27;</span>, <span class="hljs-string">&#x27;&#123;&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;&#125;&#x27;</span>) <span class="hljs-keyword">AS</span> Patch; <br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------+----------------------+</span><br><span class="hljs-operator">|</span> Preserve                       <span class="hljs-operator">|</span> Patch                <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------+----------------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, &#123;&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;&#125;] <span class="hljs-operator">|</span> &#123;&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;&#125; <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------+----------------------+</span><br></code></pre></td></tr></table></figure><h3 id="搜索和修改-JSON-值"><a href="#搜索和修改-JSON-值" class="headerlink" title="搜索和修改 JSON 值"></a>搜索和修改 JSON 值</h3><h4 id="路径表达式"><a href="#路径表达式" class="headerlink" title="路径表达式"></a>路径表达式</h4><p><code>JSON</code> 路径表达式对于提取或修改 <code>JSON</code> 文档部分内容的函数非常有用，它可以指定在文档中的哪个位置进行操作。例如，下面的查询从 <code>JSON</code> 文档中提取键为 <code>name</code> 的成员值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot; : 18, &quot;sex&quot; : 1&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.name&#x27;</span>); <br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;小明&quot;, &quot;age&quot; : 18, &quot;sex&quot; : 1&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.name&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> &quot;小明&quot;                                                            <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>路径语法使用前导 <code>$</code> 字符来表示所考虑的 <code>JSON</code> 文档，后面还可选择使用选择器来继续表示文档中更具体的部分：</p><ul><li><p>键名后面的句点表示对象中具有给定键的成员。<strong>如果不带引号的键名在路径表达式中不合法（例如包含空格），则键名必须用双引号指定</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 键名不合法</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;na me&quot;: &quot;小明&quot;, &quot;age&quot; : 18, &quot;sex&quot; : 1&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.na me&#x27;</span>);<br>ERROR <span class="hljs-number">3143</span> (<span class="hljs-number">42000</span>): Invalid JSON path expression. The error <span class="hljs-keyword">is</span> around <span class="hljs-type">character</span> position <span class="hljs-number">5.</span><br><br><span class="hljs-comment">-- 需要使用双引号包裹</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;na me&quot;: &quot;小明&quot;, &quot;age&quot; : 18, &quot;sex&quot; : 1&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.&quot;na me&quot;&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;na me&quot;: &quot;小明&quot;, &quot;age&quot; : 18, &quot;sex&quot; : 1&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.&quot;na me&quot;&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> &quot;小明&quot;                                                                <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------------------------------+</span><br></code></pre></td></tr></table></figure></li><li><p>将<code>[N]</code> 附加到选择数组的路径上（例如 <code>$</code>）表示指定数组中位置为 <code>N</code> 的值。数组位置是以 0 开头的整数。如果 <code>path</code> 没有选择数组值，则 <code>path</code> 的值与 <code>path[0]</code> 相同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_SET(<span class="hljs-string">&#x27;&quot;x&quot;&#x27;</span>, <span class="hljs-string">&#x27;$[0]&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------+</span><br><span class="hljs-operator">|</span> JSON_SET(<span class="hljs-string">&#x27;&quot;x&quot;&#x27;</span>, <span class="hljs-string">&#x27;$[0]&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------+</span><br><span class="hljs-operator">|</span> &quot;a&quot;                          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------+</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_SET(<span class="hljs-string">&#x27;&quot;x&quot;&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);    <br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------+</span><br><span class="hljs-operator">|</span> JSON_SET(<span class="hljs-string">&#x27;&quot;x&quot;&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------+</span><br><span class="hljs-operator">|</span> &quot;a&quot;                       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------+</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_SET(<span class="hljs-string">&#x27;&quot;x&quot;&#x27;</span>, <span class="hljs-string">&#x27;$[1]&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);  <br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------+</span><br><span class="hljs-operator">|</span> JSON_SET(<span class="hljs-string">&#x27;&quot;x&quot;&#x27;</span>, <span class="hljs-string">&#x27;$[1]&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------+</span><br><span class="hljs-operator">|</span> [&quot;x&quot;, &quot;a&quot;]                   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------+</span><br></code></pre></td></tr></table></figure></li><li><p><code>[M to N]</code> 指定数组值的子集或范围，从位置 M 的值开始，到位置 N 的值结束。</p><blockquote><p><code>last</code> 作为最右边数组元素索引同样被支持，</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_SET(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;&#x27;</span>, <span class="hljs-string">&#x27;$[last]&#x27;</span>, <span class="hljs-string">&#x27;Los Angeles&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_SET(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;&#x27;</span>, <span class="hljs-string">&#x27;$[last]&#x27;</span>, <span class="hljs-string">&#x27;Los Angeles&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> &quot;Los Angeles&quot;                                                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------------------------------------+</span><br></code></pre></td></tr></table></figure></li><li><p>路径可以包含 <code>*</code> 或 <code>**</code> 通配符：</p><ul><li><code>.[*]</code>表示为 <code>JSON</code> 对象中所有成员的值。</li><li><code>[*]</code> 表示为 <code>JSON</code> 数组中所有元素的值。</li><li><em><code>prefix</code>**<code>suffix </code></em> 会匹配以指定前缀开头、以指定后缀结尾的所有路径。</li></ul></li><li><p>获取文档中不存在的路径（求值为不存在的数据）时会返回 <code>NULL</code>。</p></li></ul><p>举个例子：我们使用 <code>$</code> 来表示下面这个包含三个元素的 <code>JSON</code> 数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">6</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;b&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span><span class="hljs-number">99</span><span class="hljs-punctuation">,</span> <span class="hljs-number">100</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><ul><li><code>$[0]</code> 表示 <code>3</code>.</li><li><code>$[1]</code> 表示  <code>&#123;&quot;a&quot;: [5, 6], &quot;b&quot;: 10&#125;</code>.</li><li><code>$[2]</code> 表示 <code>[99, 100]</code>.</li><li><code>$[3]</code> 返回的结果为 <code>NULL</code> （它指的是第四个数组元素，该元素不存在）。</li></ul><p>由于 <code>$[1]</code> 和 <code>$[2]</code>  表示非标量值，因此它们可以用作选择嵌套值的更具体路径表达式的基础。例子：</p><ul><li><code>$[1].a</code> 表示 <code>[5, 6]</code>.</li><li><code>$[1].b</code> 表示 <code>10</code>.</li><li><code>$[2][0]</code> 表示 <code>99</code>.</li></ul><p>使用通配符的路径计算结果为可以包含多个值的数组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: [3, 4, 5]&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.*&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: [3, 4, 5]&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.*&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]                                       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: [3, 4, 5]&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.c[*]&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: [3, 4, 5]&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.c[*]&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]                                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>在以下示例中，路径<code>$**.b</code> 表示为多个路径（<code>$.a.b</code>和 <code>$.c.b</code>）并生成匹配路径值的数组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: &#123;&quot;b&quot;: 1&#125;, &quot;c&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;</span>, <span class="hljs-string">&#x27;$**.b&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: &#123;&quot;b&quot;: 1&#125;, &quot;c&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;</span>, <span class="hljs-string">&#x27;$**.b&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]                                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p><strong>JSON 数组的范围。</strong> 可以使用带有 <code>to</code> 关键字的范围来指定 <code>JSON</code> 数组的子集。例如，<code>$[1 to 3]</code>包含数组的第二个、第三个和第四个元素，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[1, 2, 3, 4, 5]&#x27;</span>, <span class="hljs-string">&#x27;$[1 to 3]&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[1, 2, 3, 4, 5]&#x27;</span>, <span class="hljs-string">&#x27;$[1 to 3]&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>语法 <code>M to N</code>，其中 M 和 N 分别是 <code>JSON</code> 数组元素所取范围的第一个和最后一个索引。数组元素的索引从 0 开始。</p><p>最右边的数组元素： <code>last</code> 关键字是数组中最后一个元素索引的代名词。<code>last - N</code> 形式的表达式可用于相对寻址和范围定义，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[1, 2, 3, 4, 5]&#x27;</span>, <span class="hljs-string">&#x27;$[last-3 to last-1]&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[1, 2, 3, 4, 5]&#x27;</span>, <span class="hljs-string">&#x27;$[last-3 to last-1]&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]                                              <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>如果路径表达式是针对一个非数组的值进行求值，求值结果与该值被包在单元素数组中的结果相同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_REPLACE(<span class="hljs-string">&#x27;&quot;Sakila&quot;&#x27;</span>, <span class="hljs-string">&#x27;$[last]&#x27;</span>, <span class="hljs-number">10</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_REPLACE(<span class="hljs-string">&#x27;&quot;Sakila&quot;&#x27;</span>, <span class="hljs-string">&#x27;$[last]&#x27;</span>, <span class="hljs-number">10</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">10</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span><br></code></pre></td></tr></table></figure><h4 id="JSON值搜索"><a href="#JSON值搜索" class="headerlink" title="JSON值搜索"></a>JSON值搜索</h4><p>我们可以使用带有 <code>JSON</code> 列标识符和 <code>JSON</code> 路径表达式的 <code>column-&gt;path</code> 作为 <code>JSON_EXTRACT(column,path)</code> 的同义词。</p><ul><li><p><code>JSON_CONTAINS (target, candidate[, path])</code></p><p>通过返回 1 或 0 表示给定的 <code>candidate</code> 是否包含在目标 <code>JSON</code> 文档中，或者（如果提供了路径参数）候选文档是否在目标文档的特定路径中找到。如果任何参数为 NULL，或者路径参数未指定目标文档的某个部分，则返回 NULL。如果目标或候选对象不是有效的 JSON 文档，或者路径参数不是有效的路径表达式或包含 * 或 ** 通配符，则会发生错误。仅检查路径中是否存在<strong>任何数据</strong>，请改用 <code>JSON_CONTAINS_PATH()</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-variable">@j</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;d&quot;: 4&#125;&#125;&#x27;</span>;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-variable">@j2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_CONTAINS(<span class="hljs-variable">@j</span>, <span class="hljs-variable">@j2</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span> JSON_CONTAINS(<span class="hljs-variable">@j</span>, <span class="hljs-variable">@j2</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span>                             <span class="hljs-number">1</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_CONTAINS(<span class="hljs-variable">@j</span>, <span class="hljs-variable">@j2</span>, <span class="hljs-string">&#x27;$.b&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span> JSON_CONTAINS(<span class="hljs-variable">@j</span>, <span class="hljs-variable">@j2</span>, <span class="hljs-string">&#x27;$.b&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span>                             <span class="hljs-number">0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-variable">@j2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#123;&quot;d&quot;: 4&#125;&#x27;</span>;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_CONTAINS(<span class="hljs-variable">@j</span>, <span class="hljs-variable">@j2</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span> JSON_CONTAINS(<span class="hljs-variable">@j</span>, <span class="hljs-variable">@j2</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span>                             <span class="hljs-number">0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_CONTAINS(<span class="hljs-variable">@j</span>, <span class="hljs-variable">@j2</span>, <span class="hljs-string">&#x27;$.c&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span> JSON_CONTAINS(<span class="hljs-variable">@j</span>, <span class="hljs-variable">@j2</span>, <span class="hljs-string">&#x27;$.c&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span>                             <span class="hljs-number">1</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br></code></pre></td></tr></table></figure></li><li><p><code>JSON_EXTRACT(json_doc, path[, path] ...)</code></p><p>从 <code>JSON</code> 文档返回数据，该数据是从与参数 <em><code>path</code></em>  匹配的文档部分中选择的。如果有任何参数 <code>NULL</code>或没有路径在文档中找到值，则返回 <code>NULL</code>。如果参数不是有效的 <code>JSON</code> 文档或任何 <code>path</code> 参数都不是有效的路径表达式， 则会发生错误 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[10, 20, [30, 40]]&#x27;</span>, <span class="hljs-string">&#x27;$[1]&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[10, 20, [30, 40]]&#x27;</span>, <span class="hljs-string">&#x27;$[1]&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">20</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------+</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[10, 20, [30, 40]]&#x27;</span>, <span class="hljs-string">&#x27;$[1]&#x27;</span>, <span class="hljs-string">&#x27;$[0]&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[10, 20, [30, 40]]&#x27;</span>, <span class="hljs-string">&#x27;$[1]&#x27;</span>, <span class="hljs-string">&#x27;$[0]&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------------------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">20</span>, <span class="hljs-number">10</span>]                                           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------------------------+</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[10, 20, [30, 40]]&#x27;</span>, <span class="hljs-string">&#x27;$[2][*]&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------+</span><br><span class="hljs-operator">|</span> JSON_EXTRACT(<span class="hljs-string">&#x27;[10, 20, [30, 40]]&#x27;</span>, <span class="hljs-string">&#x27;$[2][*]&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------+</span><br><span class="hljs-operator">|</span> [<span class="hljs-number">30</span>, <span class="hljs-number">40</span>]                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>MySQL 支持 <code>-&gt;</code> 运算符作为此函数的简写形式，它可以与 2 个参数一起使用，其中左侧是 <code>JSON</code> 列标识符（不是表达式），右侧是要在列中匹配的 <code>JSON</code> 路径。</p></li><li><p><code>column</code> <em>-&gt;</em><code>path</code> （此功能不限于 <code>SELECT</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> c, JSON_EXTRACT(c, &quot;$.id&quot;), g<br>     <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> jemp<br>     <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> JSON_EXTRACT(c, &quot;$.id&quot;) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br>     <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> JSON_EXTRACT(c, &quot;$.name&quot;);<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+-----------+------+</span><br><span class="hljs-operator">|</span> c                             <span class="hljs-operator">|</span> c<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.id&quot; <span class="hljs-operator">|</span> g    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+-----------+------+</span><br><span class="hljs-operator">|</span> &#123;&quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;Barney&quot;&#125; <span class="hljs-operator">|</span> &quot;3&quot;       <span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> &#123;&quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;Betty&quot;&#125;  <span class="hljs-operator">|</span> &quot;4&quot;       <span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> &#123;&quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;Wilma&quot;&#125;  <span class="hljs-operator">|</span> &quot;2&quot;       <span class="hljs-operator">|</span>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+-----------+------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> c, c<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.id&quot;, g<br>     <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> jemp<br>     <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> c<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.id&quot; <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br>     <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.name&quot;;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+-----------+------+</span><br><span class="hljs-operator">|</span> c                             <span class="hljs-operator">|</span> c<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.id&quot; <span class="hljs-operator">|</span> g    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+-----------+------+</span><br><span class="hljs-operator">|</span> &#123;&quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;Barney&quot;&#125; <span class="hljs-operator">|</span> &quot;3&quot;       <span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> &#123;&quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;Betty&quot;&#125;  <span class="hljs-operator">|</span> &quot;4&quot;       <span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> &#123;&quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;Wilma&quot;&#125;  <span class="hljs-operator">|</span> &quot;2&quot;       <span class="hljs-operator">|</span>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+-----------+------+</span><br></code></pre></td></tr></table></figure></li><li><p><code>column -&gt;&gt; path</code></p><p>这是一个改进的、不带引号的提取运算符。虽然该<code>-&gt;</code>运算符只是提取一个值，但该<code>-&gt;&gt;</code>运算符还取消提取引用的结果。该运算符可以在任何允许的<code>-&gt;&gt;</code>地方使用 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> jemp <span class="hljs-keyword">WHERE</span> g <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+------+</span><br><span class="hljs-operator">|</span> c                             <span class="hljs-operator">|</span> g    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+------+</span><br><span class="hljs-operator">|</span> &#123;&quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;Barney&quot;&#125; <span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> &#123;&quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;Betty&quot;&#125;  <span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> c<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-string">&#x27;$.name&#x27;</span> <span class="hljs-keyword">AS</span> name<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">FROM</span> jemp <span class="hljs-keyword">WHERE</span> g <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span> &quot;Barney&quot; <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> &quot;Betty&quot;  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> JSON_UNQUOTE(c<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span><span class="hljs-string">&#x27;$.name&#x27;</span>) <span class="hljs-keyword">AS</span> name<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">FROM</span> jemp <span class="hljs-keyword">WHERE</span> g <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+</span><br><span class="hljs-operator">|</span> name   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+</span><br><span class="hljs-operator">|</span> Barney <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> Betty  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> c<span class="hljs-operator">-</span><span class="hljs-operator">&gt;&gt;</span><span class="hljs-string">&#x27;$.name&#x27;</span> <span class="hljs-keyword">AS</span> name<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">FROM</span> jemp <span class="hljs-keyword">WHERE</span> g <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+</span><br><span class="hljs-operator">|</span> name   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+</span><br><span class="hljs-operator">|</span> Barney <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> Betty  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure></li><li><p><code>JSON_VALUE(json_doc, path)</code></p><p>从指定文档中给定路径处的 <code>JSON</code> 文档中提取值，并返回提取的值，可以选择将其转换为所需的类型。完整的语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">JSON_VALUE</span>(json_doc, path [RETURNING type] [on_empty] [on_error])<br><br>on_empty:<br>    &#123;<span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> ERROR <span class="hljs-operator">|</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">value</span>&#125; <span class="hljs-keyword">ON</span> <span class="hljs-keyword">EMPTY</span><br><br>on_error:<br>    &#123;<span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> ERROR <span class="hljs-operator">|</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">value</span>&#125; <span class="hljs-keyword">ON</span> ERROR<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">JSON_VALUE</span>(<span class="hljs-string">&#x27;&#123;&quot;fname&quot;: &quot;Joe&quot;, &quot;lname&quot;: &quot;Palmer&quot;&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.fname&#x27;</span>);<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">JSON_VALUE</span>(<span class="hljs-string">&#x27;&#123;&quot;fname&quot;: &quot;Joe&quot;, &quot;lname&quot;: &quot;Palmer&quot;&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.fname&#x27;</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> Joe                                                          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------------------------------------------+</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">JSON_VALUE</span>(<span class="hljs-string">&#x27;&#123;&quot;item&quot;: &quot;shoes&quot;, &quot;price&quot;: &quot;49.95&quot;&#125;&#x27;</span>, <span class="hljs-string">&#x27;$.price&#x27;</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> RETURNING <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)) <span class="hljs-keyword">AS</span> price;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+</span><br><span class="hljs-operator">|</span> price <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">49.95</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://dev.mysql.com/doc/refman/8.0/en/json.html">https://dev.mysql.com/doc/refman/8.0/en/json.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture-一种异步任务编排解决方案</title>
    <link href="/2023/10/13/CompletableFuture-%E4%B8%80%E7%A7%8D%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/10/13/CompletableFuture-%E4%B8%80%E7%A7%8D%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>多线程主要是通过提高对 <code>CPU</code> 的利用率从而提升多任务处理的效率，以满足用户的友好体验。</p><p>根据 <code>Oracle</code> 官方文档的描述：<code>JAVA</code> 中创建线程的方式有两种：</p><ol><li>继承 <code>java.lang.Thread</code> 类。（ <code>Thread</code> 类本质上也是实现了 <code>Runnable</code> 接口）</li><li>实现 <code>java.lang.Runnable</code> 接口。</li></ol><p>但是，这两种方法都存在一个缺陷——没有返回值，也就是说我们无法得知线程执行结果。</p><h3 id="Future模型"><a href="#Future模型" class="headerlink" title="Future模型"></a>Future模型</h3><p>为了解决这个问题，<code>JDK1.5</code> 引入了 <code>Future</code> 和 <code>Callable</code> 接口，我们只需要将创建的任务 <code>submit</code> 到线程池，之后我们可以执行其他业务逻辑，根据需要再通过 <code>java.util.concurrent.Future#get()</code> 方法就能够得到任务执行的返回值，节约程序的运行时间。</p><p>通过一个例子快速了解 <code>Future</code> 模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 为了方便测试，这里直接使用Executors创建线程池</span><br>    <span class="hljs-comment">// 实际项目中，不推荐使用Executors创建线程池，其内部使用的是无界队列，容易造成OOM</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <br>    Future&lt;String&gt; future1 = executorService.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// 模拟任务1执行耗时</span><br>        Thread.sleep(<span class="hljs-number">300</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务1执行完成&quot;</span>;<br>    &#125;);<br>    <br>    Future&lt;String&gt; future2 = executorService.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// 模拟任务2执行耗时</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务2执行完成&quot;</span>;<br>    &#125;);<br>    <br>    <span class="hljs-comment">// 模拟主线程处理其他业务耗时</span><br>    Thread.sleep(<span class="hljs-number">300</span>);<br>    <br>    <span class="hljs-comment">// 获取任务1执行结果</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> future1.get();<br>    System.out.println(result1);<br>    <br>    <span class="hljs-comment">// 获取任务2执行结果</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> future2.get();<br>    System.out.println(result2);<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;总耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot;ms&quot;</span>);<br>    <br>    executorService.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">任务1执行完成<br>任务2执行完成<br>总耗时：564ms<br></code></pre></td></tr></table></figure><p>可以看到，合理使用异步任务可以大大提高程序的执行效率。</p><h3 id="Future的局限性"><a href="#Future的局限性" class="headerlink" title="Future的局限性"></a>Future的局限性</h3><p>从上面实例的输出我们可以看到，调用 <code>java.util.concurrent.Future#get()</code> 方法会一直阻塞主线程。</p><p>简单业务上，我们可以使用 <code>Future</code> 的另一个重载方法 <code>get(long, TimeUnit)</code> 来设置超时时间，避免主线程被永远阻塞。</p><p><code>get()</code> 方法原文描述：</p><blockquote><p>Waits if necessary for the computation to complete, and then retrieves its result.</p></blockquote><p>当然 <code>Future</code> 还贴心的提供了一个 <code>isDone()</code> 方法，可以在程序中<strong>轮询</strong>调用这个方法，等待处理完成后再调用 <code>get()</code> 方法获取返回值。</p><p>注意！如果任务完成，调用 <code>isDone()</code> 方法将返回 <code>true</code> ，<strong>但完成可能是由于正常终止、异常或取消——在所有这些情况下，此方法都将返回true</strong>。</p><p>而对于 <code>JDK8</code> 中的 <code>isDone()</code> 方法还存在这样一个 <code>BUG</code>，目前已在 <code>JDK9</code> 修复，大家感兴趣可以去看看。<a href="https://bugs.openjdk.org/browse/JDK-8073704">JDK-8073704</a></p><p><code>isDone()</code> 方法原文描述：</p><blockquote><p>Returns true if this task completed. Completion may be due to normal termination, an exception, or cancellation – in all of these cases, this method will return true.</p></blockquote><p>但无论是哪种方法，<code>Future</code> 对于处理结果的获取似乎都显得不够友好。</p><p><strong>阻塞的方式和异步编程的设计理念相违背，而轮询的方式又会无谓的耗费CPU资源</strong>。</p><p>那么~ 就只能到此为止了吗？</p><p>当然不是，<code>Doug Lea</code> 大神在 <code>JDK8</code> 又给我们带来了并发编程神器—— <code>CompletableFuture</code> 。</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><code>JAVA8</code> 引入的 <code>CompletableFuture</code>  解决了 <code>Future</code> 在实际使用过程中不支持异步任务的编排组合以及阻塞获取任务返回值的问题。</p><p>除了提供更为好用的 <code>Future</code> 特性之外，<code>CompletableFuture</code> 还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><p><code>CompletableFuture</code> 类结构示意图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletableFuture</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://image.seeyourface.cn/migrate/image-20231013170446028.png" alt="image-20231013170446028"></p><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口:</p><p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。多个计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p><p><code>CompletableFuture</code> 通过继承 <code>CompletionStage</code> 获取其提供的函数式能力。从这个接口的方法参数可以发现其大量使用了 <code>Java8</code> 引入的函数式编程。</p><p><img src="https://image.seeyourface.cn/migrate/image-20231013171231135.png" alt="image-20231013171231135"></p><h3 id="CompletableFuture使用"><a href="#CompletableFuture使用" class="headerlink" title="CompletableFuture使用"></a>CompletableFuture使用</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>有两种常见的创建 <code>CompletableFuture</code> 对象的方法：</p><ol><li>通过 <code>new</code> 关键字。</li><li>基于 <code>CompletableFuture</code> 自带的静态工厂方法：<code>runAsync()</code>、<code>supplyAsync()</code> 。</li></ol><h5 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h5><p>通过 <code>new</code> 关键字创建 <code>CompletableFuture</code> 对象这种使用方式可以看作是将 <code>CompletableFuture</code> 当做 <code>Future</code> 来使用。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以将completableFuture看成是一个容器，里面存放异步运算的返回结果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CompletableFuture&lt;String&gt; completableFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <br>    executorService.execute(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">600</span>);<br>            <span class="hljs-comment">// 在未来某个时刻，线程处理完了最终的结果，将结果放入completableFuture</span><br>            completableFuture.complete(<span class="hljs-string">&quot;i am ready&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>        &#125;<br>    &#125;);<br>    <br>    executorService.execute(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过completableFuture的isDone方法判断异步运算是否结束</span><br>                <span class="hljs-keyword">if</span> (completableFuture.isDone()) &#123;<br>                    <span class="hljs-comment">// 从completableFuture中获取异步运算的结果</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> completableFuture.get();<br>                    System.out.println(result);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                System.out.println(<span class="hljs-string">&quot;wait&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (end - start));<br>    <br>    executorService.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">耗时：41<br>wait<br>wait<br>wait<br>wait<br>wait<br>wait<br>i am ready<br></code></pre></td></tr></table></figure><h5 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span>;<br><br><span class="hljs-comment">// 推荐使用下面自定义线程池的方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable,Executor executor)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier,Executor executor)</span>;<br></code></pre></td></tr></table></figure><p>静态工厂实例化有两种格式，一种是supply开头的方法，一种是run开头的方法：</p><ul><li>supply开头：方法接收的参数是 <code>Supplier&lt;U&gt;</code> ，这也是一个函数式接口，<code>U</code> 是返回结果值的类型。当你需要异步操作且关心返回结果的时候，可以使用 <code>supplyAsync()</code> 方法。</li><li>run开头：方法接收的参数是 <code>Runnable</code> ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 <code>runAsync()</code> 方法。</li></ul><blockquote><p>在静态工厂实例化方法中，我们是可以指定Executor参数的，当我们不指定的话，我们所开的并行线程使用的是默认系统及公共线程池 <code>ForkJoinPool.commonPool()</code> ，它是被当前  <code>JVM</code>（进程）上的所有 <code>CompletableFuture</code>、并行 <code>Stream</code> 所共享的，<code>commonPool</code>  的目标场景是非阻塞的 CPU 密集型任务，其线程数默认为 CPU 数量减1，所以对于我们用 <code>java</code> 常做的IO密集型任务，默认线程池是远远不够使用的；</p><p>在双核及以下机器上，默认线程池又会<strong>退化</strong>为给每个任务创建一个线程，相当于没有线程池。</p></blockquote><h4 id="异步任务回调"><a href="#异步任务回调" class="headerlink" title="异步任务回调"></a>异步任务回调</h4><h5 id="thenRun-thenRunAsync"><a href="#thenRun-thenRunAsync" class="headerlink" title="thenRun()&#x2F;thenRunAsync()"></a>thenRun()&#x2F;thenRunAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继续沿用上一个任务的线程池</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRun</span><span class="hljs-params">(Runnable action)</span> &#123;<br><span class="hljs-keyword">return</span> uniRunStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><span class="hljs-comment">// 使用默认线程池 ForkJoinPool.commonPool()</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRunAsync</span><span class="hljs-params">(Runnable action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniRunStage(asyncPool, action);<br>&#125;<br><br><span class="hljs-comment">// 使用自定义线程池</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRunAsync</span><span class="hljs-params">(Runnable action, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniRunStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p>接收一个 <code>Runnable</code> 参数，即完成某个任务后执行回调方法接着执行第二个任务，前后任务之间没有参数传递，第二个任务也没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; <br>        System.out.printf(<span class="hljs-string">&quot;%s-执行第一个方法%n&quot;</span>, Thread.currentThread().getName()), executorService);<br><br><span class="hljs-comment">// 沿用上一个任务的线程池</span><br> CompletableFuture&lt;Void&gt; future2 = future1.thenRun(() -&gt; <br>         System.out.printf(<span class="hljs-string">&quot;%s-执行第二个方法%n&quot;</span>, Thread.currentThread().getName()));<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// pool-1-thread-1-执行第一个方法</span><br><span class="hljs-comment">// pool-1-thread-1-执行第二个方法</span><br><br><span class="hljs-comment">// 使用默认的线程池</span><br><span class="hljs-comment">//CompletableFuture&lt;Void&gt; future2 = future1.thenRunAsync(() -&gt;</span><br><span class="hljs-comment">//  System.out.printf(&quot;%s-执行第二个方法%n&quot;, Thread.currentThread().getName()));</span><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// pool-1-thread-1-执行第一个方法</span><br><span class="hljs-comment">// ForkJoinPool.commonPool-worker-9-执行第二个方法</span><br><br><span class="hljs-comment">//ExecutorService executorService2 = Executors.newFixedThreadPool(3);</span><br><span class="hljs-comment">// 使用自定义线程池</span><br><span class="hljs-comment">//CompletableFuture&lt;Void&gt; future2 = future1.thenRunAsync(() -&gt;</span><br><span class="hljs-comment">//        System.out.printf(&quot;%s-执行第二个方法%n&quot;, Thread.currentThread().getName()), executorService2)</span><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// pool-1-thread-1-执行第一个方法</span><br><span class="hljs-comment">// pool-2-thread-1-执行第二个方法</span><br><br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h5 id="thenAccept-thenAcceptAsync"><a href="#thenAccept-thenAcceptAsync" class="headerlink" title="thenAccept()&#x2F;thenAcceptAsync()"></a>thenAccept()&#x2F;thenAcceptAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAccept</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(asyncPool, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action,</span><br><span class="hljs-params">                                               Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Consumer&lt;? super T&gt; action</code> 表示其可以接受 <code>T</code> 类型或 <code>T</code> 的超类型的参数。这是为了提高通用性，允许你传递更广泛的类型作为参数。并且回调方法执行完毕后没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">1</span>, executorService);<br><br><span class="hljs-comment">// future1的返回值是 Integer，这里我们可以传入它的超类Number</span><br>future1.thenAccept((Number n) -&gt; System.out.println(n.doubleValue() + <span class="hljs-number">10</span>)); <span class="hljs-comment">// 11.0</span><br><br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h5 id="thenApply-thenApplyAsync"><a href="#thenApply-thenApplyAsync" class="headerlink" title="thenApply()&#x2F;thenApplyAsync()"></a>thenApply()&#x2F;thenApplyAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApply</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApplyAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(asyncPool, fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApplyAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>接收一个入参为 <code>Function&lt;? super T,? extends U&gt;</code> 的函数式接口参数，也就是将上一个 <code>Future</code> 的返回值当作下一个方法的入参传入，并且回调方法内可以<strong>自定义</strong>返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Hello&quot;</span>, executorService);<br><br>CompletableFuture&lt;Boolean&gt; future2 = future1.thenApply((str) -&gt; &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> str + <span class="hljs-string">&quot; World&quot;</span>;<br>    <span class="hljs-keyword">return</span> s.equals(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>&#125;);<br><br>System.out.println(future2.get()); <span class="hljs-comment">// ture</span><br><br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h5 id="whenComplete-whenCompleteAsync"><a href="#whenComplete-whenCompleteAsync" class="headerlink" title="whenComplete()&#x2F;whenCompleteAsync()"></a>whenComplete()&#x2F;whenCompleteAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenComplete</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(<span class="hljs-literal">null</span>, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(asyncPool, action);<br>&#125;<br><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法接收的参数为 <code>BiConsumer&lt;? super T, ? super Throwable&gt;</code> ，它接受 <code>T</code> 类型或 <code>T</code> 的超类型的参数，以及上个方法抛出的异常。</p><p>需要注意的是，这个方法并<strong>没有返回</strong>值，<code>whenComplete</code> 方法返回的 <code>CompletableFuture</code> 的<strong>result是上个任务的结果</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-comment">// 手动抛出异常</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>&#125;, executorService);<br><br>CompletableFuture&lt;String&gt; future2 = future1.whenComplete((res, ex) -&gt; &#123;<br>   <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>       System.out.println(ex.getMessage());<br>       <span class="hljs-comment">// java.lang.ArithmeticException: / by zero</span><br>   &#125;<br>&#125;);<br><br><span class="hljs-comment">// 如果我们把手动抛出的异常注释掉，这里的输出将是：future2的结果hello world</span><br>System.out.println(<span class="hljs-string">&quot;future2的结果&quot;</span> + future2.get());<br><br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h5 id="handle-handleAsync"><a href="#handle-handleAsync" class="headerlink" title="handle()&#x2F;handleAsync()"></a>handle()&#x2F;handleAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handleAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(asyncPool, fn);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handleAsync</span><span class="hljs-params">(</span><br><span class="hljs-params">    BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniHandleStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>handle()</code> 方法和 <code>whenComplete()</code> 方法的接收入参没有区别，但不同的地方在于 <code>handle()</code> 方法是<strong>有返回值</strong>的，并且是可以自定义返回值的。</p><p><code>handle(</code>) 方法返回的 <code>CompletableFuture</code> 的 <code>result</code> 是<strong>回调方法</strong>执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;future1 result&quot;</span>;<br>&#125;, executorService);<br><br>CompletableFuture&lt;String&gt; future2 = future1.handle((res, ex) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;future2 result&quot;</span>;<br>&#125;);<br><br>System.out.println(<span class="hljs-string">&quot;future2的结果&quot;</span> + future2.get()); <span class="hljs-comment">// future2的结果future2 result</span><br><br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h5 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally()"></a>exceptionally()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">exceptionally</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;Throwable, ? extends T&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniExceptionallyStage(fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>处理任务异常时执行的回调方法，由抛出的异常作为方法入参，有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;future1 result&quot;</span>;<br>&#125;, executorService);<br><br> CompletableFuture&lt;String&gt; exceptionally = future1.exceptionally((ex) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(ex.getMessage());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;程序出现异常&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;程序正常运行&quot;</span>;<br>&#125;);<br><br>System.out.println(exceptionally.get());<span class="hljs-comment">// 程序出现异常</span><br><br>executorService.shutdown();<br></code></pre></td></tr></table></figure><h4 id="异步任务组合"><a href="#异步任务组合" class="headerlink" title="异步任务组合"></a>异步任务组合</h4><h5 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h5><p><img src="https://image.seeyourface.cn/migrate/Completable%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88.png" alt="Completable异步任务组合"></p><h5 id="AND组合关系"><a href="#AND组合关系" class="headerlink" title="AND组合关系"></a>AND组合关系</h5><p><code>thenCombine</code> &#x2F; <code>thenAcceptBoth</code> &#x2F; <code>runAfterBoth</code>都表示：<strong>将两个 <code>CompletableFuture</code> 组合起来，只有这两个都正常执行完了，才会执行某个任务</strong>。</p><p>它们之间的区别在于：</p><ul><li><code>thenCombine</code>：会将两个任务的执行结果作为方法入参，传递到指定方法中，且<strong>有返回值</strong>。</li><li><code>thenAcceptBoth</code>: 会将两个任务的执行结果作为方法入参，传递到指定方法中，且<strong>无返回值</strong>。</li><li><code>runAfterBoth</code> 不会把执行结果当做方法入参，且没有返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">5</span>);<br>CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">7</span>);<br><br><span class="hljs-comment">// result1 是 future1 的结果，result2 是 future2 的结果</span><br>CompletableFuture&lt;Integer&gt; combinedFuture = future1.thenCombine(future2, Integer::sum);<br><br>combinedFuture.thenAccept(result -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Combined Result: &quot;</span> + result);<br>&#125;);<br><br><span class="hljs-comment">// 阻塞等待结果</span><br>combinedFuture.join(); <span class="hljs-comment">// Combined Result: 12</span><br></code></pre></td></tr></table></figure><h5 id="OR组合关系"><a href="#OR组合关系" class="headerlink" title="OR组合关系"></a>OR组合关系</h5><p><code>applyToEither</code> &#x2F; <code>acceptEither</code> &#x2F; <code>runAfterEither</code> 都表示：<strong>将两个 <code>CompletableFuture</code> 组合起来，只要其中一个执行完了，就会执行某个任务</strong>。</p><p>它们之间的区别在于：</p><ul><li><p><code>applyToEither</code>：会将已经执行完成的任务，作为方法入参，传递到指定方法中，且<strong>有返回值</strong></p></li><li><p><code>acceptEither</code>：会将已经执行完成的任务，作为方法入参，传递到指定方法中，且<strong>无返回值</strong></p></li><li><p><code>runAfterEither</code>：不会把执行结果当做方法入参，且没有返回值。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;);<br><br>CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;);<br><br>CompletableFuture&lt;Integer&gt; resultFuture = future1.applyToEither(future2, result -&gt; &#123;<br>    <span class="hljs-comment">// result 是首个完成的 CompletableFuture 的结果</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>&#125;);<br><br>resultFuture.thenAccept(result -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Result of the first completed future: &quot;</span> + result);<br>&#125;);<br><br><span class="hljs-comment">// 阻塞等待结果</span><br>resultFuture.join(); <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><h5 id="allOf"><a href="#allOf" class="headerlink" title="allOf()"></a>allOf()</h5><p><code>allOf</code> 方法用于等待多个 <code>CompletableFuture</code> 都完成后执行操作。它不返回一个合并的结果，而只是在所有的 <code>CompletableFuture</code> 都完成后触发一个操作。这个方法通常用于等待多个任务都完成后才继续执行其他操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;future1 is done&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;);<br><br>CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;future2 is done&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>&#125;);<br><br>CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;future3 is done&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;);<br><br>CompletableFuture&lt;Void&gt; allOfFuture = CompletableFuture.allOf(future1, future2, future3);<br><br>allOfFuture.thenRun(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;All futures have completed.&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 阻塞等待所有的 CompletableFuture 完成</span><br>allOfFuture.join();<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// future3 is done</span><br><span class="hljs-comment">// future1 is done</span><br><span class="hljs-comment">// future2 is done</span><br><span class="hljs-comment">// All futures have completed.</span><br></code></pre></td></tr></table></figure><h5 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf()"></a>anyOf()</h5><p><code>anyOf</code> 方法用于等待多个 <code>CompletableFuture</code> 中的任何一个完成后执行操作。它不等待所有 <code>CompletableFuture</code> 都完成，只需等待任何一个完成即可触发操作。这对于在多个任务中获取最快完成的结果非常有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;);<br><br>CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>&#125;);<br><br>CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;);<br><br>CompletableFuture&lt;Object&gt; anyOfFuture = CompletableFuture.anyOf(future1, future2, future3);<br>anyOfFuture.thenAccept(result -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Result of the first completed future: &quot;</span> + result);<br>&#125;);<br><br><span class="hljs-comment">// 阻塞等待结果</span><br>anyOfFuture.join(); <span class="hljs-comment">// Result of the first completed future: 3</span><br></code></pre></td></tr></table></figure><h5 id="thenCombine"><a href="#thenCombine" class="headerlink" title="thenCombine()"></a>thenCombine()</h5><p><code>thenCombine</code> 方法是用于组合两个独立的 <code>CompletableFuture</code> 的结果，然后在两者都完成时执行一个操作。</p><p>这个操作接受两个参数，分别是两个 <code>CompletableFuture</code> 的结果，并返回一个新的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">5</span>);<br>CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">7</span>);<br><br><span class="hljs-comment">// result1 是 future1 的结果，result2 是 future2 的结果</span><br>CompletableFuture&lt;Integer&gt; combinedFuture = future1.thenCombine(future2, Integer::sum);<br><br>combinedFuture.thenAccept(result -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;Combined Result: &quot;</span> + result);<br>&#125;);<br><br><span class="hljs-comment">// 阻塞等待结果</span><br>combinedFuture.join(); <span class="hljs-comment">//Combined Result: 12</span><br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="Future需要获取返回值，才能获取异常信息。"><a href="#Future需要获取返回值，才能获取异常信息。" class="headerlink" title="Future需要获取返回值，才能获取异常信息。"></a>Future需要获取返回值，才能获取异常信息。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5L</span>,<br>    TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>));<br>CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> b / a;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;,executorService).thenAccept(System.out::println);<br>   <br> <span class="hljs-comment">//如果不加 get()方法这一行，看不到异常信息</span><br> <span class="hljs-comment">//future.get();</span><br></code></pre></td></tr></table></figure><h4 id="尽量避免使用-get"><a href="#尽量避免使用-get" class="headerlink" title="尽量避免使用 get()"></a>尽量避免使用 get()</h4><p><code>CompletableFuture</code>的<code>get()</code>方法是阻塞的，尽量避免使用。如果必须要使用的话，需要添加超时时间，否则可能会导致主线程一直等待，无法执行其他任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">10_000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 获取异步任务的返回值，设置超时时间为 5 秒</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    System.out.println(result);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>    <span class="hljs-comment">// 处理异常</span><br>    e.printStackTrace();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码在调用 <code>get()</code> 时抛出了 <code>TimeoutException</code> 异常。这样我们就可以在异常处理中进行相应的操作，比如取消任务、重试任务、记录日志等。</p><h4 id="使用自定义线程池"><a href="#使用自定义线程池" class="headerlink" title="使用自定义线程池"></a>使用自定义线程池</h4><p><code>CompletableFuture</code> 默认使用<code>ForkJoinPool.commonPool()</code> 作为执行器，这个线程池是全局共享的，可能会被其他任务占用，导致性能下降或者饥饿。因此，建议使用自定义的线程池来执行 <code>CompletableFuture</code> 的异步任务，可以提高并发度和灵活性。</p><h4 id="正确进行异常处理"><a href="#正确进行异常处理" class="headerlink" title="正确进行异常处理"></a>正确进行异常处理</h4><p>使用 <code>CompletableFuture</code>的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。</p><p>下面是一些建议：</p><ul><li>使用 <code>whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</li><li>使用 <code>exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</li><li>使用 <code>handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</li><li>使用 <code>CompletableFuture.allOf</code> 方法可以组合多个 <code>CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复。</li></ul><h4 id="合理组合多个异步任务"><a href="#合理组合多个异步任务" class="headerlink" title="合理组合多个异步任务"></a>合理组合多个异步任务</h4><p>正确使用 <code>thenCompose()</code> 、 <code>thenCombine()</code> 、<code>acceptEither()</code>、<code>allOf()</code>、<code>anyOf() </code>等方法来组合多个异步任务，以满足实际业务的需求，提高程序执行效率。</p><p>实际使用中，我们还可以利用或者参考现成的异步任务编排框架，比如京东的 <a href="https://gitee.com/jd-platform-opensource/asyncTool">asyncTool</a> 。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thread</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2023/10/09/ThreadLocal/"/>
    <url>/2023/10/09/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h3><p>在处理多线程并发安全的问题中，我们最常使用的方法就是通过锁来控制多个不同线程对临界区的访问。</p><p>但无论是什么样的锁，乐观锁或者悲观锁，尽管<code>JDK</code> 在升级过程中对它们都有不同程度的优化，但在并发冲突的时候总是会对性能产生一定的影响。</p><p>而我们今天的主角 <code>ThreadLocal</code> 解决的正是<strong>彻底避免</strong>多线程之间产生的竞争问题。</p><p>从字面意思上看，<code>ThreadLocal</code> 可以解释为线程的局部变量，也就是说对于同一个 <code>ThreadLocal</code> 变量，每个线程访问的都是自己本地变量值，既然只有自己能够访问，那自然就避免了冲突。</p><p>所以说，<code>ThreadLocal</code> 相较于锁提供了一种与众不同的保证线程安全的方式，它不是在线程发生冲突时想办法解决冲突，而是彻底的避免了冲突的发生。</p><p>举一个现实生活当中的例子：</p><p>去商场购物时我们总会将购买的商品放到购物车中，并且商场会为每个人准备单独的购物车，如果所有人购买的东西都放到一个购物车，大家就会混淆各自购买的商品，最终结账也会出大问题。所以每个人都有属于自己的购物车，这样才不会各自混淆，<code>ThreadLocal</code> 的实现方式也和这个例子类似。</p><h3 id="ThreadLocal使用"><a href="#ThreadLocal使用" class="headerlink" title="ThreadLocal使用"></a>ThreadLocal使用</h3><p><code>ThreadLocal </code> 提供了一个 <code>withInitial()</code> 方法统一初始化所有线程的 <code>ThreadLocal</code> 的值，这里我们将 <code>thread1</code> 、<code>thread2</code> 和主线程的值都初始化为0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 创建一个 ThreadLocal 变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建两个线程并启动</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 在线程1中设置 ThreadLocal 变量的值</span><br>            THREAD_LOCAL.set(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 在线程1中获取 ThreadLocal 变量的值并打印</span><br>            System.out.println(<span class="hljs-string">&quot;Thread 1 - ThreadLocal Value: &quot;</span> + THREAD_LOCAL.get());<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 在线程2中设置 ThreadLocal 变量的值</span><br>            THREAD_LOCAL.set(<span class="hljs-number">2</span>);<br><br>            <span class="hljs-comment">// 在线程2中获取 ThreadLocal 变量的值并打印</span><br>            System.out.println(<span class="hljs-string">&quot;Thread 2 - ThreadLocal Value: &quot;</span> + THREAD_LOCAL.get());<br>        &#125;);<br><br>        <span class="hljs-comment">// 启动线程1和线程2</span><br>        thread1.start();<br>        thread2.start();<br><br>        <span class="hljs-comment">// 等待线程1和线程2完成</span><br>        thread1.join();<br>        thread2.join();<br><br>        <span class="hljs-comment">// 在主线程中获取 ThreadLocal 变量的值并打印</span><br>        System.out.println(<span class="hljs-string">&quot;Main Thread - ThreadLocal Value: &quot;</span> + THREAD_LOCAL.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">Thread 1 - ThreadLocal Value: 1<br>Thread 2 - ThreadLocal Value: 2<br>Main Thread - ThreadLocal Value: 0<br></code></pre></td></tr></table></figure><p>我们可以看到，<code>thread1</code> 和 <code>thread2</code> 设置的值互不影响，由于主线程没有重新设置值，所以取得初始化的值0。</p><h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p><code>ThreadLocal</code> 变量是如何做到只对当前线程可见的呢？我们先从 <code>ThreadLocal</code> 类当中最基本的 <code>get()</code> 方法说起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获得当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// ThreadLocalMap里保存着所有ThreadLocal变量</span><br>    <span class="hljs-comment">// 通过getMap(Thread t)方法可以发现 每个线程都有一个自己的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// ThreadLocalMap的key就是当前ThreadLocal的对象实例</span><br>        <span class="hljs-comment">// 多个ThreadLocal变量都是放在这个map中的</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-comment">// 这里取出来的值就是当前线程对这个ThreadLocal变量设置的值</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果map没有初始化，这里执行初始化的操作</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的ThreadLocalMap</span><br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，所谓的 <code>ThreadLocal</code> 变量就是保存在每个线程的 <code>ThreadLocalMap</code> 中的。这个 <code>map</code> 就是 <code>Thread</code> 对象中的 <code>threadLocals</code> 字段。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>我们可以得出结论，<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是 <code>ThreadLocalMap</code> 的封装，传递了变量值。</strong><code>ThrealLocal</code> 类中可以通过 <code>Thread.currentThread()</code> 获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个 <code>Thread</code> 中都具备一个 <code>ThreadLocalMap</code>，而 <code>ThreadLocalMap</code> 可以存储以 <code>ThreadLocal</code> 为 key ，Object 对象为 value 的键值对。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code> 内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p><p><code>ThreadLocal</code> 结构图如下所示：</p><p><img src="https://image.seeyourface.cn/migrate/image-20231009141659619.png" alt="image-20231009141659619"></p><h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p><code>ThreadLocal.ThreadLocalMap</code> 是一个比较特殊的 <code>Map</code> ，它的每个 <code>Entry</code> 的 <code>key</code> 都是一个弱引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br>    <span class="hljs-comment">// key是一个弱引用</span><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理。</p><p>这个 <code>value</code> 的引用链条如下：</p><p><img src="https://image.seeyourface.cn/migrate/ThreadLocalMap%E4%B8%ADvalue%E5%BC%95%E7%94%A8%E9%93%BE.jpg" alt="ThreadLocalMap中value引用链"></p><p>可以看到，只有当 <code>Thread</code> 被回收时，这个 <code>value</code> 才有被回收的机会，否则，只要线程不退出，<code>value</code> 总是会存在一个强引用。但是，要求每个 <code>Thread</code> 都会退出，是一个极其苛刻的要求，对于线程池来说，大部分线程会一直存在在系统的整个生命周期内，那样的话，就会造成 <code>value</code> 对象出现泄漏的可能。</p><p>如此一来，<code>ThreadLocalMap</code> 中就会出现 <code>key</code> 为 <code>null</code> 的 <code>Entry</code>。假如我们不做任何措施的话，<code>value</code> 永远无法被 <code>GC</code> 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用 <code>remove()</code> 方法。</p><p>以 <code>getEntry()</code> 方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-comment">// 如果这个key存在，直接返回结果</span><br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果没找到，就会尝试清理，也就是说如果你总是访问存在的key，清理流程永远进不来</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 整个e是entry ，也就是一个弱引用</span><br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">// 如果找到了，就返回</span><br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-comment">// 如果key为null，说明弱引用已经被回收了</span><br>        <span class="hljs-comment">// 那么就要在这里回收里面的value了</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 如果key不是要找的那个，那说明有hash冲突，这里是处理冲突，找下一个entry</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>真正用来回收value的是 <code>expungeStaleEntry()</code> 方法，在 <code>remove()</code> 和 <code>set()</code> 方法中，都会直接或者间接调用到这个方法进行 <code>value</code> 的清理：</p><p>从这里可以看到，<code>ThreadLocal</code> 为了避免内存泄露，也算是花了一番大心思。不仅使用了弱引用维护 <code>key</code>，还会在每个操作上检查 <code>key</code> 是否被回收，进而再回收 <code>value</code> 。</p><p>但是从中也可以看到，<code>ThreadLocal</code> 并不能100%保证不发生内存泄漏。</p><p>比如，很不幸的，你的 <code>get()</code> 方法总是访问固定几个一直存在的 <code>ThreadLocal</code> ，那么清理动作就不会执行，如果你没有机会调用 <code>set()</code> 和 <code>remove()</code> ，那么这个内存泄漏依然会发生。</p><p>因此，一个良好的习惯依然是：<strong>当你不需要这个 <code>ThreadLocal</code> 变量时，主动调用 <code>remove()</code>，这样对整个系统是有好处的</strong>。</p><h3 id="ThreadLocalMap中的Hash冲突处理"><a href="#ThreadLocalMap中的Hash冲突处理" class="headerlink" title="ThreadLocalMap中的Hash冲突处理"></a>ThreadLocalMap中的Hash冲突处理</h3><p><code>ThreadLocalMap</code> 作为一个 <code>HashMap</code> 和 <code>java.util.HashMap</code> 的实现是不同的。对于<code>java.util.HashMap</code> 使用的是拉链法来处理冲突：</p><p><img src="https://image.seeyourface.cn/migrate/%E6%8B%89%E9%93%BE%E6%B3%95.jpg" alt="拉链法"></p><p>但是，对于 <code>ThreadLocalMap</code>，它使用的是简单的线性探测法，如果发生了元素冲突，那么就使用下一个槽位存放：</p><p><img src="https://image.seeyourface.cn/migrate/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.jpg" alt="线性探测法"></p><p>整个 <code>set()</code> 方法过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">// 根据key的哈希值对数组长度取模找到一个位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 如果这个位置没有被占用，说明没有冲突，那就不需要循环，直接使用这个位置</span><br>    <span class="hljs-comment">// 如果发生冲突，那就一直循环往下找，直到找到一个可用的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-comment">// 循环体内，说明已经发生了冲突</span><br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">// 如果是对值进行重置，那么直接覆盖就好</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果key为null，说明原来的key被回收了，启动清理</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 一旦找到合适位置，就放入新的Entry</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>在实际开发过程中，我们可能会遇到这么一种场景。主线程开了一个子线程，但是我们希望在子线程中可以访问主线程中的 <code>ThreadLocal</code> 对象，也就是说有些数据需要进行父子线程间的传递。比如像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalExample</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个InheritableThreadLocal变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 在主线程中设置值</span><br>        inheritableThreadLocal.set(<span class="hljs-string">&quot;Main Thread Value&quot;</span>);<br><br>        <span class="hljs-comment">// 创建一个子线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">childThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 子线程可以访问父线程设置的值</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> inheritableThreadLocal.get();<br>            System.out.println(<span class="hljs-string">&quot;Child Thread Value: &quot;</span> + value);<br>        &#125;);<br><br>        <span class="hljs-comment">// 启动子线程</span><br>        childThread.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 等待子线程完成</span><br>            childThread.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">// 主线程仍然可以访问相同的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">mainThreadValue</span> <span class="hljs-operator">=</span> inheritableThreadLocal.get();<br>        System.out.println(<span class="hljs-string">&quot;Main Thread Value: &quot;</span> + mainThreadValue);<br><br>        <span class="hljs-comment">// 清除InheritableThreadLocal变量</span><br>        inheritableThreadLocal.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上述代码，可以得到结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">Child Thread Value: Main Thread Value<br>Main Thread Value: Main Thread Value<br></code></pre></td></tr></table></figure><p>可以看到，子线程可以访问到从父进程传递过来的一个数据。虽然 <code>InheritableThreadLocal</code> 看起来挺方便的，但是依然要注意以下几点：</p><ol><li>变量的传递是发生在线程创建的时候，如果不是新建线程，而是用了线程池里的线程，就不灵了。</li><li>变量的赋值就是从主线程的 <code>map</code> 复制到子线程，它们的 <code>value</code> 是同一个对象，如果这个对象本身不是线程安全的，那么就会有线程安全问题。</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有 <code>SimpleDateFormat</code> 和<code>Random</code> ）。</li><li>每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thread</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK源码系列-HashMap</title>
    <link href="/2023/09/27/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/"/>
    <url>/2023/09/27/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>HashMap</code>是Java程序员使用频率最高的用于映射(key-value键值对)处理的数据类型。</p><p>JDK1.8 之前 <code>HashMap</code> 是由 数组+链表 组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决<strong>哈希冲突</strong>而存在的（“拉链法”解决冲突）。 </p><p>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度<strong>大于等于阈值</strong>（默认为 8）（将链表转换成红黑树前会判断，如果当前<strong>数组的长度小于 64</strong>，那么会选择<strong>先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>HashMap</code>的优点是<strong>访问速度快</strong>，插入和删除操作也方便。一般来说，如果<code>HashMap</code>中的元素是均匀分布在数组中的，那么查询时间复杂度接近于O(1)；相反，那么查询的时间复杂度可能会增加，因为可能需要遍历数组中的链表或红黑树来找到对应的值。链表的查询时间复杂度是O(n)，红黑树的查询时间复杂度是O(logn)，其中n是链表或红黑树中的元素个数。因此，<code>HashMap</code>的查询时间复杂度最好是O(1)，最坏是O(n)。</p><p><code>HashMap</code>的缺点是不保证元素的顺序，不支持线程同步，也不能存储重复的键（key）。</p><p><code>HashMap</code>可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且，<code>HashMap</code>总是使用 2 的幂作为哈希表的大小。</p><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p>下图是<code>HashMap</code>的类结构关系图：</p><p>它继承了<code>AbstractMap</code>，<code>AbstractMap</code>实现了顶层接口Map中的大部分方法，只有一个抽象方法<code>entrySet()</code>需要自己实现。</p><p>实现了以下接口：</p><ul><li>Map：哈希表的顶级接口，定义了哈希表的基础操作方法，交给子类实现。</li><li>Cloneable：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li>Serializable：表明它可以进行序列化和反序列化操作，也就是即可以将<strong>对象序列化为字节流</strong>进行持久化存储或网络传输，也可以从<strong>字节流反序列化为对象</strong>，非常方便。</li></ul><p><img src="https://image.seeyourface.cn/migrate/image-20230927152729707.png" alt="image-20230927152729707"></p><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>从底层数据存储结构实现来讲，<code>HashMap</code>是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p><p><img src="https://image.seeyourface.cn/migrate/hashMap.png" alt="hashMap"></p><p>大家有没有想过：<code>HashMap</code>数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p><p>问题1：通过源码我们可以发现，<code>HashMap</code>的数据最终都保存在一个叫<code>Node&lt;K,V&gt;</code>的结构中。</p><p>什么！还有高手？？？</p><p><img src="https://image.seeyourface.cn/migrate/image-20230927170909332.png" alt="image-20230927170909332"></p><p><code>Node</code>是<code>HashMap</code>的一个内部类，实现了<code>Map.Entry</code>接口，本质是就是一个映射(键值对)。也就是上图中的长方形代表的结构。</p><p>问题2：哈希表为了解决冲突，可以采用的解决方法有开放地址法和链地址法，且<code>Java</code>中<code>HashMap</code>采用的就是链地址法。简单来说就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被<code>Hash</code>后，得到数组下标，把数据放在对应下标元素的链表上。</p><h3 id="HashMap是如何保证高性能的？"><a href="#HashMap是如何保证高性能的？" class="headerlink" title="HashMap是如何保证高性能的？"></a>HashMap是如何保证高性能的？</h3><p>前面我们说过，理想情况下<code>HashMap</code>的查询时间复杂度是O(1)，但是随着加入的对象越来越多，数组中的链表将越来越长，将严重影响HashMap的性能。</p><p>那么如何降低哈希冲突的概率呢，可以通过控制变量法进行分析：我们知道一个对象存放的位置取决于<strong>散列函数</strong>和<strong>数组容量</strong>。</p><ul><li>我们将哈希桶的容量固定，Hash算法越好，对象在哈希桶中的位置分布就越均匀，也就是哈希冲突的概率越低。</li><li>对于同一个Hash算法，哈希桶越大，对象在哈希桶中冲突的概率也越低。</li></ul><p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的Hash算法减少Hash碰撞。</p><p>而<code>HashMap</code>正是通过好的Hash算法和哈希桶的扩容机制来平衡空间与时间之间的关系。</p><h3 id="什么时候触发扩容机制"><a href="#什么时候触发扩容机制" class="headerlink" title="什么时候触发扩容机制"></a>什么时候触发扩容机制</h3><p>在介绍Hash算法和扩容流程之前，我想先提一下 <code>HashMap</code> 在什么时候会触发扩容机制。</p><p>通过查看<code>HashMap</code>源码可知，扩容机制是通过 <code>resize()</code> 方法实现的，而我们在往 <code>HashMap</code> 中放入对象时，满足条件 <code>(++size &gt; threshold)</code> 时会调用 <code>resize()</code> 方法进行扩容，<code>threshold</code> 在源码中给出的解释是：在给定 <code>Load factor</code> 和 <code>capacity</code> (数组容量)下所允许的最大元素数目，即 <code>threshold = capacity * load factor </code> ，默认的负载因子(<code>load factor</code>)是0.75。</p><p>如果使用无参构造器创建 <code>HashMap</code> 默认容量为 <code>1 &gt;&gt; 4</code> 即16，所以当添加第13个对象时就会触发<code>HashMap</code>的扩容机制。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230928134857618.png" alt="image-20230928134857618"></p><p>也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多，超过这个数目就重新resize(扩容)。</p><p>默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以适当降低负载因子 <code>loadFactor</code> 的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 <code>loadFactor</code> 的值，这个值<strong>可以大于</strong>1。</p><h3 id="为什么HashMap的容量始终为2的N次幂"><a href="#为什么HashMap的容量始终为2的N次幂" class="headerlink" title="为什么HashMap的容量始终为2的N次幂"></a>为什么HashMap的容量始终为2的N次幂</h3><p><code>HashMap</code>扩容后的容量是之前容量的两倍。并且在 <code>HashMap</code> 中，哈希桶数组table的容量大小始终为2的n次方(一定是合数)。这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，例如 <code>Hashtable</code> 初始化桶大小为11，就是桶大小设计为素数的应用（<code>Hashtable</code>扩容后不能保证还是素数）。</p><p><code>HashMap</code> 采用这种非常规设计，主要是为了在<strong>取模和扩容</strong>时做优化。</p><p>如下图在容量N为 <code>2 ^ 3 = 8</code> 的 <code>HashMap</code> 中，我们举个例子来证明素数的冲突概率要小于合数：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230928145903047.png" alt="image-20230928145903047"></p><p>首先，二进制中用位运算来执行取模操作，只适用于模数为<strong>2的倍数</strong>的情况，这里解释了<code>HashMap</code>用2的N次幂做容量的第一个原因。</p><p>K &#x3D; 28 对 N 取模的运算 28 % N 可以转化为位运算的 <code>1 1100 &amp; (N - 1)</code> ，上面的例子结果就是4；再对另一个元素 K &#x3D; 20 做同样运算，我们能得到该元素最终存储的索引也是4。</p><p>通过上图我们发现，即使 28 和 20 转化为二进制后的第四位（从右往左数）不相同，但仍然哈希到了同一个位置，也就是说这时候元素K第四位就根本不参与哈希运算，这就无法完整地反映元素 K 的特性，增大了导致冲突的几率。</p><p>取其他合数时，都会不同程度的导致c的某些位”失效”，从而在一些常见应用中导致冲突。</p><p>但是取质数，基本可以保证K的每一位都参与哈希运算，从而在常见应用中减小冲突几率（并不能完全避免）。</p><p>所以为了减少冲突，<code>HashMap</code> 定位哈希桶索引位置时，也加入了<strong>高位参与运算</strong>的过程。</p><h3 id="链表和红黑树的相互转化"><a href="#链表和红黑树的相互转化" class="headerlink" title="链表和红黑树的相互转化"></a>链表和红黑树的相互转化</h3><p>即使负载因子和 <code>Hash</code> 算法设计的再合理，也无法避免会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 <code>HashMap</code> 的性能。</p><p>于是，在 <code>JDK1.8</code> 版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长超过 <code>TREEIFY_THRESHOLD</code>（默认为8）时，会进一步判断数组容量，<strong>如果数组容量小于 <code>MIN_TREEIFY_CAPACITY</code> (默认为64)，会优先对数组进行扩容</strong>，然后将数据重新散列到新的哈希桶中；如果数组容量大于等于64，就会将链表转换为红黑树，利用红黑树快速增删改查的特点提高 <code>HashMap</code> 的性能。</p><p>在扩容过程中，如果原来数组中红黑树的节点经重新散列后<strong>小于等于</strong> <code>UNTREEIFY_THRESHOLD</code> (默认为6)时，红黑树会重新退化为链表。</p><p><img src="https://image.seeyourface.cn/migrate/img-20230928153456.png" alt="img-20230928153456"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认构造函数。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br>&#125;<br><br><span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>   <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>   putMapEntries(m, <span class="hljs-literal">false</span>);<span class="hljs-comment">//下面会分析到这个方法</span><br>&#125;<br><br><span class="hljs-comment">// 指定“容量大小”的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>   <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">// 指定“容量大小”和“负载因子”的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>   <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>   <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>       initialCapacity = MAXIMUM_CAPACITY;<br>   <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>   <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>   <span class="hljs-comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span><br>   <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>值得注意的是：上述四个构造方法中，都初始化了负载因子 <code>loadFactor</code>，由于<code>HashMap</code>中没有 <code>capacity</code> 这样的字段，即使指定了初始化容量 <code>initialCapacity</code> ，也只是通过 <code>tableSizeFor</code> 将其扩容到与 <code>initialCapacity</code> <strong>最接近的2的幂次方大小</strong>，然后暂时赋值给 <code>threshold</code> ，后续通过 <code>resize</code> 方法将 <code>threshold</code> 赋值给 <code>newCap</code> 进行 <code>table</code> 的初始化。</p></blockquote><h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor()"></a>tableSizeFor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns a power of two size for the given target capacity.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对任意十进制数转换为2的整数幂，结果是这个数本身的<strong>最高有效位的前一位变成1，最高有效位以及其后的位都变为0</strong>。</p><p>核心思想是，先<strong>将最高有效位以及其后的位都变为1</strong>，最后再+1，就进位到前一位变成1，其后所有的满2变0。所以关键是<strong>如何将最高有效位后面都变为1</strong>。</p><ul><li>右移一位，再或运算，最高有效位就有两位变为1</li><li>右移两位，再或运算，最高有效位就有四位变为1</li><li>右移16位再或运算，保证32位的int类型整数最高有效位之后的位都能变为1。</li><li>最后加1就能达到想要的效果。</li></ul><p>开始移位前先将容量先减1，是为了避免给定容量已经是8, 16这样已经是2的幂数时，不减一直接移位会导致得到的结果比预期大。比如预期16得到应该是16，直接移位的话会得到32。</p><h4 id="putMapEntries"><a href="#putMapEntries" class="headerlink" title="putMapEntries()"></a>putMapEntries()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.size();<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 未初始化，s为m的实际元素个数，ft = s/loadFactor =&gt; s=ft*loadFactor, 跟我们前面提到的</span><br><span class="hljs-comment">             * 阈值=容量*负载因子 是不是很像，ft指的是要添加s个元素所需的最小的容量。</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> ((ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY) ?<br>                    (<span class="hljs-type">int</span>)ft : MAXIMUM_CAPACITY);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 根据构造函数可知，table未初始化，threshold实际上是存放的初始化容量，如果添加s个元素所</span><br><span class="hljs-comment">             * 需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。</span><br><span class="hljs-comment">             * 注意这里不是初始化阈值</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : m.entrySet()) &#123;<br>            <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> e.getValue();<br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h4><p>无论是增加、删除还是查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过 <code>HashMap</code> 的数据结构是数组和链表的结合，所以我们当然希望这个 <code>HashMap</code> 里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。</p><p>hash方法的离散性能直接决定了 <code>HashMap</code> 定位数组索引位置效率，我们看看源码是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK1.8</span><br><span class="hljs-comment">// 首先取得hashCode的值 h</span><br><span class="hljs-comment">// h 与 h 无符号向右位移16位做异或运算，目的是让高位参与运算，而异或运算保证0 1出现的概率相等</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br><span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">// JDK 1.7</span><br><span class="hljs-comment">// 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="确定元素在哈希桶中的位置"><a href="#确定元素在哈希桶中的位置" class="headerlink" title="确定元素在哈希桶中的位置"></a>确定元素在哈希桶中的位置</h4><p>对于任意给定的对象，只要它的 <code>hashCode()</code> 返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。</p><p>我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。</p><p>但是，模运算的消耗还是比较大的，在 <code>HashMap</code> 中是这样做的：<code>HashMap</code> 底层数组的长度总是2的n次方，这是 <code>HashMap</code> 在速度上的优化。<strong>当length总是2的n次方时</strong>，<code>h &amp; (length-1)</code> 运算<strong>等价于</strong>对 <code>length</code> 取模，也就是 <code>h % length</code>，但是**&amp;比%具有更高的效率**。</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><p><code>HashMap</code> 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对 putVal 方法添加元素的分析如下：</strong></p><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ol><p><img src="https://image.seeyourface.cn/migrate/image-20230928175621083.png" alt="image-20230928175621083"></p><p>画的有点乱，大家将就看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>        <span class="hljs-comment">// 判断插入的是否是红黑树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 不是红黑树节点则说明为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h4><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。resize方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span><br>    <span class="hljs-comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ? (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把旧哈希表中的每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 只有一个节点，直接计算元素新的位置即可</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 将红黑树拆分成2棵子树，拆分后的子树节点数小于等于6，则将树转化成链表</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 定义低位链表的头节点和尾节点</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-comment">// 定义高位链表的头节点和尾节点</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 判断原hash值有效位的高一位是0，连接到低位链表，并保持元素的相对顺序不变，节省对新数组长度重新取模的时间</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 判断原hash值有效位的高一位是0，连接到高位链表，并保持元素的相对顺序不变，节省对新数组长度重新取模的时间  </span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 低位链表的头节点连接到原索引位置的bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 高位链表的头节点连接到原索引位置 + oldCap的bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的自增主键一定是连续的吗？</title>
    <link href="/2023/09/26/MySQL%E7%9A%84%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F/"/>
    <url>/2023/09/26/MySQL%E7%9A%84%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MySQL自增主键的作用是在自增列上定义一个主键，让主键的值由数据库系统自动分配，而不需要用户输入。这样可以避免主键重复或缺失，提高插入数据的效率，保持主键索引的递增顺序，减少<em>索引的碎片化</em>。</p><blockquote><p>索引的碎片化是指索引中的数据在物理存储上不连续，而是分散在磁盘上的不同位置。这样会导致查询需要更多的磁盘I&#x2F;O操作，降低查询性能和资源利用率。</p></blockquote><p>但实际上，MySQL的自增主键并不能保证一定是连续自增的。</p><p>先创建一张表，其中id为主键且自增，字段a创建了一个唯一索引。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926112247507.png" alt="image-20230926112247507"></p><h3 id="自增值保存在哪？"><a href="#自增值保存在哪？" class="headerlink" title="自增值保存在哪？"></a>自增值保存在哪？</h3><p>执行<code>insert test_incr(a, b) values(1,1);</code>插入一条数据；再执行<code>show create table test_incr;</code>命令查看表的结构。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926113445991.png" alt="image-20230926113445991"></p><p>上述表的结构定义存放在后缀名为 <code>.frm</code> 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 <code>.frm</code> 文件：</p><p><img src="https://image.seeyourface.cn/migrate/img-20230926113940.png" alt="img-20230926113940"></p><p>从上述表结构可以看到，表定义里面出现了一个 <code>AUTO_INCREMENT=2</code>，表示下一次插入数据时，如果需要自动生成自增值，会生成 id &#x3D; 2。</p><p>但需要注意的是，自增值并不会保存在这个表结构也就是 <code>.frm</code> 文件中，不同的引擎对于自增值的保存策略不同：</p><ol><li>MyISAM 引擎的自增值保存在数据文件中</li><li>InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 <code>max(id)</code>，然后将 <code>max(id)+1</code> 作为这个表当前的自增值。</li></ol><p>举个例子：现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT&#x3D;2对吧。这时候，我们删除 id&#x3D;1 的行，AUTO_INCREMENT 还是 2。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926114409154.png" alt="image-20230926114409154"></p><p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿也就是说，MySQL 重启可能会修改一个表的 <strong>AUTO_INCREMENT</strong> 的值。</p><p>我们趁MySQL不注意，使用<code>kill -9 pid</code>杀掉MySQL服务（主打的就是一个不讲武德），然后重启服务，再次执行<code>show create table test_incr;</code></p><p><img src="https://image.seeyourface.cn/migrate/image-20230926140109271.png" alt="image-20230926140109271"></p><p>此时我们发现<strong>AUTO_INCREMENT</strong>没有显示，是因为默认等于1不会展示。</p><p>以上测试基于MySQL数据库的<strong>5.7.36</strong>版本，存储引擎为<strong>INNODB</strong>。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926140417057.png" alt="image-20230926140417057"></p><p>实际上，到了 MySQL 8.0 版本后，自增值的变更记录被放在了 <strong>redo log</strong> 中，提供了自增值持久化的能力，也就是实现了“如果发生重启，表的自增值可以根据 redo  log 恢复为 MySQL 重启前的值”。</p><p>也就是对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。</p><p>理解了 MySQL 自增值到底保存在哪里以后，再来看看自增值的修改机制，并为大家介绍一些自增值不连续的场景，以下结论基于MySQL8，存储引擎INNODB。</p><h3 id="自增列指定值"><a href="#自增列指定值" class="headerlink" title="自增列指定值"></a>自增列指定值</h3><p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ul><li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li><li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li></ul><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 <code>insert_num</code>，当前的自增值是 <code>autoIncrement_num</code>：</p><ul><li>如果 <code>insert_num &lt; autoIncrement_num</code>，那么这个表的自增值不变</li><li>如果 <code>insert_num &gt;= autoIncrement_num</code>，就需要把当前自增值修改为新的自增值</li></ul><p>也就是说，如果插入的 id 是 100，当前的自增值是 90，<code>insert_num &gt;= autoIncrement_num</code>，那么自增值就会被修改为新的自增值即 101…</p><p>一定如此吗？</p><p>凡是没有绝对~~~</p><p>MySQL中是通过<code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 这两个参数来实现主键自增的，这俩分别用来表示自增的初始值和步长，默认值都是 1。</p><p>所以，上面的例子中生成新的自增值的步骤实际是这样的：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 100  的值，作为新的自增值。</p><p>也就是说，这种情况下，当步长不等于1时，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。</p><p>更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的。</p><h3 id="唯一键冲突"><a href="#唯一键冲突" class="headerlink" title="唯一键冲突"></a>唯一键冲突</h3><p>我们之前往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT&#x3D; 2。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926152320949.png" alt="image-20230926152320949"></p><p>这时我再执行一条插入 <code>(null,1,1)</code> 的命令，很显然会报错 <code>Duplicate entry</code>，因为我们设置了一个唯一索引字段 <code>a</code>：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926152525247.png" alt="image-20230926152525247"></p><p>但是我们可以发现，虽然插入失败了，AUTO_INCREMENT的值从2变为了3！</p><p>具体原因来分析下这个 insert 语句的执行流程：</p><ol><li>执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);</li><li>InnoDB 发现用户没有指定自增 id 的值，则获取表 <code>test_pk</code> 当前的自增值 2；</li><li>将传入的记录改成 (2,1,1);</li><li>将表的自增值改成 3；</li><li>继续执行插入数据操作，由于已经存在 a&#x3D;1 的记录，所以报 Duplicate key error，语句返回。</li></ol><p>可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。</p><p>这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id &#x3D; 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。</p><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><p>现在我们表里有一行 <code>(1,1,1)</code> 的记录，并且AUTO_INCREMENT &#x3D; 3：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926153207589.png" alt="image-20230926153207589"></p><p>然后我们手动开启事务，插入一条(null,2,2)的数据，再回滚。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926153412078.png" alt="image-20230926153412078"></p><p>显然，我们执行了插入语句，但是回滚了事务，所以数据库中并没有刚才的(null,2,2)数据。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926153917766.png" alt="image-20230926153917766"></p><p>但是我们可以发现自增值并没有同样发生回滚！如上图所示，自增值仍然固执地从 3 增加到了 4。</p><p>如果这时候我们再去插入一条数据（null, 2, 2）的时候，主键 id 就会被自动赋为 4 了：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926154213388.png" alt="image-20230926154213388"></p><p>所以，当出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去，回退回去的话不就不会发生自增 id 不连续了吗？这又是为什么呢？</p><p>其实，这么做的主要原因是为了提高性能。</p><p>我们可以假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？</p><p>现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后按请求顺序申请，对吧。</p><ol><li>假设事务 A 申请到了 id &#x3D; 1， 事务 B 申请到 id&#x3D;2，那么这时候表 t 的自增值是3，之后继续执行。</li><li>事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id &#x3D; 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id &#x3D; 2 的行，而当前的自增 id 值是 1。</li><li>接下来，继续执行的其他事务就会申请到 id&#x3D;2。这时，就会出现插入语句报错“主键冲突”。</li></ol><p><img src="https://image.seeyourface.cn/migrate/img_20230926155314.png" alt="img_20230926155314"></p><p>有两种方法可以解决这个主键冲突：</p><ol><li>每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id</li><li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id</li></ol><p>很显然，上述两个方法的成本都比较高，会导致性能问题。而原因就是我们假设的这个 “允许自增 id 回退”。</p><p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但<strong>不保证是连续的</strong>。</p><h3 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h3><p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p><ol><li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li><li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li><li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li><li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li></ol><p>注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！因为这类语句在申请自增 id 的时候，根据value的数量是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p><p>而对于 <code>insert … select</code>、<code>replace … select</code> 和 <code>load data</code> 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种<strong>批量申请</strong>的策略，毕竟一个一个申请的话实在太慢了。</p><p>举个例子，假设我们现在这个表有下面这些数据：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926162829910.png" alt="image-20230926162829910"></p><p>创建一张和当前表 <code>test_incr</code> 有相同结构定义的表 <code>test_incr2</code>：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926163210736.png" alt="image-20230926163210736"></p><p>然后使用 <code>insert...select</code> 往 <code>teset_incr2</code> 表中批量插入数据：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926163423686.png" alt="image-20230926163423686"></p><p>可以看到，成功导入了数据。</p><p>再来看下 <code>test_pk2</code> 的自增值是多少：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926163515786.png" alt="image-20230926163515786"></p><p>如上分析一致，是 8 而不是 6。</p><p>具体来说，<code>insert…select</code> 实际上往表中插入了 5 行数据 （1,1）（2,2）（3,3）（4,4）（5,5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：</p><ul><li>第一次申请到了一个 id：id&#x3D;1</li><li>第二次被分配了两个 id：id&#x3D;2 和 id&#x3D;3</li><li>第三次被分配到了 4 个 id：id&#x3D;4、id &#x3D; 5、id &#x3D; 6、id&#x3D;7</li></ul><p>由于这条语句实际只用上了 5 个 id，所以 id&#x3D;6 和 id&#x3D;7 就被浪费掉了。之后，再执行 <code>insert into test_incr2 values(null,6,6)</code>，实际上插入的数据就是（8,6,6)：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230926163809960.png" alt="image-20230926163809960"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下自增值不连续的四个场景：</p><ol><li>自增初始值和自增步长设置不为 1。</li><li>唯一键冲突。</li><li>事务回滚。</li><li>批量插入（如 <code>insert...select</code> 语句）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP缓存</title>
    <link href="/2023/09/25/HTTP%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/25/HTTP%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="为什么要使用缓存？"><a href="#为什么要使用缓存？" class="headerlink" title="为什么要使用缓存？"></a>为什么要使用缓存？</h4><p>HTTP(超文本传输协议)是一种无状态的应用程序级请求&#x2F;响应协议，使用可扩展语义和自描述消息与基于网络的超文本信息系统进行灵活的交互。对于现代互联网来说存在着大量的静态文件例如HTML、CSS和图片等资源，这些资源在后续的请求中不会发生变更。我们可以缓存存储可缓存的响应，以减少未来等效请求的响应时间和网络带宽消耗。</p><p>HTTP <strong>缓存的目标</strong>是通过重用先前的响应消息来满足当前请求，每次缓存重用新响应时，新响应都可以减少延迟和网络开销，从而显着提高性能。</p><h3 id="缓存操作概述"><a href="#缓存操作概述" class="headerlink" title="缓存操作概述"></a>缓存操作概述</h3><h4 id="缓存需要解决的主要问题是什么？"><a href="#缓存需要解决的主要问题是什么？" class="headerlink" title="缓存需要解决的主要问题是什么？"></a>缓存需要解决的主要问题是什么？</h4><p>虽然缓存是HTTP的可选功能，但我们可以假设重用缓存的响应是有效的，并且当没有要求或本地配置阻止对响应进行缓存时，这种重用是<strong>默认行为</strong>。也就是说HTTP的缓存默认是开启的。因此，<strong>HTTP 缓存实现的重点是防止缓存存储不可重用的响应或不适当地重用已存储的响应</strong>，而不是强制缓存存储和重用特定响应。</p><h4 id="本地缓存存储格式"><a href="#本地缓存存储格式" class="headerlink" title="本地缓存存储格式"></a>本地缓存存储格式</h4><p>缓存在本地是以 【请求-响应】 的key&#x2F;value键值对的形式存储的。</p><p>缓存键（key）是缓存用来选择响应的信息，至少由请求方法和用于检索存储的响应的目标 URL 组成，该方法确定在什么情况下（GET&#x2F;POST等）可以使用该响应来满足后续请求。然而，目前许多常用的 HTTP 缓存<strong>仅缓存 GET</strong> 响应，因此仅使用 URL 作为缓存键。</p><h5 id="使用Vary标头字段计算缓存键"><a href="#使用Vary标头字段计算缓存键" class="headerlink" title="使用Vary标头字段计算缓存键"></a>使用Vary标头字段计算缓存键</h5><p><strong>注意！！！</strong></p><p>虽然区分响应的方式本质上是基于它们的 URL。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230925230408064.png" alt="image-20230925230408064"></p><p>但是响应的内容并不总是相同的，即使它们具有相同的 URL。例如在执行内容协商时，来自服务器的响应可能取决于 <code>Accept</code>、<code>Accept-Language</code> 和 <code>Accept-Encoding</code> 请求标头的值。</p><p>打个比方：对于带有 <code>Accept-Language: en</code> 标头并已缓存的英语内容，不希望再对具有 <code>Accept-Language: ja 请求标头的请求重用该缓存响应。在这种情况下，可以通过在 </code>Vary<code> 标头的值中添加“</code>Accept-Language&#96;”，根据语言单独缓存响应。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Language<br></code></pre></td></tr></table></figure><p>当缓存收到可由存储响应满足的请求并且该本地存储的响应包含 Vary 标头字段时，缓存<strong>不允许</strong>在没有重新验证的情况下使用该存储的响应，除非该 Vary 字段值指定的所有呈现的请求标头字段都与原始请求中的字段匹配。这会导致缓存基于响应 URL 和 <code>Accept-Language</code>请求标头的组合进行键控——而不是仅仅基于响应 URL。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230925230553189.png" alt="image-20230925230553189"></p><p>同时，Vary标头字段值包含 “*” 的存储响应将<strong>始终无法匹配</strong>。</p><h4 id="哪些响应能被缓存？"><a href="#哪些响应能被缓存？" class="headerlink" title="哪些响应能被缓存？"></a>哪些响应能被缓存？</h4><p>并不是所有响应都能被缓存存储，响应中存在 no-store 缓存指令将不会被缓存。</p><p>最常见的是缓存请求成功的结果：即对 GET 请求200（OK）的响应，其中包含目标资源的表示。</p><p>然而，也可以存储重定向、否定结果（404 未找到）、不完整的结果（206 部分内容）、以及对 GET 以外的方法的响应如果该方法的定义允许此类缓存并定义了适合用作缓存键的内容。</p><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><p><a href="https://httpwg.org/specs/rfc9111.html#calculating.freshness.lifetime">RFC 9111 HTTP Caching</a> 标准定义了两种不同的缓存：<strong>私有缓存和共享缓存</strong>。</p><h4 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h4><p>私有缓存是与特定客户端相绑定的缓存——通常是指浏览器缓存。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。</p><p>如果响应包含个性化内容并且你只想将响应存储在私有缓存中，则必须指定 <code>private</code> 指令。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>private<br></code></pre></td></tr></table></figure><p>但是如果响应具有 <code>Authorization</code> 标头，则不能将其存储在私有缓存（或共享缓存，除非 Cache-Control 指定的是 <code>public</code>）中。</p><blockquote><p>A cache <em>MUST NOT</em> store a response to a request unless if the cache is shared: the Authorization header field is not present in the request or a response directive is present that explicitly allows shared caching;</p></blockquote><h4 id="共享缓存"><a href="#共享缓存" class="headerlink" title="共享缓存"></a>共享缓存</h4><p>共享缓存位于客户端和服务器之间，可以存储能在用户之间<strong>共享</strong>的响应。共享缓存可以进一步细分为代理缓存和托管缓存。</p><h3 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h3><p><a href="https://httpwg.org/specs/rfc9111.html#calculating.freshness.lifetime">RFC 9111 HTTP Caching</a> 规范中提到，由于源服务器并不总是提供显式过期时间，因此当未指定显式时间时，缓存<em>可以</em>分配启发式过期时间，并采用使用其他字段值（例如上次修改时间）的算法来估计合理的过期时间。该规范没有提供具体的算法，但它确实对其结果施加了最坏情况的限制。</p><p>当存储的响应中存在显式过期时间(例如<code>Cache-Control</code>)时，缓存<strong>不得</strong>使用启发式方法来确定新鲜度。也就是说<strong>启发式缓存只适用于存储响应中没有显式给出过期时间的情况</strong>。</p><p>例如，我们通过请求获取到以下响应，内容最后一次更新是在 1 年前。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 26 Sep 2022 22:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 26 Sep 2021 22:22:22 GMT<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p>通过响应我们可以推测整整一年没有更新的内容在那之后的一段时间内也将不会更新。因此，客户端决定存储此响应（尽管缺少 <code>max-age</code>）并重用它一段时间。复用多长时间取决于实现，但规范建议存储<strong>不超过自该修改时间以来至今的一部分</strong>。这个值在规范中推荐为10%，所以上面的例子中重用的时间不超过0.1年。</p><p>因此，如果源服务器希望阻止缓存，则鼓励它们发送显式指令（例如，<code>Cache-Control：no-cache</code>）</p><blockquote><p>Since origin servers do not always provide explicit expiration times, a cache <em>MAY</em> assign a heuristic expiration time when an explicit time is not specified, employing algorithms that use other field values (such as the Last-Modified time) to estimate a plausible expiration time. This specification does not provide specific algorithms, but it does impose worst-case constraints on their results.</p><p>A cache <em>MUST NOT</em> use heuristics to determine freshness when an explicit expiration time is present in the stored response. Because of the requirements in Section 3), heuristics can only be used on responses without explicit freshness whose status codes are defined as heuristically cacheable (e.g., see Section 15.1 of HTTP) and on responses without explicit freshness that have been marked as explicitly cacheable (e.g., with a public response directive).</p><p>Note that in previous specifications, heuristically cacheable response status codes were called “cacheable by default”.</p><p>If the response has a Last-Modified header field of HTTP, caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.</p></blockquote><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>命中强制缓存时，客户端不会再请求服务器，直接从重用缓存的响应，并返回HTTP状态码为200。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230927225454971.png" alt="image-20230927225454971"></p><p>强制缓存由响应标头中的<code>Expries</code>、<code>Cache-Control</code> 和 <code>Pragma</code>来控制：</p><ul><li>Expires：在 HTTP&#x2F;1.0 中，缓存的有效期是通过 <code>Expires</code> 标头来指定的。<code>Expires</code> 标头使用明确的时间而不是通过指定经过的时间来指定缓存的生命周期。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Tue, 28 Feb 2022 22:22:22 GMT<br></code></pre></td></tr></table></figure><p>这种方式存在一些问题，例如时间格式难以解析，并且客户端可能通过故意偏移系统时钟来诱发问题。</p><ul><li>Cache-Control：由于Expires可能导致的问题，在 HTTP&#x2F;1.1 中引入了<code>Cache-Control</code> 标头，它采用了 <code>max-age</code>——即用于指定经过的时间，这是一个相对时间，是自响应生成以来经过的时间。如果 <code>Expires</code> 和 <code>Cache-Control: max-age</code> 都可用，则将 <code>max-age</code> 定义为首选。因此，由于 HTTP&#x2F;1.1 已被广泛使用，无需特地提供 <code>Expires</code>。<ul><li>no-store： 禁用缓存，表明服务器希望<strong>永远都不要在客户端存储资源</strong>，总是去原始服务器去获取最新资源。</li><li>no-cache：可以在客户端存储资源，但<strong>每次都必须去服务端做新鲜度校验</strong>。</li><li>private&#x2F;public：private指的单个用户，public可以被任何中间人、CDN等缓存</li><li>max-age&#x3D;：max-age是距离请求发起的时间的秒数</li><li>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</li></ul></li><li>Pragma：<code>Pragma</code>请求标头字段是为 HTTP&#x2F;1.0 缓存定义的，以便客户端可以指定“无缓存”的请求（因为Cache-Control直到HTTP&#x2F;1.1才被定义）。然而，对 <code>Cache-Control</code> 的支持现在已经很广泛了，因此，<em>RFC 9111 - HTTP Caching</em>规范不赞成使用 Pragma。</li></ul><h4 id="强制缓存存储的位置"><a href="#强制缓存存储的位置" class="headerlink" title="强制缓存存储的位置"></a>强制缓存存储的位置</h4><table><thead><tr><th>状态</th><th>Network - Size</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>from memory cache</td><td>不请求网络资源，资源在内存，一般是脚本、字体、图片，浏览器关闭，数据将被释放</td></tr><tr><td>200</td><td>from disk cache</td><td>请求网络资源，资源在磁盘，一般是CSS等，关闭数据还在</td></tr><tr><td>200</td><td>资源大小</td><td>从服务器下载最新资源</td></tr><tr><td>304</td><td>报文大小</td><td>请求服务端发现资源未更新，使用本地资源，不从服务器携带完整响应</td></tr></tbody></table><p>比如下图返回的响应Size字段中的内容：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230927233159423.png" alt="image-20230927233159423"></p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>客户端向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源，由于此响应仅表示“没有变化”，因此没有响应主体——只有一个状态码——因此传输大小非常小。</p><p>协商缓存，响应头中有两对字段配合使用标记规则。</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified &#x2F; If-Modified-Since"></a>Last-Modified &#x2F; If-Modified-Since</h4><p>以下响应在 22:22:22 生成，<code>max-age</code> 为 1 小时，因此你知道它在 23:22:22 之前是有效的。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p>到 23:22:22 时，响应会过时并且不能重用缓存。因此，下面的请求显示客户端发送带有 <code>If-Modified-Since</code> 请求标头的请求，以询问服务器自指定时间以来是否有任何的改变。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br></code></pre></td></tr></table></figure><p>如果内容自指定时间以来没有更改，服务器将响应 <code>304 Not Modified</code>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">304</span> Not Modified<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 23:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br></code></pre></td></tr></table></figure><p>收到该响应后，客户端将存储的过期响应恢复为有效的，并可以在剩余的 1 小时内重复使用它。</p><p>这种方法同样存在一些问题：例如，时间格式复杂且难以解析，分布式服务器难以同步文件更新时间。</p><p>所以为了解决这些问题，<code>ETag</code> 响应标头被标准化作为替代方案。</p><h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a>ETag&#x2F;If-None-Match</h4><p><code>ETag</code> 响应标头的值是服务器生成的任意值。服务器对于生成值没有任何限制，因此服务器可以根据他们选择的任何方式自由设置值——例如主体内容的哈希或版本号，只需要能唯一标识这个资源即可。</p><p>举个例子，如果 <code>ETag</code> 标头使用了 hash 值，<code>index.html</code> 资源的 hash 值是 <code>deadbeef</code>，响应如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;deadbeef&quot;<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p>如果该响应是陈旧的，则客户端获取缓存响应的 <code>ETag</code> 响应标头的值，并将其放入 <code>If-None-Match</code> 请求标头中，以询问服务器资源是否已被修改：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;deadbeef&quot;<br></code></pre></td></tr></table></figure><p>如果服务器为请求的资源确定的 <code>ETag</code> 标头的值与请求中的 <code>If-None-Match</code> 值相同，则服务器将返回 <code>304 Not Modified</code>。</p><p>但是，如果服务器确定请求的资源现在应该具有不同的 <code>ETag</code> 值，则服务器将其改为 <code>200 OK</code> 和资源的最新版本进行响应。</p><p>那是不是有了<code>ETag</code>之后就没必要使用<code>Last-Modified</code>呢？答案是否定的。</p><p>引用MDN开发规范中的内容：</p><blockquote><p><strong>备注：</strong> 在评估如何使用 <code>ETag</code> 和 <code>Last-Modified</code> 时，请考虑以下几点：在缓存重新验证期间，如果 <code>ETag</code> 和 <code>Last-Modified</code> 都存在，则 <code>ETag</code> 优先。因此，如果你只考虑缓存，你可能会认为 <code>Last-Modified</code> 是不必要的。然而，<code>Last-Modified</code> 不仅仅对缓存有用；相反，它是一个标准的 HTTP 标头，内容管理 (CMS) 系统也使用它来显示上次修改时间，由爬虫调整爬取频率，以及用于其他各种目的。所以考虑到整个 HTTP 生态系统，最好同时提供 <code>ETag</code> 和 <code>Last-Modified</code>。</p></blockquote><h3 id="强制重新验证"><a href="#强制重新验证" class="headerlink" title="强制重新验证"></a>强制重新验证</h3><p>如果你是个喜新厌旧的人，不希望重复使用响应，而是希望始终从服务器获取最新内容，HTTP提供了<code>no-cache</code>指令强制验证。</p><p>通过在响应中添加 <code>Cache-Control: no-cache</code> 以及 <code>Last-Modified</code> 和 <code>ETag</code>——如下所示——如果请求的资源已更新，客户端将收到 <code>200 OK</code> 响应，否则，如果请求的资源尚未更新，则会收到 <code>304 Not Modified</code> 响应。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>deadbeef<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p><code>max-age=0</code> 和 <code>must-revalidate</code> 的组合与 <code>no-cache</code> 具有相同的含义。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0, must-revalidate<br></code></pre></td></tr></table></figure><p><code>max-age=0</code> 意味着响应立即过时，而 <code>must-revalidate</code> 意味着一旦过时就不得在没有重新验证的情况下重用它——因此，结合起来，语义似乎与 <code>no-cache</code> 相同。</p><p>然而，<code>max-age=0</code> 的使用是解决 HTTP&#x2F;1.1 之前的许多实现无法处理 <code>no-cache</code> 这一指令——因此为了解决这个限制，<code>max-age=0</code> 被用作解决方法。</p><p>但是现在符合 HTTP&#x2F;1.1 的服务器已经广泛部署，没有理由使用 <code>max-age=0</code> 和 <code>must-revalidate</code> 组合——你应该只使用 <code>no-cache</code>。</p><h3 id="不使用缓存"><a href="#不使用缓存" class="headerlink" title="不使用缓存"></a>不使用缓存</h3><p><code>no-cache</code> 指令不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应。</p><p>如果你不希望将响应存储在任何缓存中，应使用 <code>no-store</code>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br></code></pre></td></tr></table></figure><h3 id="重新加载"><a href="#重新加载" class="headerlink" title="重新加载"></a>重新加载</h3><p>为了从页面错误中恢复或更新到最新版本的资源，浏览器为用户提供了重新加载功能。</p><p>在浏览器重新加载期间发送的 HTTP 请求的简化视图如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;deadbeef&quot;<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 20:20:20 GMT<br></code></pre></td></tr></table></figure><p>请求中的 <code>max-age=0</code> 指令指定“重用 age 为 0 或更少的响应”——因此，中间存储的响应不会被重用。</p><p>请求通过 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 进行验证。</p><h3 id="强制重新加载"><a href="#强制重新加载" class="headerlink" title="强制重新加载"></a>强制重新加载</h3><p>出于向后兼容的原因，浏览器在重新加载期间使用 <code>max-age=0</code>——因为在 HTTP&#x2F;1.1 之前的许多过时的实现中不理解 <code>no-cache</code>。但是在这个用例中，<code>no-cache</code> 已被支持，并且<strong>强制重新加载</strong>是绕过缓存响应的另一种方法。</p><p>浏览器<strong>强制重新加载</strong>期间的 HTTP 请求如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Pragma</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br></code></pre></td></tr></table></figure><h3 id="避免重新验证"><a href="#避免重新验证" class="headerlink" title="避免重新验证"></a>避免重新验证</h3><p>永远不会改变的内容应该被赋予一个较长的 <code>max-age</code>，方法是使用缓存破坏——也就是说，在请求 URL 中包含版本号、哈希值等。</p><p>但是，当用户重新加载时，即使服务器知道内容是不可变的，也会发送重新验证请求。</p><p>为了防止这种情况，<code>immutable</code> 指令可用于明确指示不需要重新验证，因为内容永远不会改变。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=31536000, immutable<br></code></pre></td></tr></table></figure><p>这可以防止在重新加载期间进行不必要的重新验证。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>如下图请求网站<a href="https://seeyourface.cn，第一次请求我们注意服务器返回的响应内容：">https://seeyourface.cn，第一次请求我们注意服务器返回的响应内容：</a></p><p>HTTP Code : 200 —— 没有使用强制缓存，同时也没有进行协商缓存。</p><p>Etag —— 协商缓存用到的标头，缓存失效时下一个请求在<code>If-None-Match</code>中携带缓存中Etag内容，服务器经过验证后，如果没有对资源进行修改，返回304 Not Modified。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230928000111033.png" alt="image-20230928000111033"></p><p>我们刷新浏览器再次请求，状态码确实是304，我这个请求是在600秒之内刷新的，那为什么第一次的请求标头中的 <code>Cache-Control : max-age=600</code> 字段没有生效呢，不应该是通过强制缓存直接重用响应吗？</p><p>这是因为请求中携带了 <code>Cache-Control : max-age=0</code> ，请求中的 <code>max-age=0</code> 指令指定“重用 age 为 0 或更少的响应”——因此，我们存储的响应不会被重用。而是通过 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 进行验证。所以请求标头<code>If-None-Match</code>中携带了上一次响应的<code>Etag</code>字段内容，服务器经过验证，认为该资源自上次请求以来没有被修改，所以返回304状态码，客户端可重用已存储的响应。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230928000248303.png" alt="image-20230928000248303"></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK源码系列-LinkedList</title>
    <link href="/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-LinkedList/"/>
    <url>/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-LinkedList/</url>
    
    <content type="html"><![CDATA[<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文内容均以JDK8为例。</p><p><code>LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。</p><p><img src="https://image.seeyourface.cn/migrate/linkedList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="linkedList数据结构"></p><p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p><p><img src="https://image.seeyourface.cn/migrate/336a2145-32ef-497e.png" alt="336a2145-32ef-497e"></p><p>另外，<strong>不要</strong>下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) ，因为都需要先遍历到对应节点再进行增删操作。</p><h4 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h4><ul><li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持<strong>随机访问</strong>（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p><h4 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h4><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p><p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p><p><code>LinkedList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，<code>Deque</code> 的发音为 “deck” [dɛk]，这个大部分人都会读错。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化和反序列化操作，也就是即可以将<strong>对象序列化为字节流</strong>进行持久化存储或网络传输，也可以从<strong>字节流反序列化为对象</strong>，非常方便。</li></ul><p><img src="https://image.seeyourface.cn/migrate/image-20230924171241953.png" alt="image-20230924171241953"></p><p>与ArrayList不同的是，<code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>       <span class="hljs-comment">// 实际存储数据</span><br>       E item;<br>       <span class="hljs-comment">// 后继节点</span><br>       Node&lt;E&gt; next;<br>       <span class="hljs-comment">// 前驱节点</span><br>       Node&lt;E&gt; prev;<br><span class="hljs-comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span><br>       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>           <span class="hljs-built_in">this</span>.item = element;<br>           <span class="hljs-built_in">this</span>.next = next;<br>           <span class="hljs-built_in">this</span>.prev = prev;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个空的链表对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br><span class="hljs-comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>       <span class="hljs-built_in">this</span>();<br>       addAll(c);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p><code>LinkedList</code> 除了实现了 <code>List</code> 接口相关方法，还实现了 <code>Deque</code> 接口的很多方法，所以我们有很多种方式插入元素。</p><p>这里以 <code>List</code> 接口中相关的插入方法为例进行源码讲解，对应的是<code>add()</code> 方法。</p><p><code>add()</code> 方法有两个版本：</p><ul><li><code>add(E e)</code>：用于在 <code>LinkedList</code> 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。</li><li><code>add(int index, E element)</code>:用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n &#x2F; 2 个元素，时间复杂度为 O(n)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在链表尾部插入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表指定位置插入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 下标越界检查</span><br>    checkPositionIndex(index);<br><br>    <span class="hljs-comment">// 判断 index 是不是链表尾部位置</span><br>    <span class="hljs-keyword">if</span> (index == size)<br>        <span class="hljs-comment">// 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可</span><br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果不是则调用 linkBefore 方法将其插入指定元素之前</span><br>        linkBefore(element, node(index));<br>&#125;<br><br><span class="hljs-comment">// 将元素节点插入到链表尾部</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 将最后一个元素赋值（引用传递）给节点 l</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 将 last 引用指向新节点</span><br>    last = newNode;<br>    <span class="hljs-comment">// 判断尾节点是否为空</span><br>    <span class="hljs-comment">// 如果 l 是null 意味着这是第一次添加元素</span><br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span><br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span><br>        l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br><br><span class="hljs-comment">// 在指定元素之前插入元素</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br>    <span class="hljs-comment">// assert succ != null;断言 succ不为 null</span><br>    <span class="hljs-comment">// 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>    <span class="hljs-comment">// 初始化节点，并指明前驱和后继节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>    <span class="hljs-comment">// 将 succ 节点前驱引用 prev 指向新节点</span><br>    succ.prev = newNode;<br>    <span class="hljs-comment">// 判断尾节点是否为空，为空表示当前链表还没有节点</span><br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// succ 节点前驱的后继引用指向新节点</span><br>        pred.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><code>LinkedList</code>获取元素相关的方法一共有 3 个：</p><ol><li><code>getFirst()</code>：获取链表的第一个元素。</li><li><code>getLast()</code>：获取链表的最后一个元素。</li><li><code>get(int index)</code>：获取链表指定位置的元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取链表的第一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-comment">// 获取链表的最后一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> l.item;<br>&#125;<br><br><span class="hljs-comment">// 获取链表指定位置的元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>  <span class="hljs-comment">// 下标越界检查，如果越界就抛异常</span><br>  checkElementIndex(index);<br>  <span class="hljs-comment">// 返回链表中对应下标的元素</span><br>  <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br></code></pre></td></tr></table></figure><p>get(index)方法的核心在于 <code>node(int index)</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回指定下标的非空节点</span><br>Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 断言下标未越界</span><br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br>    <span class="hljs-comment">// 如果index小于size的二分之一  从前开始查找（向后查找）  反之向前查找</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-comment">// 遍历，循环向后查找，直至 i == index</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>get(int index)</code> 或 <code>remove(int index)</code> 等方法内部都调用了该方法来获取对应的节点。</p><p>从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><code>LinkedList</code>删除元素相关的方法一共有 5 个：</p><ol><li><code>removeFirst()</code>：删除并返回链表的第一个元素。</li><li><code>removeLast()</code>：删除并返回链表的最后一个元素。</li><li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li><li><code>void clear()</code>：移除此链表中的所有元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除并返回链表的第一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br><br><span class="hljs-comment">// 删除并返回链表的最后一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkLast(l);<br>&#125;<br><br><span class="hljs-comment">// 删除链表中首次出现的指定元素，如果不存在该元素则返回 fals</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果不为 null ,遍历链表找到要删除的节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除链表指定位置的元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 下标越界检查，如果越界就抛异常</span><br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的核心在于 <code>unlink(Node&lt;E&gt; x)</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>    <span class="hljs-comment">// 断言 x 不为 null</span><br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-comment">// 获取当前节点（也就是待删除节点）的元素</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<br>    <span class="hljs-comment">// 获取当前节点的下一个节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-comment">// 获取当前节点的前一个节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>    <span class="hljs-comment">// 如果前一个节点为空，则说明当前节点是头节点</span><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 维护链表头指向当前节点的下一个节点</span><br>        first = next;<br>    <span class="hljs-comment">// 如果前一个节点不为空    </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将前一个节点的 next 指针指向当前节点的下一个节点</span><br>        prev.next = next;<br>        <span class="hljs-comment">// 将当前节点的 prev 指针置为 null，，方便 GC 回收</span><br>        x.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果下一个节点为空，则说明当前节点是尾节点</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 维护链表尾指向当前节点的前一个节点</span><br>        last = prev;<br>    <span class="hljs-comment">// 如果下一个节点不为空    </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将下一个节点的 prev 指针指向当前节点的前一个节点</span><br>        next.prev = prev;<br>        <span class="hljs-comment">// 将当前节点的 next 指针置为 null，方便 GC 回收</span><br>        x.next = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将当前节点元素置为 null，方便 GC 回收</span><br>    x.item = <span class="hljs-literal">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unlink()</code> 方法的逻辑如下：</p><ol><li><p>首先获取待删除节点 x 的前驱和后继节点；</p></li><li><p>判断待删除节点是否为头节点或尾节点： </p><ul><li><p>如果 x 是头节点，则将 first 指向 x 的后继节点 next</p></li><li><p>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</p></li><li><p>如果 x 不是头节点也不是尾节点，执行下一步操作</p></li></ul></li><li><p>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</p></li><li><p>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</p></li><li><p>将待删除节点 x 的元素置空，修改链表长度。</p></li></ol><p>参考下图理解：</p><p><img src="https://image.seeyourface.cn/migrate/LinkedList%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91.jpg" alt="LinkedList删除节点逻辑"></p><h4 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h4><p>推荐使用<code>for-each</code> 循环来遍历 <code>LinkedList</code> 中的元素， <code>for-each</code> 循环最终会转换成迭代器形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;pear&quot;</span>);<br><br><span class="hljs-keyword">for</span> (String fruit : list) &#123;<br>    System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LinkedList</code> 的遍历的核心就是它的迭代器的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 双向迭代器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListItr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 表示上一次调用 next() 或 previous() 方法时经过的节点；</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; lastReturned;<br>    <span class="hljs-comment">// 表示下一个要遍历的节点；</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; next;<br>    <span class="hljs-comment">// 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> nextIndex;<br>    <span class="hljs-comment">// 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>    …………<br>&#125;<br></code></pre></td></tr></table></figure><p>下面对迭代器 <code>ListItr</code> 中的核心方法进行详细介绍。</p><p>我们先来看下从头到尾方向的迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断还有没有下一个节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历</span><br>    <span class="hljs-keyword">return</span> nextIndex &lt; size;<br>&#125;<br><br><span class="hljs-comment">// 获取下一个节点</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查在迭代过程中链表是否被修改过</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常</span><br>    <span class="hljs-keyword">if</span> (!hasNext())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-comment">// 将 lastReturned 指向当前节点</span><br>    lastReturned = next;<br>    <span class="hljs-comment">// 将 next 指向下一个节点</span><br>    next = next.next;<br>    nextIndex++;<br>    <span class="hljs-keyword">return</span> lastReturned.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看一下从尾到头方向的迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否还有前一个节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextIndex &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取前一个节点</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">previous</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是否在迭代过程中链表被修改</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 如果没有前一个节点，则抛出异常</span><br>    <span class="hljs-keyword">if</span> (!hasPrevious())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-comment">// 将 lastReturned 和 next 指针指向上一个节点</span><br>    lastReturned = next = (next == <span class="hljs-literal">null</span>) ? last : next.prev;<br>    nextIndex--;<br>    <span class="hljs-keyword">return</span> lastReturned.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要删除或插入元素，也可以使用迭代器进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>list.add(<span class="hljs-literal">null</span>);<br>list.add(<span class="hljs-string">&quot;banana&quot;</span>);<br><br><span class="hljs-comment">// Collection 接口的 removeIf 方法底层依然是基于迭代器</span><br>list.removeIf(Objects::isNull);<br><br><span class="hljs-keyword">for</span> (String fruit : list) &#123;<br>    System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器对应的移除元素的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从列表中删除上次被返回的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是否在迭代过程中链表被修改</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 如果上次返回的节点为空，则抛出异常</span><br>    <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br><br>    <span class="hljs-comment">// 获取当前节点的下一个节点</span><br>    Node&lt;E&gt; lastNext = lastReturned.next;<br>    <span class="hljs-comment">// 从链表中删除上次返回的节点</span><br>    unlink(lastReturned);<br>    <span class="hljs-comment">// 修改指针</span><br>    <span class="hljs-keyword">if</span> (next == lastReturned)<br>        next = lastNext;<br>    <span class="hljs-keyword">else</span><br>        nextIndex--;<br>    <span class="hljs-comment">// 将上次返回的节点引用置为 null，方便 GC 回收</span><br>    lastReturned = <span class="hljs-literal">null</span>;<br>    expectedModCount++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK源码系列-ArrayList</title>
    <link href="/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/"/>
    <url>/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/</url>
    
    <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文内容均以JDK8为例。</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>RandomAccess</code> : 这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化和反序列化操作，也就是即可以将<strong>对象序列化为字节流</strong>进行持久化存储或网络传输，也可以从<strong>字节流反序列化为对象</strong>，非常方便。</li></ul><p><img src="https://image.seeyourface.cn/migrate/image-20230924112821522.png" alt="image-20230924112821522"></p><p><code>ArrayList</code> 的底层是数组队列，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的优点是容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这样可以减少递增式再分配的数量，提高程序执行的效率。</p><h4 id="ArrayList和Vector的区别？"><a href="#ArrayList和Vector的区别？" class="headerlink" title="ArrayList和Vector的区别？"></a>ArrayList和Vector的区别？</h4><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全。</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，通过<em>synchronized</em>关键字保证线程安全。</li></ul><h4 id="ArrayList可以添加null值吗？"><a href="#ArrayList可以添加null值吗？" class="headerlink" title="ArrayList可以添加null值吗？"></a>ArrayList可以添加null值吗？</h4><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。但是不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， 因为<code>null</code> 值无意义，会让代码难以维护例如忘记做判空处理就会导致<strong>空指针</strong>异常。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230924114702452.png" alt="image-20230924114702452"></p><h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h4><ul><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都不是同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为双向循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行<strong>向后位&#x2F;向前</strong>移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先<strong>移动到指定位置</strong>再插入和删除。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。本质是因为<code>LinkedList</code>元素的存储不是连续的。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h4 id="ArrayList核心源码"><a href="#ArrayList核心源码" class="headerlink" title="ArrayList核心源码"></a>ArrayList核心源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.UnaryOperator;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认初始容量大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空数组（用于空实例）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 用于默认大小空实例的共享空数组实例。</span><br><span class="hljs-comment">     * 目的是把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span><br><span class="hljs-comment">     */</span> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存ArrayList数据的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList 所包含的元素个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span><br>            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数等于0，创建空数组</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//其他情况，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认无参构造函数</span><br><span class="hljs-comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        <span class="hljs-comment">//将指定集合转换为数组</span><br>        elementData = c.toArray();<br>        <span class="hljs-comment">//如果elementData数组的长度不为0</span><br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                <span class="hljs-comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span><br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// elementData数组长度为0，用空数组代替</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>            elementData = (size == <span class="hljs-number">0</span>)<br>              ? EMPTY_ELEMENTDATA<br>              : Arrays.copyOf(elementData, size);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//下面是ArrayList的扩容机制</span><br><span class="hljs-comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><br><span class="hljs-comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>            <span class="hljs-comment">// any size if not default element table</span><br>            ? <span class="hljs-number">0</span><br>            <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>            <span class="hljs-comment">// supposed to be at default size.</span><br>            : DEFAULT_CAPACITY;<br>        <span class="hljs-comment">//如果最小容量大于已有的最大容量</span><br>        <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>            ensureExplicitCapacity(minCapacity);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//1.得到最小扩容量</span><br>    <span class="hljs-comment">//2.通过最小容量扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>              <span class="hljs-comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span><br>            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br><br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>    <br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>            grow(minCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要分配的最大数组大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity / 2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span><br>        <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span><br>        <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br>    <br>    <span class="hljs-comment">//比较minCapacity和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回此列表中的元素数。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表不包含元素，则返回 true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//注意=和==的区别</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表包含指定的元素，则返回true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br>        <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-comment">//equals()方法比较</span><br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span><br>            v.elementData = Arrays.copyOf(elementData, size);<br>            v.modCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">// 这不应该发生，因为我们是可以克隆的</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span><br><span class="hljs-comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span><br><span class="hljs-comment">     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span><br><span class="hljs-comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span><br><span class="hljs-comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span><br><span class="hljs-comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span><br><span class="hljs-comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">if</span> (a.length &lt; size)<br>            <span class="hljs-comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span><br>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>            <span class="hljs-comment">//调用System提供的arraycopy()方法实现数组之间的复制</span><br>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-comment">// 这段逻辑的目的是在将列表元素复制到数组后，如果数组的长度大于列表的大小（即列表中的元素个数），则将数组中多余的元素位置置为 null。</span><br>        <span class="hljs-comment">// 这样做是为了避免在后续的代码中可能导致混淆或错误的情况。</span><br>        <span class="hljs-comment">// 例如 list = &#123;&quot;java&quot;, &quot;c&quot;&#125; a = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125; 返回的数组为 &#123;&quot;java&quot;, &quot;c&quot;, null, &quot;4&quot;, &quot;5&quot;&#125;</span><br>        <span class="hljs-comment">// 这样就可以避免混淆list中的元素和a数组中的旧元素</span><br>        <span class="hljs-keyword">if</span> (a.length &gt; size)<br>            a[size] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-comment">// Positional Access Operations</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用指定的元素替换此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        <span class="hljs-comment">//对index进行界限检查</span><br>        rangeCheck(index);<br><br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>        elementData[index] = element;<br>        <span class="hljs-comment">//返回原来在这个位置的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span><br>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                         size - index);<br>        elementData[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        modCount++;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-comment">//从列表中删除的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span><br><span class="hljs-comment">     * 返回true，如果此列表包含指定的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Private remove method that skips bounds checking and does not</span><br><span class="hljs-comment">     * return the value removed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// 把数组中所有的元素的值设为null</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            elementData[i] = <span class="hljs-literal">null</span>;<br><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index, elementData, index + numNew,<br>                             numMoved);<br><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span><br><span class="hljs-comment">     * 将任何后续元素移动到左侧（减少其索引）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - toIndex;<br>        System.arraycopy(elementData, toIndex, elementData, fromIndex,<br>                         numMoved);<br><br>        <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> size - (toIndex-fromIndex);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> newSize; i &lt; size; i++) &#123;<br>            elementData[i] = <span class="hljs-literal">null</span>;<br>        &#125;<br>        size = newSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查给定的索引是否在范围内。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * add和addAll使用的rangeCheck的一个版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回IndexOutOfBoundsException细节信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Index: &quot;</span>+index+<span class="hljs-string">&quot;, Size: &quot;</span>+size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除指定集合中包含的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-comment">//如果此列表被修改则返回true</span><br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 仅保留此列表中包含在指定集合中的元素。</span><br><span class="hljs-comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span><br><span class="hljs-comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span>+index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *以正确的顺序返回该列表中的元素的迭代器。</span><br><span class="hljs-comment">     *返回的迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h4><p>先从 ArrayList 的构造函数说起，ArrayList 有三种方式来初始化，构造方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认初始容量大小</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br> &#125;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>     <span class="hljs-comment">//初始容量大于0</span><br>     <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// 创建initialCapacity大小的数组</span><br>         <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>     <span class="hljs-comment">//初始容量等于0</span><br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// 创建空数组</span><br>         <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>     <span class="hljs-comment">//初始容量小于0，抛出异常    </span><br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                            initialCapacity);<br>     &#125;<br> &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span><br><span class="hljs-comment"> * 如果指定的集合为null，throws NullPointerException。</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>     elementData = c.toArray();<br>     <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>         <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>             elementData = Arrays.copyOf(elementData, size, Object[].class);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// replace with empty array.</span><br>         <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>以无参数构造方法创建</strong> <code>ArrayList</code> <strong>时，实际上初始化赋值的是一个空数组。</strong></p><p><strong>当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </p><blockquote><p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData </p></blockquote><h5 id="逐步分析-ArrayList-扩容机制"><a href="#逐步分析-ArrayList-扩容机制" class="headerlink" title="逐步分析 ArrayList 扩容机制"></a>逐步分析 ArrayList 扩容机制</h5><p>这里以无参构造函数创建的 ArrayList 为例分析</p><h6 id="先来看-add-方法"><a href="#先来看-add-方法" class="headerlink" title="先来看 add 方法"></a>先来看 <code>add</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal方法</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h6 id="再来看看-ensureCapacityInternal-方法"><a href="#再来看看-ensureCapacityInternal-方法" class="headerlink" title="再来看看 ensureCapacityInternal() 方法"></a>再来看看 <code>ensureCapacityInternal()</code> 方法</h6><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 方法里面调用calculateCapacity获取最小容量</span><br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="calculateCapacity-方法"><a href="#calculateCapacity-方法" class="headerlink" title="calculateCapacity()方法"></a>calculateCapacity()方法</h6><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算最小容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-comment">// 如果是无参构造，elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA为true</span><br>       <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>           <span class="hljs-comment">// 这里取1和DEFAULT_CAPACITY的较大值，也就是10</span><br>           <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>       &#125;<br>       <span class="hljs-keyword">return</span> minCapacity;<br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity()方法"></a>ensureExplicitCapacity()方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       modCount++;<br><br>       <span class="hljs-comment">// overflow-conscious code</span><br>       <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>           <span class="hljs-comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>           grow(minCapacity);<br>   &#125;<br></code></pre></td></tr></table></figure><p>我们来仔细分析一下这个过程：</p><ul><li><p>当我们要 add 进第 1 个元素到 ArrayList 时，<code>elementData.length</code> 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</p></li><li><p>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</p></li><li><p>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</p></li><li><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p></li></ul><h6 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a><code>grow()</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 要分配的最大数组大小</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// ArrayList核心扩容方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>       <span class="hljs-comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity / 2，</span><br>       <span class="hljs-comment">// 因为位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍。</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>       <span class="hljs-comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span><br>       <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>           newCapacity = minCapacity;<br>       <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE, 进入`hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE</span><br>       <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>       <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>           newCapacity = hugeCapacity(minCapacity);<br>       <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>       elementData = Arrays.copyOf(elementData, newCapacity);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1), 所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数。</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt; 1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 右移了 1 位所以相当于 oldCapacity &#x2F; 2。对于大数据的 二进制运算, 位移运算符比那些普通运算符的运算要快很多，因为程序底层都是基于二进制所以程序仅仅是移动一下而已，不用去计算，这样提高了效率，节省了资源。</p></blockquote><p><strong>我们再来通过例子探究一下</strong><code>grow()</code> <strong>方法：</strong></p><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true，size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true，size 增为 11。</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li><p>java 中的 <code>length</code>属性是针对数组说的，比如说你声明了一个数组，想知道这个数组的长度则用到了 length 这个属性。</p></li><li><p>java 中的 <code>length()</code> 方法是针对字符串说的，如果想看这个字符串的长度则用到 <code>length()</code> 这个方法。</p></li><li><p>java 中的 <code>size()</code> 方法是针对泛型集合说的，如果想看这个泛型有多少个元素，就调用此方法来查看！</p></li></ul><h6 id="hugeCapacity-方法。"><a href="#hugeCapacity-方法。" class="headerlink" title="hugeCapacity() 方法。"></a><code>hugeCapacity()</code> 方法。</h6><p>从上面 <code>grow()</code> 方法源码我们知道：如果新容量大于 <code>MAX_ARRAY_SIZE</code>，进入(执行) hugeCapacity() 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>       <span class="hljs-comment">// 对minCapacity和MAX_ARRAY_SIZE进行比较</span><br>       <span class="hljs-comment">// 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br>       <span class="hljs-comment">// 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br>       <span class="hljs-comment">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>       <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>           Integer.MAX_VALUE :<br>           MAX_ARRAY_SIZE;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf()方法"></a><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h5><p>通过上面的源码，我们会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h6 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy() 方法"></a><code>System.arraycopy()</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos,</span><br><span class="hljs-params">                                    Object dest, <span class="hljs-type">int</span> destPos,</span><br><span class="hljs-params">                                    <span class="hljs-type">int</span> length)</span>;<br></code></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment"> * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment"> * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheckForAdd(index);<br><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// arraycopy()方法实现数组自己复制自己</span><br>    <span class="hljs-comment">// elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf()方法"></a><code>Arrays.copyOf()</code>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 复制指定的数组，截断或填充 null（如有必要），以便副本具有指定的长度。对于在原始数组和副本中都有效的所有索引，这两个数组将包含相同的值。</span><br><span class="hljs-comment">   * 对于在副本中有效但对原始副本无效的任何索引，副本将包含 null。当且仅当指定的长度大于原始数组的长度时，此类索引才会存在。</span><br><span class="hljs-comment">   * 生成的数组与原始数组的类完全相同。 </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">* @param original 源对象数组，需要被复制的数组</span><br><span class="hljs-comment">   * @param newLength 要返回的副本的长度</span><br><span class="hljs-comment">   * @return 原始数组的副本，截断或填充空值获取指定长度</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOf(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> newLength) &#123;<br>   <span class="hljs-comment">// 申请一个新的数组</span><br>       <span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[newLength];<br><span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span><br>       System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                        Math.min(original.length, newLength));<br>       <span class="hljs-keyword">return</span> copy;<br>   &#125;<br></code></pre></td></tr></table></figure><p>再举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span><br><span class="hljs-comment"> * 返回的数组的运行时类型是指定数组的运行时类型。</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br> <span class="hljs-comment">//elementData：要复制的数组；size：要复制的长度</span><br>     <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br> &#125;<br></code></pre></td></tr></table></figure><h6 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h6><p><strong>联系：</strong>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h5 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a><code>ensureCapacity</code>方法</h5><p><code>ArrayList</code> 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 <code>ArrayList</code> 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>        <span class="hljs-comment">// any size if not default element table</span><br>        ? <span class="hljs-number">0</span><br>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>        <span class="hljs-comment">// supposed to be at default size.</span><br>        : DEFAULT_CAPACITY;<br><br>    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>意思是，我们在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity</code> 方法将容量扩容至可以容纳元素的大小，以减少增量时重新分配的次数。</p><p>通过下面的代码实际测试以下这个方法的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>           list.add(i);<br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;使用ensureCapacity方法前：&quot;</span> + (endTime - startTime));<br>   &#125;<br><br><span class="hljs-comment">// 执行五次分别获得的结果</span><br><span class="hljs-comment">// 使用ensureCapacity方法前：2295, 2291, 2308, 2305, 2306</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">startTime1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>   <span class="hljs-comment">// 使用ensureCapacity方法</span><br>       list.ensureCapacity(N);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>           list.add(i);<br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">endTime1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;使用ensureCapacity方法后：&quot;</span> + (endTime1 - startTime1));<br>   &#125;<br><br><span class="hljs-comment">// 执行五次分别获得的结果</span><br><span class="hljs-comment">// 使用ensureCapacity方法前：2163, 2113, 2156, 2150, 2164</span><br></code></pre></td></tr></table></figure><p>通过运行结果，可以看出向 <code>ArrayList</code> 添加大量元素之前使用<code>ensureCapacity</code> 方法可以稍稍提升性能。</p><p>不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 <code>ArrayList</code> 里面添加这么多元素。</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么ConcurrentHashMap的key/value不能为空，HashMap可以？</title>
    <link href="/2023/09/23/%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E7%9A%84keyvalue%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8CHashMap%E5%8F%AF%E4%BB%A5%EF%BC%9F/"/>
    <url>/2023/09/23/%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E7%9A%84keyvalue%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8CHashMap%E5%8F%AF%E4%BB%A5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么ConcurrentHashMap的key-value不能为空，HashMap可以？"><a href="#为什么ConcurrentHashMap的key-value不能为空，HashMap可以？" class="headerlink" title="为什么ConcurrentHashMap的key&#x2F;value不能为空，HashMap可以？"></a>为什么ConcurrentHashMap的key&#x2F;value不能为空，HashMap可以？</h3><p>以JDK8为例，在ConcurrentHashMap源码的<code>putVal</code>方法中当传入的参数key或者value为null时，会抛出<code>NullPointerException</code></p><img src="https://image.seeyourface.cn/migrate/image-20230923222339494.png" alt="image-20230923222339494" style="zoom: 67%;" /><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。</p><p>null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 ConcurrentHashMap 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 ConcurrentHashMap 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，<strong>存在</strong>一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以<strong>无法通过</strong> <code>containsKey(key)</code> 来判断否存在这个键值对，也就没<strong>办法解决二义性</strong>问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，<strong>不存在</strong>一个线程操作该 <code>HashMap</code> 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，<strong>多线程下无法正确判定键值对是否存在</strong>（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果确实需要在 <code>ConcurrentHashMap</code> 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">NULL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><hr><p>关于<code>ConcurrentHashMap</code> 作者本人 (Doug Lea)对于这个问题做出的回答：</p><blockquote><p>The main reason that nulls aren’t allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) is that ambiguities that may be just barely tolerable in non-concurrent maps can’t be accommodated. The main one is that if map.get(key) returns null, you can’t detect whether the key explicitly maps to null vs the key isn’t mapped. In a non-concurrent map, you can check this via map.contains(key), but in a concurrent one, the map might have changed between calls.</p></blockquote><p>翻译：</p><p>ConcurrentMaps（ConcurrentHashMaps、ConcurrentSkipListMaps）中不允许使用 null 的主要原因是，无法容纳在非并发映射中勉强可以容忍的歧义。主要的一点是，如果map.get(key)返回null，你无法检测该键是否显式映射到null与该键是否未映射。在非并发映射中，您可以通过 map.contains(key) 检查这一点，但在并发映射中，映射可能在<strong>调用之间</strong>发生了变化。</p><h4 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h4><p>那么<strong>问题来了</strong>，你有可能会问：八股我都背烂了<code>ConcurrentHashMap</code>不是线程安全的吗，为什么会有其他线程造成影响？</p><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证<strong>多个线程同时对它进行读写操作</strong>时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 HashMap 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p><p>复合操作是指由多个<strong>基本操作</strong>(如put、get、remove、containsKey等)组成的操作，例如先判断某个键是否存在<strong>containsKey(key)<strong>，然后根据结果进行插入或更新</strong>put(key, value)<strong>。这种操作在执行过程中可能会被其他线程</strong>打断</strong>，导致结果不符合预期。</p><p>例如，有两个线程 A 和 B 同时对 <code>ConcurrentHashMap</code> 进行复合操作，如下：</p><img src="https://image.seeyourface.cn/migrate/image-20230923224919178.png" alt="image-20230923224919178" style="zoom: 67%;" /><p>如果线程 A 和 B 的执行顺序是这样：</p><ol><li>线程 A 判断 map 中不存在 key</li><li>线程 B 判断 map 中不存在 key</li><li>线程 B 将 (key, anotherValue) 插入 map</li><li>线程 A 将 (key, value) 插入 map</li></ol><p>那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是<strong>复合操作的非原子性</strong>导致的问题。</p><h4 id="那如何保证-ConcurrentHashMap-复合操作的原子性呢？"><a href="#那如何保证-ConcurrentHashMap-复合操作的原子性呢？" class="headerlink" title="那如何保证 ConcurrentHashMap 复合操作的原子性呢？"></a>那如何保证 ConcurrentHashMap 复合操作的原子性呢？</h4><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 putIfAbsent、compute、computeIfAbsent 、computeIfPresent、merge等。</p><p>这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p><img src="https://image.seeyourface.cn/migrate/image-20230923225542922.png" alt="image-20230923225542922" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ConcurrentHashMap</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK工具使用指南</title>
    <link href="/2023/09/23/JDK%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/09/23/JDK%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="JDK工具使用指南"><a href="#JDK工具使用指南" class="headerlink" title="JDK工具使用指南"></a>JDK工具使用指南</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p><strong>该命令用于打印当前JVM中运行的Java进程状态信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jps [options] [<span class="hljs-built_in">hostid</span>]<br></code></pre></td></tr></table></figure><p><code>options</code>表示命令可选参数：</p><ul><li>-q：仅显示pid</li><li>-m：显示进程pid及main方法参数</li><li>-l：打印进程对应JAR文件所在的完整路径名</li><li>-v：查看进程pid及JVM参数</li><li>-h：打印帮助信息</li></ul><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p><strong>用于打印全部参数和系统属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jinfo [options] &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-[pid]：输出全部参数</li><li>-flag [name] pid：打印对应名称的参数内容</li><li>-flag [+|-] [name] pid：不重启虚拟机的情况下，动态修改JVM参数</li><li>-flag [name]&#x3D;[value]：不重启虚拟机的情况下，动态修改JVM参数</li></ul><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p><strong>对Java应用程序的性能和资源进行实时监控，包括Heap和垃圾回收状态的监控</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstat -[options] [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]<br></code></pre></td></tr></table></figure><p>其中，vmid为虚拟机id，Liunx&#x2F;Unix一般为pid，interval为采样间隔（ms），count为采样数</p><p><code>jstat -gc 54231 1000 3</code> 表示每隔1000ms打印一次pid为54231的进程GC信息，总共打印三次</p><p>options表示命令可选参数：</p><ul><li><p>-class：显示加载class的数量及所占空间等信息</p></li><li><p>-compiler：JIT即时编译器相关的统计信息</p></li><li><p>-gc：打印GC信息（展开查看参数说明）</p></li><li><p>-gccapacity：打印各个内存池分代空间的容量</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>NGCMN</td><td>年轻代(young)中初始化(最小)的大小(字节)</td></tr><tr><td>NGCMX</td><td>年轻代(young)的最大容量(字节)</td></tr><tr><td>NGC</td><td>年轻代(young)中当前的容量(字节)</td></tr><tr><td>S0C</td><td>年轻代中第一个survivor（幸存区）的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个survivor（幸存区）的容量(字节)</td></tr><tr><td>EC</td><td>年轻代中Eden（伊甸园）的容量(字节)</td></tr><tr><td>OGCMN</td><td>old代中初始化(最小)的大小(字节)</td></tr><tr><td>OGCMX</td><td>old代的最大容量(字节)</td></tr><tr><td>OGC</td><td>old代当前新生成的容量(字节)</td></tr><tr><td>OC</td><td>Old代的容量(字节)</td></tr><tr><td>MCMN</td><td>Metaspace 区初始化 ( 最小 ) 容量 (字节)</td></tr><tr><td>MCMX</td><td>Metaspace 区的最大容量(字节)</td></tr><tr><td>MC</td><td>当前 Metaspace 的容量(字节)</td></tr><tr><td>CCSMN</td><td>最小压缩类空间大小(字节)</td></tr><tr><td>CCMSX</td><td>最大压缩类空间大小(字节)</td></tr><tr><td>CCSC</td><td>当前压缩类空间大小(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中GC(minor GC)次数</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时old代GC(full GC)次数</td></tr></tbody></table></li><li><p>-gcutil：GC相关区域的使用率统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>S0</td><td>年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</td></tr><tr><td>S1</td><td>年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</td></tr><tr><td>E</td><td>年轻代中Eden（伊甸园）已使用的占当前容量百分比</td></tr><tr><td>O</td><td>old代已使用的占当前容量百分比</td></tr><tr><td>M</td><td>Metaspace代已使用的占当前容量百分比</td></tr><tr><td>CCS</td><td>压缩区已使用的占当前容量百分比</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中gc所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时gc用的总时间(s)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时old代(全gc)gc次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时old代(全gc)gc所用时间(s)</td></tr></tbody></table></li><li><p>-gccause：查看上次GC和本次GC（如果正在GC）产生的原因，参数同-gcutil</p></li><li><p>-gcnew：年轻代的统计信息</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>S0C</td><td>年轻代中第一个survivor（幸存区）的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个survivor（幸存区）的容量(字节)</td></tr><tr><td>S0U</td><td>年轻代中第一个survivor（幸存区）目前已使用空间(字节)</td></tr><tr><td>S1U</td><td>年轻代中第二个survivor（幸存区）目前已使用空间(字节)</td></tr><tr><td>TT</td><td>持有次数限制(默认15)</td></tr><tr><td>MTT</td><td>Maximum tenuring threshold，可以通过-XX:MaxTenuringThreshold&#x3D;N设置，默认为15</td></tr><tr><td>DSS</td><td>Desired survivor size，单位为KB，这个值默认为Survivor区的50%</td></tr><tr><td>EC</td><td>年轻代中Eden（伊甸园）的容量(字节)</td></tr><tr><td>EU</td><td>年轻代中Eden（伊甸园）目前已使用空间(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中gc所用时间(s)</td></tr></tbody></table></li><li><p>-gcoldcapacity：老年代空间大小统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>OGCMN</td><td>老年代最小容量</td></tr><tr><td>OGCMX</td><td>老年代最大容量</td></tr><tr><td>OGC</td><td>当前老年代大小</td></tr><tr><td>OC</td><td>老年代大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table></li><li><p>-gcmetacapacity：meta区大小统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>MCMN</td><td>最小元数据容量</td></tr><tr><td>MCMX</td><td>最大元数据容量</td></tr><tr><td>MC</td><td>当前元空间大小</td></tr><tr><td>CCSMN</td><td>最小压缩类空间大小</td></tr><tr><td>CCSMX</td><td>最大压缩类空间大小</td></tr><tr><td>CCSC</td><td>当前压缩类空间大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table></li><li><p>-printcompilation：打印JVM编译统计信息</p></li></ul><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p><strong>用于查看堆内存的情况，或者将堆内存输出为二进制文本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap [option] &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li><p>-heap：打印堆内存配置和使用情况</p></li><li><p>-histo：打印堆内存中的对象大小、数量</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>num</td><td>序号</td></tr><tr><td>instances</td><td>实例个数</td></tr><tr><td>bytes</td><td>字节数</td></tr><tr><td>class_name</td><td>类名</td></tr></tbody></table></li><li><p><code>-dump:format=b,file=[filename].hprof</code> ：dump堆内存到hprof文件</p></li></ul><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p><strong>用于访问jmap命令生产的dump文件，通过浏览器访问</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jhat [options] &lt;dump-file&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-port：指定jhat的http服务端口，默认7000</li></ul><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p><strong>用于查看指定Java进程pid的堆栈信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstack [options]<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-F：强制线程转储。当jstack 没有响应(进程挂起)时使用</li><li>-m：打印Java和底层C&#x2F;C++框架所有栈信息</li><li>-l(小写L)：长列表模式，打印锁的附加信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL分页怎么优化？</title>
    <link href="/2023/09/22/MySQL%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F/"/>
    <url>/2023/09/22/MySQL%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>我们刷网站的时候，我们经常会遇到需要分页查询的场景。</p><p>比如下图谷歌的翻页功能。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922223517480.png" alt="image-20230922223517480"></p><p>我们很容易能联想到可以用MySQL实现。</p><p>假设我们的建表SQL是这样的:</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922224514427.png" alt="image-20230922224514427"></p><p>建表SQL大家也不用扣细节，只需要知道<strong>id是主键，并且在user_name建了个非主键索引</strong>就够了，其他都不重要。</p><p>为了实现分页。</p><p>很容易联想到下面这样的SQL语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-keyword">offset</span>, size;<br></code></pre></td></tr></table></figure><p>打个比方我们一页需要10条数据。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922224640869.png" alt="image-20230922224640869"></p><p>第一页就是下面这样的sql语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>第一百页就是:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">990</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>那么问题来了。</p><p>用这种方式，<strong>同样都是拿10条数据，查第一页和第一百页的查询速度是一样的吗？为什么？</strong></p><h3 id="两种limit的执行过程"><a href="#两种limit的执行过程" class="headerlink" title="两种limit的执行过程"></a>两种limit的执行过程</h3><p>上面的两种查询方式。对应 <code>limit offset, size</code> 和 <code>limit size</code> 两种方式。</p><p>而其实 <code>limit size</code> ，相当于 <code>limit 0, size</code>。也就是从0开始取size条数据</p><p>也就是说，两种方式的<strong>区别在于offset是否为0</strong>。</p><p>先来看下<code>limit sql</code>的内部执行逻辑。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922225317030.png" alt="image-20230922225317030"></p><p>mysql内部分为<strong>server层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用innodb。</p><p>server层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件</p><p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他where条件），则会放到<strong>结果集</strong>中，最后返回给调用mysql的<strong>客户端（go、java写的应用程序）</strong>。</p><p>我们可以对下面的sql先执行下 <code>explain</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>可以看到，explain中提示 key 那里，执行的是<strong>PRIMARY</strong>，也就是走的<strong>主键索引</strong>。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922225605773.png" alt="image-20230922225605773"></p><p>主键索引本质是一棵B+树，它是放在innodb中的一个数据结构。</p><p>我们可以回忆下，B+树大概长这样。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922225637429.png" alt="image-20230922225637429"></p><p>在这个树状结构里，我们需要关注的是，最下面一层节点，也就是<strong>叶子结点</strong>。而这个叶子结点里放的信息会根据当前的索引是<strong>主键索引还是非主键索引</strong>有所不同。</p><ul><li>如果是<strong>主键索引</strong>，它的叶子节点会存放完整的行数据信息。</li><li>如果是<strong>非主键索引</strong>，那它的叶子节点则会存放主键，如果想获得行数据信息，则需要再跑到主键索引去拿一次数据，这叫<strong>回表</strong>。</li></ul><p>比如执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">where</span> user_name <span class="hljs-operator">=</span> &quot;小白10&quot;;<br></code></pre></td></tr></table></figure><p>会通过非主键索引去查询<strong>user_name</strong>为”小白10”的数据，然后在叶子结点里找到**”小白10**”的数据对应的<strong>主键为10</strong>。</p><p>此时回表到<strong>主键索引</strong>中做查询，最后定位到<strong>主键为10的行数据</strong>。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922230006225.png" alt="image-20230922230006225"></p><p>但不管是主键还是非主键索引，他们的叶子结点数据都是<strong>有序的</strong>。比如在主键索引中，这些数据是根据主键id的大小，从小到大，进行排序的。</p><h4 id="基于主键索引的limit执行过程"><a href="#基于主键索引的limit执行过程" class="headerlink" title="基于主键索引的limit执行过程"></a>基于主键索引的limit执行过程</h4><p>回到文章开头的问题里，当我们去掉<code>explain</code>，执行这条sql。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sq">select * from page order by id limit 0, 10;<br></code></pre></td></tr></table></figure><p>上面select后面带的是<strong>星号</strong>，也就是要求获得行数据的所有字段信息。</p><p>server层会调用innodb的接口，在innodb里的主键索引中获取到第0到10条<strong>完整行数据</strong>，依次返回给server层，并放到server层的结果集中，返回给客户端。</p><p>而当我们把<code>offset</code>搞离谱点，比如执行的是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">6000000</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>server层会调用innodb的接口，由于这次的offset&#x3D;6000000，会在innodb里的主键索引中获取到第0到（6000000 + 10）条<strong>完整行数据，返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条</strong>，也就是10条数据，放到server层的结果集中，返回给客户端。</p><p>可以看出，当offset非0时，server层会从引擎层获取到很多无用的数据，而获取的这些无用数据都是要耗时的。</p><p>因此，我们就知道了文章开头的问题的答案，<strong>mysql查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出1000+10条数据，并抛弃前1000条，这部分耗时更大</strong>。</p><p><strong>那这种case有办法优化吗？</strong></p><p>可以看出，当offset非0时，server层会从引擎层获取到很多无用的数据，而当select后面是**<em><strong>号时，就需要拷贝完整的行信息，</strong>拷贝完整数据跟只拷贝行数据里的其中一两个列字段耗时是不同的</em>*，这就让原本就耗时的操作变得更加离谱。</p><p>因为前面的offset条数据最后都是不要的，就算将完整字段都拷贝来了又有什么用呢，所以我们可以将sql语句修改成下面这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">6000000</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>上面这条sql语句，里面先执行子查询 <code>select id from page order by id limit 6000000, 1</code>, 这个操作，其实也是将在innodb中的主键索引中获取到<code>6000000+1</code>条数据，然后server层会抛弃前6000000条，只保留最后一条数据的id。</p><p>但不同的地方在于，在返回server层的过程中，只会拷贝数据行内的id这一列，而不会拷贝数据行的所有列，当数据量较大时，这部分的耗时还是比较明显的。</p><p>在拿到了上面的id之后，假设这个id正好等于6000000，那sql就变成了这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span>(<span class="hljs-number">6000000</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这样innodb再走一次<strong>主键索引</strong>，通过B+树<strong>快速定位</strong>到id&#x3D;6000000的行数据，时间复杂度是log(n)，然后向后取10条数据。</p><p>这样性能确实是提升了，亲测能快一倍左右，属于那种耗时从3s变成1.5s的操作。</p><p>啊这······</p><p>属实有些杯水车薪，有点搓，属于没办法中的办法。</p><h4 id="基于非主键索引的limit执行过程"><a href="#基于非主键索引的limit执行过程" class="headerlink" title="基于非主键索引的limit执行过程"></a>基于非主键索引的limit执行过程</h4><p>上面提到的是主键索引的执行过程，我们再来看下基于非主键索引的limit执行过程。</p><p>比如下面的sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> user_name limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>server层会调用innodb的接口，在innodb里的非主键索引中获取到第0条数据对应的主键id后，<strong>回表</strong>到主键索引中找到对应的完整行数据，然后返回给server层，server层将其放到结果集中，返回给客户端。</p><p>而当offset&gt;0时，且offset的值较小时，逻辑也类似，区别在于，offset&gt;0时会丢弃前面的offset条数据。</p><p>也就是说<strong>非主键索引的limit过程，比主键索引的limit过程，多了个回表的消耗</strong>。</p><p>但当offset变得非常大时，比如600万，此时执行explain。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922231012627.png" alt="image-20230922231012627"></p><p>可以看到type那一栏显示的是<strong>ALL</strong>，也就是<strong>全表扫描</strong>。</p><p>这是因为server层的<strong>优化器</strong>，会在执行器执行sql语句前，判断下哪种执行计划的代价更小。</p><p>很明显，优化器在看到非主键索引的<strong>600w次回表</strong>之后，摇了摇头，我还不如全表一条条记录去判断算了，于是选择了全表扫描。</p><p>因此，当<strong>limit offset过大时，非主键索引查询非常容易变成全表扫描。是真·性能杀手</strong>。</p><p>这种情况也能通过一些方式去优化。比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page t1, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> user_name limit <span class="hljs-number">6000000</span>, <span class="hljs-number">100</span>) t2  <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure><p>通过<code>select id from page order by user_name limit 6000000, 100</code>。先走innodb层的user_name非主键索引取出id，因为只拿主键id，不需要回表，所以这块性能会稍微快点，在返回server层之后，同样抛弃前600w条数据，保留最后的100个id。然后再用这100个id去跟t1表做id匹配，此时走的是主键索引，将匹配到的100条行数据返回。这样就绕开了之前的600w条数据的回表。</p><p>当然，跟上面的case一样，还是没有解决要白拿600w条数据然后抛弃的问题，这也是非常挫的优化。</p><p>像这种，当offset变得超大时，比如到了百万千万的量级，问题就突然变得严肃了。</p><p>这里就产生了个专门的术语，叫<strong>深度分页</strong>。</p><h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>深度分页问题，是个很恶心的问题，恶心就恶心在，这个问题，它其实<strong>无解</strong>。</p><p>不管你是用mysql还是es，你都只能通过一些手段去”减缓”问题的严重性。</p><p>遇到这个问题，我们就该回过头来想想。</p><p>为什么我们的代码会产生深度分页问题？</p><p><strong>它背后的原始需求是什么</strong>，我们可以根据这个做一些规避。</p><h4 id="如果你是想取出全表的数据"><a href="#如果你是想取出全表的数据" class="headerlink" title="如果你是想取出全表的数据"></a>如果你是想取出全表的数据</h4><p>有些需求是这样的，我们有一张数据库表，但我们希望将这个数据库表里的所有数据取出，异构到es，或者hive里，这时候如果直接执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page;<br></code></pre></td></tr></table></figure><p>这个sql一执行，狗看了都摇头。</p><p>因为数据量较大，mysql根本没办法一次性获取到全部数据，妥妥<strong>超时报错</strong>。</p><p>于是不少mysql小白会通过<code>limit offset size</code>分页的形式去分批获取，刚开始都是好的，等慢慢地，哪天数据表变得奇大无比，就有可能出现前面提到的<code>深度分页</code>问题。</p><p>这种场景是最好解决的。</p><p>我们可以将所有的数据<strong>根据id主键进行排序</strong>，然后分批次取，将<strong>当前批次的最大id作为下次筛选的条件</strong>进行查询。</p><p>可以看下伪代码：</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922231706442.png" alt="image-20230922231706442"></p><p>这个操作，可以通过主键索引，每次定位到id在哪，然后往后遍历100个数据，这样不管是多少万的数据，查询性能都很稳定。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922231821926.png" alt="image-20230922231821926"></p><h4 id="如果是给用户做分页展示"><a href="#如果是给用户做分页展示" class="headerlink" title="如果是给用户做分页展示"></a>如果是给用户做分页展示</h4><p>如果深度分页背后的原始需求只是产品经理希望做一个展示页的功能，比如商品展示页，那么我们就应该好好跟产品经理battle一下了。</p><p>什么样的翻页，需要翻到10多万以后，这明显是不合理的需求。</p><p>是不是可以改一下需求，让它更接近用户的使用行为？</p><p>比如，我们在使用谷歌搜索时看到的翻页功能。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922231926176.png" alt="image-20230922231926176"></p><p>一般来说，谷歌搜索基本上都在20页以内，作为一个用户，我就很少会翻到第10页之后。</p><p>如果我们要做搜索或筛选类的页面的话，就别用mysql了，用es，并且也需要控制展示的结果数，比如一万以内，这样不至于让分页过深。</p><p>如果因为各种原因，必须使用mysql。那同样，也需要控制下返回结果数量，比如数量1k以内。</p><p>这样就能勉强支持各种翻页，跳页（比如突然跳到第6页然后再跳到第106页）。</p><p>但如果能从产品的形式上就做成不支持跳页会更好，比如只<strong>支持上一页或下一页</strong>。</p><p><img src="https://image.seeyourface.cn/migrate/image-20230922232056893.png" alt="image-20230922232056893"></p><p>通过上下页的形式我们就可以使用上面提到的<code>start_id</code>方式，采用分批获取，每批数据以<code>start_id</code>为起始位置。这个解法最大的好处是不管翻到多少页，查询速度永远稳定。</p><p>听起来很挫？</p><p>怎么会呢，把这个功能包装一下。</p><p>变成像抖音那样只能上划或下划，它有一个专业的名称叫<strong>瀑布流</strong>。</p><p>是不是瞬间就高大上了？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>limit offset, size</code> 比 <code>limit size</code> 要慢，且offset的值越大，sql的执行速度越慢。</li><li>当offset过大，会引发<strong>深度分页</strong>问题，目前不管是mysql还是es都没有很好的方法去解决这个问题。只能通过限制查询数量或分批获取的方式进行规避。</li><li>遇到深度分页的问题，多思考其原始需求，大部分时候是不应该出现深度分页的场景的，必要时多去影响产品经理。</li><li>如果数据量很少，比如1k的量级，且长期不太可能有巨大的增长，还是用<strong>limit offset, size</strong> 的方案吧，整挺好，能用就行。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/i6FL1iRECiWZ1CCf_juxQQ">https://mp.weixin.qq.com/s/i6FL1iRECiWZ1CCf_juxQQ</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>查询优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
