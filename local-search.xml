<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL的自增主键一定是连续的吗？</title>
    <link href="/2023/09/26/MySQL%E7%9A%84%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F/"/>
    <url>/2023/09/26/MySQL%E7%9A%84%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MySQL自增主键的作用是在自增列上定义一个主键，让主键的值由数据库系统自动分配，而不需要用户输入。这样可以避免主键重复或缺失，提高插入数据的效率，保持主键索引的递增顺序，减少<em>索引的碎片化</em>。</p><blockquote><p>索引的碎片化是指索引中的数据在物理存储上不连续，而是分散在磁盘上的不同位置。这样会导致查询需要更多的磁盘I&#x2F;O操作，降低查询性能和资源利用率。</p></blockquote><p>但实际上，MySQL的自增主键并不能保证一定是连续自增的。</p><p>先创建一张表，其中id为主键且自增，字段a创建了一个唯一索引。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926112247507.png" alt="image-20230926112247507"></p><h3 id="自增值保存在哪？"><a href="#自增值保存在哪？" class="headerlink" title="自增值保存在哪？"></a>自增值保存在哪？</h3><p>执行<code>insert test_incr(a, b) values(1,1);</code>插入一条数据；再执行<code>show create table test_incr;</code>命令查看表的结构。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926113445991.png" alt="image-20230926113445991"></p><p>上述表的结构定义存放在后缀名为 <code>.frm</code> 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 <code>.frm</code> 文件：</p><p><img src="https://blog.seeyourface.cn/blog/img-20230926113940.png" alt="img-20230926113940"></p><p>从上述表结构可以看到，表定义里面出现了一个 <code>AUTO_INCREMENT=2</code>，表示下一次插入数据时，如果需要自动生成自增值，会生成 id &#x3D; 2。</p><p>但需要注意的是，自增值并不会保存在这个表结构也就是 <code>.frm</code> 文件中，不同的引擎对于自增值的保存策略不同：</p><ol><li>MyISAM 引擎的自增值保存在数据文件中</li><li>InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 <code>max(id)</code>，然后将 <code>max(id)+1</code> 作为这个表当前的自增值。</li></ol><p>举个例子：现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT&#x3D;2对吧。这时候，我们删除 id&#x3D;1 的行，AUTO_INCREMENT 还是 2。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926114409154.png" alt="image-20230926114409154"></p><p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿也就是说，MySQL 重启可能会修改一个表的 <strong>AUTO_INCREMENT</strong> 的值。</p><p>我们趁MySQL不注意，使用<code>kill -9 pid</code>杀掉MySQL服务（主打的就是一个不讲武德），然后重启服务，再次执行<code>show create table test_incr;</code></p><p><img src="https://blog.seeyourface.cn/blog/image-20230926140109271.png" alt="image-20230926140109271"></p><p>此时我们发现<strong>AUTO_INCREMENT</strong>没有显示，是因为默认等于1不会展示。</p><p>以上测试基于MySQL数据库的<strong>5.7.36</strong>版本，存储引擎为<strong>INNODB</strong>。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926140417057.png" alt="image-20230926140417057"></p><p>实际上，到了 MySQL 8.0 版本后，自增值的变更记录被放在了 <strong>redo log</strong> 中，提供了自增值持久化的能力，也就是实现了“如果发生重启，表的自增值可以根据 redo  log 恢复为 MySQL 重启前的值”。</p><p>也就是对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。</p><p>理解了 MySQL 自增值到底保存在哪里以后，再来看看自增值的修改机制，并为大家介绍一些自增值不连续的场景，以下结论基于MySQL8，存储引擎INNODB。</p><h3 id="自增列指定值"><a href="#自增列指定值" class="headerlink" title="自增列指定值"></a>自增列指定值</h3><p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ul><li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li><li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li></ul><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 <code>insert_num</code>，当前的自增值是 <code>autoIncrement_num</code>：</p><ul><li>如果 <code>insert_num &lt; autoIncrement_num</code>，那么这个表的自增值不变</li><li>如果 <code>insert_num &gt;= autoIncrement_num</code>，就需要把当前自增值修改为新的自增值</li></ul><p>也就是说，如果插入的 id 是 100，当前的自增值是 90，<code>insert_num &gt;= autoIncrement_num</code>，那么自增值就会被修改为新的自增值即 101…</p><p>一定如此吗？</p><p>凡是没有绝对~~~</p><p>MySQL中是通过<code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 这两个参数来实现主键自增的，这俩分别用来表示自增的初始值和步长，默认值都是 1。</p><p>所以，上面的例子中生成新的自增值的步骤实际是这样的：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 100  的值，作为新的自增值。</p><p>也就是说，这种情况下，当步长不等于1时，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。</p><p>更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的。</p><h3 id="唯一键冲突"><a href="#唯一键冲突" class="headerlink" title="唯一键冲突"></a>唯一键冲突</h3><p>我们之前往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT&#x3D; 2。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926152320949.png" alt="image-20230926152320949"></p><p>这时我再执行一条插入 <code>(null,1,1)</code> 的命令，很显然会报错 <code>Duplicate entry</code>，因为我们设置了一个唯一索引字段 <code>a</code>：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926152525247.png" alt="image-20230926152525247"></p><p>但是我们可以发现，虽然插入失败了，AUTO_INCREMENT的值从2变为了3！</p><p>具体原因来分析下这个 insert 语句的执行流程：</p><ol><li>执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);</li><li>InnoDB 发现用户没有指定自增 id 的值，则获取表 <code>test_pk</code> 当前的自增值 2；</li><li>将传入的记录改成 (2,1,1);</li><li>将表的自增值改成 3；</li><li>继续执行插入数据操作，由于已经存在 a&#x3D;1 的记录，所以报 Duplicate key error，语句返回。</li></ol><p>可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。</p><p>这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id &#x3D; 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。</p><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><p>现在我们表里有一行 <code>(1,1,1)</code> 的记录，并且AUTO_INCREMENT &#x3D; 3：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926153207589.png" alt="image-20230926153207589"></p><p>然后我们手动开启事务，插入一条(null,2,2)的数据，再回滚。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926153412078.png" alt="image-20230926153412078"></p><p>显然，我们执行了插入语句，但是回滚了事务，所以数据库中并没有刚才的(null,2,2)数据。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926153917766.png" alt="image-20230926153917766"></p><p>但是我们可以发现自增值并没有同样发生回滚！如上图所示，自增值仍然固执地从 3 增加到了 4。</p><p>如果这时候我们再去插入一条数据（null, 2, 2）的时候，主键 id 就会被自动赋为 4 了：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926154213388.png" alt="image-20230926154213388"></p><p>所以，当出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去，回退回去的话不就不会发生自增 id 不连续了吗？这又是为什么呢？</p><p>其实，这么做的主要原因是为了提高性能。</p><p>我们可以假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？</p><p>现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后按请求顺序申请，对吧。</p><ol><li>假设事务 A 申请到了 id &#x3D; 1， 事务 B 申请到 id&#x3D;2，那么这时候表 t 的自增值是3，之后继续执行。</li><li>事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id &#x3D; 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id &#x3D; 2 的行，而当前的自增 id 值是 1。</li><li>接下来，继续执行的其他事务就会申请到 id&#x3D;2。这时，就会出现插入语句报错“主键冲突”。</li></ol><p><img src="https://blog.seeyourface.cn/blog/img_20230926155314.png" alt="img_20230926155314"></p><p>有两种方法可以解决这个主键冲突：</p><ol><li>每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id</li><li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id</li></ol><p>很显然，上述两个方法的成本都比较高，会导致性能问题。而原因就是我们假设的这个 “允许自增 id 回退”。</p><p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但<strong>不保证是连续的</strong>。</p><h3 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h3><p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p><ol><li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li><li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li><li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li><li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li></ol><p>注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！因为这类语句在申请自增 id 的时候，根据value的数量是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p><p>而对于 <code>insert … select</code>、<code>replace … select</code> 和 <code>load data</code> 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种<strong>批量申请</strong>的策略，毕竟一个一个申请的话实在太慢了。</p><p>举个例子，假设我们现在这个表有下面这些数据：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926162829910.png" alt="image-20230926162829910"></p><p>创建一张和当前表 <code>test_incr</code> 有相同结构定义的表 <code>test_incr2</code>：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926163210736.png" alt="image-20230926163210736"></p><p>然后使用 <code>insert...select</code> 往 <code>teset_incr2</code> 表中批量插入数据：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926163423686.png" alt="image-20230926163423686"></p><p>可以看到，成功导入了数据。</p><p>再来看下 <code>test_pk2</code> 的自增值是多少：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926163515786.png" alt="image-20230926163515786"></p><p>如上分析一致，是 8 而不是 6。</p><p>具体来说，<code>insert…select</code> 实际上往表中插入了 5 行数据 （1,1）（2,2）（3,3）（4,4）（5,5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：</p><ul><li>第一次申请到了一个 id：id&#x3D;1</li><li>第二次被分配了两个 id：id&#x3D;2 和 id&#x3D;3</li><li>第三次被分配到了 4 个 id：id&#x3D;4、id &#x3D; 5、id &#x3D; 6、id&#x3D;7</li></ul><p>由于这条语句实际只用上了 5 个 id，所以 id&#x3D;6 和 id&#x3D;7 就被浪费掉了。之后，再执行 <code>insert into test_incr2 values(null,6,6)</code>，实际上插入的数据就是（8,6,6)：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926163809960.png" alt="image-20230926163809960"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下自增值不连续的四个场景：</p><ol><li>自增初始值和自增步长设置不为 1。</li><li>唯一键冲突。</li><li>事务回滚。</li><li>批量插入（如 <code>insert...select</code> 语句）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK源码系列-LinkedList</title>
    <link href="/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-LinkedList/"/>
    <url>/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-LinkedList/</url>
    
    <content type="html"><![CDATA[<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文内容均以JDK8为例。</p><p><code>LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。</p><p><img src="https://blog.seeyourface.cn/blog/linkedList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="linkedList数据结构"></p><p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p><p><img src="https://blog.seeyourface.cn/blog/336a2145-32ef-497e.png" alt="336a2145-32ef-497e"></p><p>另外，<strong>不要</strong>下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) ，因为都需要先遍历到对应节点再进行增删操作。</p><h4 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h4><ul><li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持<strong>随机访问</strong>（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p><h4 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h4><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p><p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p><p><code>LinkedList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，<code>Deque</code> 的发音为 “deck” [dɛk]，这个大部分人都会读错。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化和反序列化操作，也就是即可以将<strong>对象序列化为字节流</strong>进行持久化存储或网络传输，也可以从<strong>字节流反序列化为对象</strong>，非常方便。</li></ul><p><img src="https://blog.seeyourface.cn/blog/image-20230924171241953.png" alt="image-20230924171241953"></p><p>与ArrayList不同的是，<code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>       <span class="hljs-comment">// 实际存储数据</span><br>       E item;<br>       <span class="hljs-comment">// 后继节点</span><br>       Node&lt;E&gt; next;<br>       <span class="hljs-comment">// 前驱节点</span><br>       Node&lt;E&gt; prev;<br><span class="hljs-comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span><br>       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>           <span class="hljs-built_in">this</span>.item = element;<br>           <span class="hljs-built_in">this</span>.next = next;<br>           <span class="hljs-built_in">this</span>.prev = prev;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个空的链表对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br><span class="hljs-comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>       <span class="hljs-built_in">this</span>();<br>       addAll(c);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p><code>LinkedList</code> 除了实现了 <code>List</code> 接口相关方法，还实现了 <code>Deque</code> 接口的很多方法，所以我们有很多种方式插入元素。</p><p>这里以 <code>List</code> 接口中相关的插入方法为例进行源码讲解，对应的是<code>add()</code> 方法。</p><p><code>add()</code> 方法有两个版本：</p><ul><li><code>add(E e)</code>：用于在 <code>LinkedList</code> 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。</li><li><code>add(int index, E element)</code>:用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n &#x2F; 2 个元素，时间复杂度为 O(n)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在链表尾部插入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表指定位置插入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 下标越界检查</span><br>    checkPositionIndex(index);<br><br>    <span class="hljs-comment">// 判断 index 是不是链表尾部位置</span><br>    <span class="hljs-keyword">if</span> (index == size)<br>        <span class="hljs-comment">// 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可</span><br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果不是则调用 linkBefore 方法将其插入指定元素之前</span><br>        linkBefore(element, node(index));<br>&#125;<br><br><span class="hljs-comment">// 将元素节点插入到链表尾部</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 将最后一个元素赋值（引用传递）给节点 l</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 将 last 引用指向新节点</span><br>    last = newNode;<br>    <span class="hljs-comment">// 判断尾节点是否为空</span><br>    <span class="hljs-comment">// 如果 l 是null 意味着这是第一次添加元素</span><br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span><br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span><br>        l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br><br><span class="hljs-comment">// 在指定元素之前插入元素</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br>    <span class="hljs-comment">// assert succ != null;断言 succ不为 null</span><br>    <span class="hljs-comment">// 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>    <span class="hljs-comment">// 初始化节点，并指明前驱和后继节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>    <span class="hljs-comment">// 将 succ 节点前驱引用 prev 指向新节点</span><br>    succ.prev = newNode;<br>    <span class="hljs-comment">// 判断尾节点是否为空，为空表示当前链表还没有节点</span><br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// succ 节点前驱的后继引用指向新节点</span><br>        pred.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><code>LinkedList</code>获取元素相关的方法一共有 3 个：</p><ol><li><code>getFirst()</code>：获取链表的第一个元素。</li><li><code>getLast()</code>：获取链表的最后一个元素。</li><li><code>get(int index)</code>：获取链表指定位置的元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取链表的第一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-comment">// 获取链表的最后一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> l.item;<br>&#125;<br><br><span class="hljs-comment">// 获取链表指定位置的元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>  <span class="hljs-comment">// 下标越界检查，如果越界就抛异常</span><br>  checkElementIndex(index);<br>  <span class="hljs-comment">// 返回链表中对应下标的元素</span><br>  <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br></code></pre></td></tr></table></figure><p>get(index)方法的核心在于 <code>node(int index)</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回指定下标的非空节点</span><br>Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 断言下标未越界</span><br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br>    <span class="hljs-comment">// 如果index小于size的二分之一  从前开始查找（向后查找）  反之向前查找</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-comment">// 遍历，循环向后查找，直至 i == index</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>get(int index)</code> 或 <code>remove(int index)</code> 等方法内部都调用了该方法来获取对应的节点。</p><p>从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><code>LinkedList</code>删除元素相关的方法一共有 5 个：</p><ol><li><code>removeFirst()</code>：删除并返回链表的第一个元素。</li><li><code>removeLast()</code>：删除并返回链表的最后一个元素。</li><li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li><li><code>void clear()</code>：移除此链表中的所有元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除并返回链表的第一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br><br><span class="hljs-comment">// 删除并返回链表的最后一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkLast(l);<br>&#125;<br><br><span class="hljs-comment">// 删除链表中首次出现的指定元素，如果不存在该元素则返回 fals</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果不为 null ,遍历链表找到要删除的节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除链表指定位置的元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 下标越界检查，如果越界就抛异常</span><br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的核心在于 <code>unlink(Node&lt;E&gt; x)</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>    <span class="hljs-comment">// 断言 x 不为 null</span><br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-comment">// 获取当前节点（也就是待删除节点）的元素</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<br>    <span class="hljs-comment">// 获取当前节点的下一个节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-comment">// 获取当前节点的前一个节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>    <span class="hljs-comment">// 如果前一个节点为空，则说明当前节点是头节点</span><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 维护链表头指向当前节点的下一个节点</span><br>        first = next;<br>    <span class="hljs-comment">// 如果前一个节点不为空    </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将前一个节点的 next 指针指向当前节点的下一个节点</span><br>        prev.next = next;<br>        <span class="hljs-comment">// 将当前节点的 prev 指针置为 null，，方便 GC 回收</span><br>        x.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果下一个节点为空，则说明当前节点是尾节点</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 维护链表尾指向当前节点的前一个节点</span><br>        last = prev;<br>    <span class="hljs-comment">// 如果下一个节点不为空    </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将下一个节点的 prev 指针指向当前节点的前一个节点</span><br>        next.prev = prev;<br>        <span class="hljs-comment">// 将当前节点的 next 指针置为 null，方便 GC 回收</span><br>        x.next = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将当前节点元素置为 null，方便 GC 回收</span><br>    x.item = <span class="hljs-literal">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unlink()</code> 方法的逻辑如下：</p><ol><li><p>首先获取待删除节点 x 的前驱和后继节点；</p></li><li><p>判断待删除节点是否为头节点或尾节点： </p><ul><li><p>如果 x 是头节点，则将 first 指向 x 的后继节点 next</p></li><li><p>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</p></li><li><p>如果 x 不是头节点也不是尾节点，执行下一步操作</p></li></ul></li><li><p>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</p></li><li><p>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</p></li><li><p>将待删除节点 x 的元素置空，修改链表长度。</p></li></ol><p>参考下图理解：</p><p><img src="https://blog.seeyourface.cn/blog/LinkedList%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91.jpg" alt="LinkedList删除节点逻辑"></p><h4 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h4><p>推荐使用<code>for-each</code> 循环来遍历 <code>LinkedList</code> 中的元素， <code>for-each</code> 循环最终会转换成迭代器形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;pear&quot;</span>);<br><br><span class="hljs-keyword">for</span> (String fruit : list) &#123;<br>    System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LinkedList</code> 的遍历的核心就是它的迭代器的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 双向迭代器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListItr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 表示上一次调用 next() 或 previous() 方法时经过的节点；</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; lastReturned;<br>    <span class="hljs-comment">// 表示下一个要遍历的节点；</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; next;<br>    <span class="hljs-comment">// 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> nextIndex;<br>    <span class="hljs-comment">// 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>    …………<br>&#125;<br></code></pre></td></tr></table></figure><p>下面对迭代器 <code>ListItr</code> 中的核心方法进行详细介绍。</p><p>我们先来看下从头到尾方向的迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断还有没有下一个节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历</span><br>    <span class="hljs-keyword">return</span> nextIndex &lt; size;<br>&#125;<br><br><span class="hljs-comment">// 获取下一个节点</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查在迭代过程中链表是否被修改过</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常</span><br>    <span class="hljs-keyword">if</span> (!hasNext())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-comment">// 将 lastReturned 指向当前节点</span><br>    lastReturned = next;<br>    <span class="hljs-comment">// 将 next 指向下一个节点</span><br>    next = next.next;<br>    nextIndex++;<br>    <span class="hljs-keyword">return</span> lastReturned.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看一下从尾到头方向的迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否还有前一个节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextIndex &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取前一个节点</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">previous</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是否在迭代过程中链表被修改</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 如果没有前一个节点，则抛出异常</span><br>    <span class="hljs-keyword">if</span> (!hasPrevious())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-comment">// 将 lastReturned 和 next 指针指向上一个节点</span><br>    lastReturned = next = (next == <span class="hljs-literal">null</span>) ? last : next.prev;<br>    nextIndex--;<br>    <span class="hljs-keyword">return</span> lastReturned.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要删除或插入元素，也可以使用迭代器进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>list.add(<span class="hljs-literal">null</span>);<br>list.add(<span class="hljs-string">&quot;banana&quot;</span>);<br><br><span class="hljs-comment">// Collection 接口的 removeIf 方法底层依然是基于迭代器</span><br>list.removeIf(Objects::isNull);<br><br><span class="hljs-keyword">for</span> (String fruit : list) &#123;<br>    System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器对应的移除元素的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从列表中删除上次被返回的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是否在迭代过程中链表被修改</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 如果上次返回的节点为空，则抛出异常</span><br>    <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br><br>    <span class="hljs-comment">// 获取当前节点的下一个节点</span><br>    Node&lt;E&gt; lastNext = lastReturned.next;<br>    <span class="hljs-comment">// 从链表中删除上次返回的节点</span><br>    unlink(lastReturned);<br>    <span class="hljs-comment">// 修改指针</span><br>    <span class="hljs-keyword">if</span> (next == lastReturned)<br>        next = lastNext;<br>    <span class="hljs-keyword">else</span><br>        nextIndex--;<br>    <span class="hljs-comment">// 将上次返回的节点引用置为 null，方便 GC 回收</span><br>    lastReturned = <span class="hljs-literal">null</span>;<br>    expectedModCount++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK源码系列-ArrayList</title>
    <link href="/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/"/>
    <url>/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/</url>
    
    <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文内容均以JDK8为例。</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>RandomAccess</code> : 这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化和反序列化操作，也就是即可以将<strong>对象序列化为字节流</strong>进行持久化存储或网络传输，也可以从<strong>字节流反序列化为对象</strong>，非常方便。</li></ul><p><img src="https://blog.seeyourface.cn/blog/image-20230924112821522.png" alt="image-20230924112821522"></p><p><code>ArrayList</code> 的底层是数组队列，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的优点是容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这样可以减少递增式再分配的数量，提高程序执行的效率。</p><h4 id="ArrayList和Vector的区别？"><a href="#ArrayList和Vector的区别？" class="headerlink" title="ArrayList和Vector的区别？"></a>ArrayList和Vector的区别？</h4><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全。</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，通过<em>synchronized</em>关键字保证线程安全。</li></ul><h4 id="ArrayList可以添加null值吗？"><a href="#ArrayList可以添加null值吗？" class="headerlink" title="ArrayList可以添加null值吗？"></a>ArrayList可以添加null值吗？</h4><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。但是不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， 因为<code>null</code> 值无意义，会让代码难以维护例如忘记做判空处理就会导致<strong>空指针</strong>异常。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230924114702452.png" alt="image-20230924114702452"></p><h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h4><ul><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都不是同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为双向循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行<strong>向后位&#x2F;向前</strong>移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先<strong>移动到指定位置</strong>再插入和删除。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。本质是因为<code>LinkedList</code>元素的存储不是连续的。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h4 id="ArrayList核心源码"><a href="#ArrayList核心源码" class="headerlink" title="ArrayList核心源码"></a>ArrayList核心源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.UnaryOperator;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认初始容量大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空数组（用于空实例）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 用于默认大小空实例的共享空数组实例。</span><br><span class="hljs-comment">     * 目的是把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span><br><span class="hljs-comment">     */</span> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存ArrayList数据的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList 所包含的元素个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span><br>            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数等于0，创建空数组</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//其他情况，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认无参构造函数</span><br><span class="hljs-comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        <span class="hljs-comment">//将指定集合转换为数组</span><br>        elementData = c.toArray();<br>        <span class="hljs-comment">//如果elementData数组的长度不为0</span><br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                <span class="hljs-comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span><br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// elementData数组长度为0，用空数组代替</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>            elementData = (size == <span class="hljs-number">0</span>)<br>              ? EMPTY_ELEMENTDATA<br>              : Arrays.copyOf(elementData, size);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//下面是ArrayList的扩容机制</span><br><span class="hljs-comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><br><span class="hljs-comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>            <span class="hljs-comment">// any size if not default element table</span><br>            ? <span class="hljs-number">0</span><br>            <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>            <span class="hljs-comment">// supposed to be at default size.</span><br>            : DEFAULT_CAPACITY;<br>        <span class="hljs-comment">//如果最小容量大于已有的最大容量</span><br>        <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>            ensureExplicitCapacity(minCapacity);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//1.得到最小扩容量</span><br>    <span class="hljs-comment">//2.通过最小容量扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>              <span class="hljs-comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span><br>            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br><br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>    <br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>            grow(minCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要分配的最大数组大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity / 2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span><br>        <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span><br>        <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br>    <br>    <span class="hljs-comment">//比较minCapacity和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回此列表中的元素数。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表不包含元素，则返回 true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//注意=和==的区别</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表包含指定的元素，则返回true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br>        <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-comment">//equals()方法比较</span><br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span><br>            v.elementData = Arrays.copyOf(elementData, size);<br>            v.modCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">// 这不应该发生，因为我们是可以克隆的</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span><br><span class="hljs-comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span><br><span class="hljs-comment">     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span><br><span class="hljs-comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span><br><span class="hljs-comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span><br><span class="hljs-comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span><br><span class="hljs-comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">if</span> (a.length &lt; size)<br>            <span class="hljs-comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span><br>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>            <span class="hljs-comment">//调用System提供的arraycopy()方法实现数组之间的复制</span><br>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-comment">// 这段逻辑的目的是在将列表元素复制到数组后，如果数组的长度大于列表的大小（即列表中的元素个数），则将数组中多余的元素位置置为 null。</span><br>        <span class="hljs-comment">// 这样做是为了避免在后续的代码中可能导致混淆或错误的情况。</span><br>        <span class="hljs-comment">// 例如 list = &#123;&quot;java&quot;, &quot;c&quot;&#125; a = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125; 返回的数组为 &#123;&quot;java&quot;, &quot;c&quot;, null, &quot;4&quot;, &quot;5&quot;&#125;</span><br>        <span class="hljs-comment">// 这样就可以避免混淆list中的元素和a数组中的旧元素</span><br>        <span class="hljs-keyword">if</span> (a.length &gt; size)<br>            a[size] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-comment">// Positional Access Operations</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用指定的元素替换此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        <span class="hljs-comment">//对index进行界限检查</span><br>        rangeCheck(index);<br><br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>        elementData[index] = element;<br>        <span class="hljs-comment">//返回原来在这个位置的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span><br>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                         size - index);<br>        elementData[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        modCount++;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-comment">//从列表中删除的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span><br><span class="hljs-comment">     * 返回true，如果此列表包含指定的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Private remove method that skips bounds checking and does not</span><br><span class="hljs-comment">     * return the value removed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// 把数组中所有的元素的值设为null</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            elementData[i] = <span class="hljs-literal">null</span>;<br><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index, elementData, index + numNew,<br>                             numMoved);<br><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span><br><span class="hljs-comment">     * 将任何后续元素移动到左侧（减少其索引）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - toIndex;<br>        System.arraycopy(elementData, toIndex, elementData, fromIndex,<br>                         numMoved);<br><br>        <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> size - (toIndex-fromIndex);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> newSize; i &lt; size; i++) &#123;<br>            elementData[i] = <span class="hljs-literal">null</span>;<br>        &#125;<br>        size = newSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查给定的索引是否在范围内。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * add和addAll使用的rangeCheck的一个版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回IndexOutOfBoundsException细节信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Index: &quot;</span>+index+<span class="hljs-string">&quot;, Size: &quot;</span>+size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除指定集合中包含的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-comment">//如果此列表被修改则返回true</span><br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 仅保留此列表中包含在指定集合中的元素。</span><br><span class="hljs-comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span><br><span class="hljs-comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span>+index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *以正确的顺序返回该列表中的元素的迭代器。</span><br><span class="hljs-comment">     *返回的迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h4><p>先从 ArrayList 的构造函数说起，ArrayList 有三种方式来初始化，构造方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认初始容量大小</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br> &#125;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>     <span class="hljs-comment">//初始容量大于0</span><br>     <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// 创建initialCapacity大小的数组</span><br>         <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>     <span class="hljs-comment">//初始容量等于0</span><br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// 创建空数组</span><br>         <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>     <span class="hljs-comment">//初始容量小于0，抛出异常    </span><br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                            initialCapacity);<br>     &#125;<br> &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span><br><span class="hljs-comment"> * 如果指定的集合为null，throws NullPointerException。</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>     elementData = c.toArray();<br>     <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>         <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>             elementData = Arrays.copyOf(elementData, size, Object[].class);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// replace with empty array.</span><br>         <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>以无参数构造方法创建</strong> <code>ArrayList</code> <strong>时，实际上初始化赋值的是一个空数组。</strong></p><p><strong>当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </p><blockquote><p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData </p></blockquote><h5 id="逐步分析-ArrayList-扩容机制"><a href="#逐步分析-ArrayList-扩容机制" class="headerlink" title="逐步分析 ArrayList 扩容机制"></a>逐步分析 ArrayList 扩容机制</h5><p>这里以无参构造函数创建的 ArrayList 为例分析</p><h6 id="先来看-add-方法"><a href="#先来看-add-方法" class="headerlink" title="先来看 add 方法"></a>先来看 <code>add</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal方法</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h6 id="再来看看-ensureCapacityInternal-方法"><a href="#再来看看-ensureCapacityInternal-方法" class="headerlink" title="再来看看 ensureCapacityInternal() 方法"></a>再来看看 <code>ensureCapacityInternal()</code> 方法</h6><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 方法里面调用calculateCapacity获取最小容量</span><br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="calculateCapacity-方法"><a href="#calculateCapacity-方法" class="headerlink" title="calculateCapacity()方法"></a>calculateCapacity()方法</h6><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算最小容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-comment">// 如果是无参构造，elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA为true</span><br>       <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>           <span class="hljs-comment">// 这里取1和DEFAULT_CAPACITY的较大值，也就是10</span><br>           <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>       &#125;<br>       <span class="hljs-keyword">return</span> minCapacity;<br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity()方法"></a>ensureExplicitCapacity()方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       modCount++;<br><br>       <span class="hljs-comment">// overflow-conscious code</span><br>       <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>           <span class="hljs-comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>           grow(minCapacity);<br>   &#125;<br></code></pre></td></tr></table></figure><p>我们来仔细分析一下这个过程：</p><ul><li><p>当我们要 add 进第 1 个元素到 ArrayList 时，<code>elementData.length</code> 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</p></li><li><p>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</p></li><li><p>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</p></li><li><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p></li></ul><h6 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a><code>grow()</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 要分配的最大数组大小</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// ArrayList核心扩容方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>       <span class="hljs-comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity / 2，</span><br>       <span class="hljs-comment">// 因为位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍。</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>       <span class="hljs-comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span><br>       <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>           newCapacity = minCapacity;<br>       <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE, 进入`hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE</span><br>       <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>       <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>           newCapacity = hugeCapacity(minCapacity);<br>       <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>       elementData = Arrays.copyOf(elementData, newCapacity);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1), 所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数。</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt; 1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 右移了 1 位所以相当于 oldCapacity &#x2F; 2。对于大数据的 二进制运算, 位移运算符比那些普通运算符的运算要快很多，因为程序底层都是基于二进制所以程序仅仅是移动一下而已，不用去计算，这样提高了效率，节省了资源。</p></blockquote><p><strong>我们再来通过例子探究一下</strong><code>grow()</code> <strong>方法：</strong></p><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true，size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true，size 增为 11。</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li><p>java 中的 <code>length</code>属性是针对数组说的，比如说你声明了一个数组，想知道这个数组的长度则用到了 length 这个属性。</p></li><li><p>java 中的 <code>length()</code> 方法是针对字符串说的，如果想看这个字符串的长度则用到 <code>length()</code> 这个方法。</p></li><li><p>java 中的 <code>size()</code> 方法是针对泛型集合说的，如果想看这个泛型有多少个元素，就调用此方法来查看！</p></li></ul><h6 id="hugeCapacity-方法。"><a href="#hugeCapacity-方法。" class="headerlink" title="hugeCapacity() 方法。"></a><code>hugeCapacity()</code> 方法。</h6><p>从上面 <code>grow()</code> 方法源码我们知道：如果新容量大于 <code>MAX_ARRAY_SIZE</code>，进入(执行) hugeCapacity() 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>       <span class="hljs-comment">// 对minCapacity和MAX_ARRAY_SIZE进行比较</span><br>       <span class="hljs-comment">// 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br>       <span class="hljs-comment">// 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br>       <span class="hljs-comment">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>       <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>           Integer.MAX_VALUE :<br>           MAX_ARRAY_SIZE;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf()方法"></a><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h5><p>通过上面的源码，我们会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h6 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy() 方法"></a><code>System.arraycopy()</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos,</span><br><span class="hljs-params">                                    Object dest, <span class="hljs-type">int</span> destPos,</span><br><span class="hljs-params">                                    <span class="hljs-type">int</span> length)</span>;<br></code></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment"> * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment"> * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheckForAdd(index);<br><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// arraycopy()方法实现数组自己复制自己</span><br>    <span class="hljs-comment">// elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf()方法"></a><code>Arrays.copyOf()</code>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 复制指定的数组，截断或填充 null（如有必要），以便副本具有指定的长度。对于在原始数组和副本中都有效的所有索引，这两个数组将包含相同的值。</span><br><span class="hljs-comment">   * 对于在副本中有效但对原始副本无效的任何索引，副本将包含 null。当且仅当指定的长度大于原始数组的长度时，此类索引才会存在。</span><br><span class="hljs-comment">   * 生成的数组与原始数组的类完全相同。 </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">* @param original 源对象数组，需要被复制的数组</span><br><span class="hljs-comment">   * @param newLength 要返回的副本的长度</span><br><span class="hljs-comment">   * @return 原始数组的副本，截断或填充空值获取指定长度</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOf(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> newLength) &#123;<br>   <span class="hljs-comment">// 申请一个新的数组</span><br>       <span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[newLength];<br><span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span><br>       System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                        Math.min(original.length, newLength));<br>       <span class="hljs-keyword">return</span> copy;<br>   &#125;<br></code></pre></td></tr></table></figure><p>再举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span><br><span class="hljs-comment"> * 返回的数组的运行时类型是指定数组的运行时类型。</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br> <span class="hljs-comment">//elementData：要复制的数组；size：要复制的长度</span><br>     <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br> &#125;<br></code></pre></td></tr></table></figure><h6 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h6><p><strong>联系：</strong>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h5 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a><code>ensureCapacity</code>方法</h5><p><code>ArrayList</code> 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 <code>ArrayList</code> 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>        <span class="hljs-comment">// any size if not default element table</span><br>        ? <span class="hljs-number">0</span><br>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>        <span class="hljs-comment">// supposed to be at default size.</span><br>        : DEFAULT_CAPACITY;<br><br>    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>意思是，我们在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity</code> 方法将容量扩容至可以容纳元素的大小，以减少增量时重新分配的次数。</p><p>通过下面的代码实际测试以下这个方法的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>           list.add(i);<br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;使用ensureCapacity方法前：&quot;</span> + (endTime - startTime));<br>   &#125;<br><br><span class="hljs-comment">// 执行五次分别获得的结果</span><br><span class="hljs-comment">// 使用ensureCapacity方法前：2295, 2291, 2308, 2305, 2306</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">startTime1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>   <span class="hljs-comment">// 使用ensureCapacity方法</span><br>       list.ensureCapacity(N);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>           list.add(i);<br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">endTime1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;使用ensureCapacity方法后：&quot;</span> + (endTime1 - startTime1));<br>   &#125;<br><br><span class="hljs-comment">// 执行五次分别获得的结果</span><br><span class="hljs-comment">// 使用ensureCapacity方法前：2163, 2113, 2156, 2150, 2164</span><br></code></pre></td></tr></table></figure><p>通过运行结果，可以看出向 <code>ArrayList</code> 添加大量元素之前使用<code>ensureCapacity</code> 方法可以稍稍提升性能。</p><p>不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 <code>ArrayList</code> 里面添加这么多元素。</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么ConcurrentHashMap的key/value不能为空，HashMap可以？</title>
    <link href="/2023/09/23/%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E7%9A%84keyvalue%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8CHashMap%E5%8F%AF%E4%BB%A5%EF%BC%9F/"/>
    <url>/2023/09/23/%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E7%9A%84keyvalue%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8CHashMap%E5%8F%AF%E4%BB%A5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么ConcurrentHashMap的key-value不能为空，HashMap可以？"><a href="#为什么ConcurrentHashMap的key-value不能为空，HashMap可以？" class="headerlink" title="为什么ConcurrentHashMap的key&#x2F;value不能为空，HashMap可以？"></a>为什么ConcurrentHashMap的key&#x2F;value不能为空，HashMap可以？</h3><p>以JDK8为例，在ConcurrentHashMap源码的<code>putVal</code>方法中当传入的参数key或者value为null时，会抛出<code>NullPointerException</code></p><img src="https://blog.seeyourface.cn/blog/image-20230923222339494.png" alt="image-20230923222339494" style="zoom: 67%;" /><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。</p><p>null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 ConcurrentHashMap 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 ConcurrentHashMap 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，<strong>存在</strong>一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以<strong>无法通过</strong> <code>containsKey(key)</code> 来判断否存在这个键值对，也就没<strong>办法解决二义性</strong>问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，<strong>不存在</strong>一个线程操作该 <code>HashMap</code> 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，<strong>多线程下无法正确判定键值对是否存在</strong>（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果确实需要在 <code>ConcurrentHashMap</code> 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">NULL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><hr><p>关于<code>ConcurrentHashMap</code> 作者本人 (Doug Lea)对于这个问题做出的回答：</p><blockquote><p>The main reason that nulls aren’t allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) is that ambiguities that may be just barely tolerable in non-concurrent maps can’t be accommodated. The main one is that if map.get(key) returns null, you can’t detect whether the key explicitly maps to null vs the key isn’t mapped. In a non-concurrent map, you can check this via map.contains(key), but in a concurrent one, the map might have changed between calls.</p></blockquote><p>翻译：</p><p>ConcurrentMaps（ConcurrentHashMaps、ConcurrentSkipListMaps）中不允许使用 null 的主要原因是，无法容纳在非并发映射中勉强可以容忍的歧义。主要的一点是，如果map.get(key)返回null，你无法检测该键是否显式映射到null与该键是否未映射。在非并发映射中，您可以通过 map.contains(key) 检查这一点，但在并发映射中，映射可能在<strong>调用之间</strong>发生了变化。</p><h4 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h4><p>那么<strong>问题来了</strong>，你有可能会问：八股我都背烂了<code>ConcurrentHashMap</code>不是线程安全的吗，为什么会有其他线程造成影响？</p><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证<strong>多个线程同时对它进行读写操作</strong>时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 HashMap 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p><p>复合操作是指由多个<strong>基本操作</strong>(如put、get、remove、containsKey等)组成的操作，例如先判断某个键是否存在<strong>containsKey(key)<strong>，然后根据结果进行插入或更新</strong>put(key, value)<strong>。这种操作在执行过程中可能会被其他线程</strong>打断</strong>，导致结果不符合预期。</p><p>例如，有两个线程 A 和 B 同时对 <code>ConcurrentHashMap</code> 进行复合操作，如下：</p><img src="https://blog.seeyourface.cn/blog/image-20230923224919178.png" alt="image-20230923224919178" style="zoom: 67%;" /><p>如果线程 A 和 B 的执行顺序是这样：</p><ol><li>线程 A 判断 map 中不存在 key</li><li>线程 B 判断 map 中不存在 key</li><li>线程 B 将 (key, anotherValue) 插入 map</li><li>线程 A 将 (key, value) 插入 map</li></ol><p>那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是<strong>复合操作的非原子性</strong>导致的问题。</p><h4 id="那如何保证-ConcurrentHashMap-复合操作的原子性呢？"><a href="#那如何保证-ConcurrentHashMap-复合操作的原子性呢？" class="headerlink" title="那如何保证 ConcurrentHashMap 复合操作的原子性呢？"></a>那如何保证 ConcurrentHashMap 复合操作的原子性呢？</h4><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 putIfAbsent、compute、computeIfAbsent 、computeIfPresent、merge等。</p><p>这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p><img src="https://blog.seeyourface.cn/blog/image-20230923225542922.png" alt="image-20230923225542922" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ConcurrentHashMap</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK工具使用指南</title>
    <link href="/2023/09/23/JDK%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/09/23/JDK%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="JDK工具使用指南"><a href="#JDK工具使用指南" class="headerlink" title="JDK工具使用指南"></a>JDK工具使用指南</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p><strong>该命令用于打印当前JVM中运行的Java进程状态信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jps [options] [<span class="hljs-built_in">hostid</span>]<br></code></pre></td></tr></table></figure><p><code>options</code>表示命令可选参数：</p><ul><li>-q：仅显示pid</li><li>-m：显示进程pid及main方法参数</li><li>-l：打印进程对应JAR文件所在的完整路径名</li><li>-v：查看进程pid及JVM参数</li><li>-h：打印帮助信息</li></ul><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p><strong>用于打印全部参数和系统属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jinfo [options] &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-[pid]：输出全部参数</li><li>-flag [name] pid：打印对应名称的参数内容</li><li>-flag [+|-] [name] pid：不重启虚拟机的情况下，动态修改JVM参数</li><li>-flag [name]&#x3D;[value]：不重启虚拟机的情况下，动态修改JVM参数</li></ul><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p><strong>对Java应用程序的性能和资源进行实时监控，包括Heap和垃圾回收状态的监控</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstat -[options] [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]<br></code></pre></td></tr></table></figure><p>其中，vmid为虚拟机id，Liunx&#x2F;Unix一般为pid，interval为采样间隔（ms），count为采样数</p><p><code>jstat -gc 54231 1000 3</code> 表示每隔1000ms打印一次pid为54231的进程GC信息，总共打印三次</p><p>options表示命令可选参数：</p><ul><li><p>-class：显示加载class的数量及所占空间等信息</p></li><li><p>-compiler：JIT即时编译器相关的统计信息</p></li><li><p>-gc：打印GC信息（展开查看参数说明）</p></li><li><p>-gccapacity：打印各个内存池分代空间的容量</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>NGCMN</td><td>年轻代(young)中初始化(最小)的大小(字节)</td></tr><tr><td>NGCMX</td><td>年轻代(young)的最大容量(字节)</td></tr><tr><td>NGC</td><td>年轻代(young)中当前的容量(字节)</td></tr><tr><td>S0C</td><td>年轻代中第一个survivor（幸存区）的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个survivor（幸存区）的容量(字节)</td></tr><tr><td>EC</td><td>年轻代中Eden（伊甸园）的容量(字节)</td></tr><tr><td>OGCMN</td><td>old代中初始化(最小)的大小(字节)</td></tr><tr><td>OGCMX</td><td>old代的最大容量(字节)</td></tr><tr><td>OGC</td><td>old代当前新生成的容量(字节)</td></tr><tr><td>OC</td><td>Old代的容量(字节)</td></tr><tr><td>MCMN</td><td>Metaspace 区初始化 ( 最小 ) 容量 (字节)</td></tr><tr><td>MCMX</td><td>Metaspace 区的最大容量(字节)</td></tr><tr><td>MC</td><td>当前 Metaspace 的容量(字节)</td></tr><tr><td>CCSMN</td><td>最小压缩类空间大小(字节)</td></tr><tr><td>CCMSX</td><td>最大压缩类空间大小(字节)</td></tr><tr><td>CCSC</td><td>当前压缩类空间大小(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中GC(minor GC)次数</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时old代GC(full GC)次数</td></tr></tbody></table></li><li><p>-gcutil：GC相关区域的使用率统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>S0</td><td>年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</td></tr><tr><td>S1</td><td>年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</td></tr><tr><td>E</td><td>年轻代中Eden（伊甸园）已使用的占当前容量百分比</td></tr><tr><td>O</td><td>old代已使用的占当前容量百分比</td></tr><tr><td>M</td><td>Metaspace代已使用的占当前容量百分比</td></tr><tr><td>CCS</td><td>压缩区已使用的占当前容量百分比</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中gc所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时gc用的总时间(s)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时old代(全gc)gc次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时old代(全gc)gc所用时间(s)</td></tr></tbody></table></li><li><p>-gccause：查看上次GC和本次GC（如果正在GC）产生的原因，参数同-gcutil</p></li><li><p>-gcnew：年轻代的统计信息</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>S0C</td><td>年轻代中第一个survivor（幸存区）的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个survivor（幸存区）的容量(字节)</td></tr><tr><td>S0U</td><td>年轻代中第一个survivor（幸存区）目前已使用空间(字节)</td></tr><tr><td>S1U</td><td>年轻代中第二个survivor（幸存区）目前已使用空间(字节)</td></tr><tr><td>TT</td><td>持有次数限制(默认15)</td></tr><tr><td>MTT</td><td>Maximum tenuring threshold，可以通过-XX:MaxTenuringThreshold&#x3D;N设置，默认为15</td></tr><tr><td>DSS</td><td>Desired survivor size，单位为KB，这个值默认为Survivor区的50%</td></tr><tr><td>EC</td><td>年轻代中Eden（伊甸园）的容量(字节)</td></tr><tr><td>EU</td><td>年轻代中Eden（伊甸园）目前已使用空间(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中gc所用时间(s)</td></tr></tbody></table></li><li><p>-gcoldcapacity：老年代空间大小统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>OGCMN</td><td>老年代最小容量</td></tr><tr><td>OGCMX</td><td>老年代最大容量</td></tr><tr><td>OGC</td><td>当前老年代大小</td></tr><tr><td>OC</td><td>老年代大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table></li><li><p>-gcmetacapacity：meta区大小统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>MCMN</td><td>最小元数据容量</td></tr><tr><td>MCMX</td><td>最大元数据容量</td></tr><tr><td>MC</td><td>当前元空间大小</td></tr><tr><td>CCSMN</td><td>最小压缩类空间大小</td></tr><tr><td>CCSMX</td><td>最大压缩类空间大小</td></tr><tr><td>CCSC</td><td>当前压缩类空间大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table></li><li><p>-printcompilation：打印JVM编译统计信息</p></li></ul><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p><strong>用于查看堆内存的情况，或者将堆内存输出为二进制文本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap [option] &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li><p>-heap：打印堆内存配置和使用情况</p></li><li><p>-histo：打印堆内存中的对象大小、数量</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>num</td><td>序号</td></tr><tr><td>instances</td><td>实例个数</td></tr><tr><td>bytes</td><td>字节数</td></tr><tr><td>class_name</td><td>类名</td></tr></tbody></table></li><li><p><code>-dump:format=b,file=[filename].hprof</code> ：dump堆内存到hprof文件</p></li></ul><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p><strong>用于访问jmap命令生产的dump文件，通过浏览器访问</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jhat [options] &lt;dump-file&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-port：指定jhat的http服务端口，默认7000</li></ul><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p><strong>用于查看指定Java进程pid的堆栈信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstack [options]<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-F：强制线程转储。当jstack 没有响应(进程挂起)时使用</li><li>-m：打印Java和底层C&#x2F;C++框架所有栈信息</li><li>-l(小写L)：长列表模式，打印锁的附加信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL分页怎么优化？</title>
    <link href="/2023/09/22/MySQL%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F/"/>
    <url>/2023/09/22/MySQL%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>我们刷网站的时候，我们经常会遇到需要分页查询的场景。</p><p>比如下图谷歌的翻页功能。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922223517480.png" alt="image-20230922223517480"></p><p>我们很容易能联想到可以用MySQL实现。</p><p>假设我们的建表SQL是这样的:</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922224514427.png" alt="image-20230922224514427"></p><p>建表SQL大家也不用扣细节，只需要知道<strong>id是主键，并且在user_name建了个非主键索引</strong>就够了，其他都不重要。</p><p>为了实现分页。</p><p>很容易联想到下面这样的SQL语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-keyword">offset</span>, size;<br></code></pre></td></tr></table></figure><p>打个比方我们一页需要10条数据。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922224640869.png" alt="image-20230922224640869"></p><p>第一页就是下面这样的sql语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>第一百页就是:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">990</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>那么问题来了。</p><p>用这种方式，<strong>同样都是拿10条数据，查第一页和第一百页的查询速度是一样的吗？为什么？</strong></p><h3 id="两种limit的执行过程"><a href="#两种limit的执行过程" class="headerlink" title="两种limit的执行过程"></a>两种limit的执行过程</h3><p>上面的两种查询方式。对应 <code>limit offset, size</code> 和 <code>limit size</code> 两种方式。</p><p>而其实 <code>limit size</code> ，相当于 <code>limit 0, size</code>。也就是从0开始取size条数据</p><p>也就是说，两种方式的<strong>区别在于offset是否为0</strong>。</p><p>先来看下<code>limit sql</code>的内部执行逻辑。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922225317030.png" alt="image-20230922225317030"></p><p>mysql内部分为<strong>server层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用innodb。</p><p>server层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件</p><p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他where条件），则会放到<strong>结果集</strong>中，最后返回给调用mysql的<strong>客户端（go、java写的应用程序）</strong>。</p><p>我们可以对下面的sql先执行下 <code>explain</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>可以看到，explain中提示 key 那里，执行的是<strong>PRIMARY</strong>，也就是走的<strong>主键索引</strong>。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922225605773.png" alt="image-20230922225605773"></p><p>主键索引本质是一棵B+树，它是放在innodb中的一个数据结构。</p><p>我们可以回忆下，B+树大概长这样。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922225637429.png" alt="image-20230922225637429"></p><p>在这个树状结构里，我们需要关注的是，最下面一层节点，也就是<strong>叶子结点</strong>。而这个叶子结点里放的信息会根据当前的索引是<strong>主键索引还是非主键索引</strong>有所不同。</p><ul><li>如果是<strong>主键索引</strong>，它的叶子节点会存放完整的行数据信息。</li><li>如果是<strong>非主键索引</strong>，那它的叶子节点则会存放主键，如果想获得行数据信息，则需要再跑到主键索引去拿一次数据，这叫<strong>回表</strong>。</li></ul><p>比如执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">where</span> user_name <span class="hljs-operator">=</span> &quot;小白10&quot;;<br></code></pre></td></tr></table></figure><p>会通过非主键索引去查询<strong>user_name</strong>为”小白10”的数据，然后在叶子结点里找到**”小白10**”的数据对应的<strong>主键为10</strong>。</p><p>此时回表到<strong>主键索引</strong>中做查询，最后定位到<strong>主键为10的行数据</strong>。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922230006225.png" alt="image-20230922230006225"></p><p>但不管是主键还是非主键索引，他们的叶子结点数据都是<strong>有序的</strong>。比如在主键索引中，这些数据是根据主键id的大小，从小到大，进行排序的。</p><h4 id="基于主键索引的limit执行过程"><a href="#基于主键索引的limit执行过程" class="headerlink" title="基于主键索引的limit执行过程"></a>基于主键索引的limit执行过程</h4><p>回到文章开头的问题里，当我们去掉<code>explain</code>，执行这条sql。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sq">select * from page order by id limit 0, 10;<br></code></pre></td></tr></table></figure><p>上面select后面带的是<strong>星号</strong>，也就是要求获得行数据的所有字段信息。</p><p>server层会调用innodb的接口，在innodb里的主键索引中获取到第0到10条<strong>完整行数据</strong>，依次返回给server层，并放到server层的结果集中，返回给客户端。</p><p>而当我们把<code>offset</code>搞离谱点，比如执行的是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">6000000</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>server层会调用innodb的接口，由于这次的offset&#x3D;6000000，会在innodb里的主键索引中获取到第0到（6000000 + 10）条<strong>完整行数据，返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条</strong>，也就是10条数据，放到server层的结果集中，返回给客户端。</p><p>可以看出，当offset非0时，server层会从引擎层获取到很多无用的数据，而获取的这些无用数据都是要耗时的。</p><p>因此，我们就知道了文章开头的问题的答案，<strong>mysql查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出1000+10条数据，并抛弃前1000条，这部分耗时更大</strong>。</p><p><strong>那这种case有办法优化吗？</strong></p><p>可以看出，当offset非0时，server层会从引擎层获取到很多无用的数据，而当select后面是**<em><strong>号时，就需要拷贝完整的行信息，</strong>拷贝完整数据跟只拷贝行数据里的其中一两个列字段耗时是不同的</em>*，这就让原本就耗时的操作变得更加离谱。</p><p>因为前面的offset条数据最后都是不要的，就算将完整字段都拷贝来了又有什么用呢，所以我们可以将sql语句修改成下面这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">6000000</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>上面这条sql语句，里面先执行子查询 <code>select id from page order by id limit 6000000, 1</code>, 这个操作，其实也是将在innodb中的主键索引中获取到<code>6000000+1</code>条数据，然后server层会抛弃前6000000条，只保留最后一条数据的id。</p><p>但不同的地方在于，在返回server层的过程中，只会拷贝数据行内的id这一列，而不会拷贝数据行的所有列，当数据量较大时，这部分的耗时还是比较明显的。</p><p>在拿到了上面的id之后，假设这个id正好等于6000000，那sql就变成了这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span>(<span class="hljs-number">6000000</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这样innodb再走一次<strong>主键索引</strong>，通过B+树<strong>快速定位</strong>到id&#x3D;6000000的行数据，时间复杂度是log(n)，然后向后取10条数据。</p><p>这样性能确实是提升了，亲测能快一倍左右，属于那种耗时从3s变成1.5s的操作。</p><p>啊这······</p><p>属实有些杯水车薪，有点搓，属于没办法中的办法。</p><h4 id="基于非主键索引的limit执行过程"><a href="#基于非主键索引的limit执行过程" class="headerlink" title="基于非主键索引的limit执行过程"></a>基于非主键索引的limit执行过程</h4><p>上面提到的是主键索引的执行过程，我们再来看下基于非主键索引的limit执行过程。</p><p>比如下面的sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> user_name limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>server层会调用innodb的接口，在innodb里的非主键索引中获取到第0条数据对应的主键id后，<strong>回表</strong>到主键索引中找到对应的完整行数据，然后返回给server层，server层将其放到结果集中，返回给客户端。</p><p>而当offset&gt;0时，且offset的值较小时，逻辑也类似，区别在于，offset&gt;0时会丢弃前面的offset条数据。</p><p>也就是说<strong>非主键索引的limit过程，比主键索引的limit过程，多了个回表的消耗</strong>。</p><p>但当offset变得非常大时，比如600万，此时执行explain。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922231012627.png" alt="image-20230922231012627"></p><p>可以看到type那一栏显示的是<strong>ALL</strong>，也就是<strong>全表扫描</strong>。</p><p>这是因为server层的<strong>优化器</strong>，会在执行器执行sql语句前，判断下哪种执行计划的代价更小。</p><p>很明显，优化器在看到非主键索引的<strong>600w次回表</strong>之后，摇了摇头，我还不如全表一条条记录去判断算了，于是选择了全表扫描。</p><p>因此，当<strong>limit offset过大时，非主键索引查询非常容易变成全表扫描。是真·性能杀手</strong>。</p><p>这种情况也能通过一些方式去优化。比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page t1, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> user_name limit <span class="hljs-number">6000000</span>, <span class="hljs-number">100</span>) t2  <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure><p>通过<code>select id from page order by user_name limit 6000000, 100</code>。先走innodb层的user_name非主键索引取出id，因为只拿主键id，不需要回表，所以这块性能会稍微快点，在返回server层之后，同样抛弃前600w条数据，保留最后的100个id。然后再用这100个id去跟t1表做id匹配，此时走的是主键索引，将匹配到的100条行数据返回。这样就绕开了之前的600w条数据的回表。</p><p>当然，跟上面的case一样，还是没有解决要白拿600w条数据然后抛弃的问题，这也是非常挫的优化。</p><p>像这种，当offset变得超大时，比如到了百万千万的量级，问题就突然变得严肃了。</p><p>这里就产生了个专门的术语，叫<strong>深度分页</strong>。</p><h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>深度分页问题，是个很恶心的问题，恶心就恶心在，这个问题，它其实<strong>无解</strong>。</p><p>不管你是用mysql还是es，你都只能通过一些手段去”减缓”问题的严重性。</p><p>遇到这个问题，我们就该回过头来想想。</p><p>为什么我们的代码会产生深度分页问题？</p><p><strong>它背后的原始需求是什么</strong>，我们可以根据这个做一些规避。</p><h4 id="如果你是想取出全表的数据"><a href="#如果你是想取出全表的数据" class="headerlink" title="如果你是想取出全表的数据"></a>如果你是想取出全表的数据</h4><p>有些需求是这样的，我们有一张数据库表，但我们希望将这个数据库表里的所有数据取出，异构到es，或者hive里，这时候如果直接执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page;<br></code></pre></td></tr></table></figure><p>这个sql一执行，狗看了都摇头。</p><p>因为数据量较大，mysql根本没办法一次性获取到全部数据，妥妥<strong>超时报错</strong>。</p><p>于是不少mysql小白会通过<code>limit offset size</code>分页的形式去分批获取，刚开始都是好的，等慢慢地，哪天数据表变得奇大无比，就有可能出现前面提到的<code>深度分页</code>问题。</p><p>这种场景是最好解决的。</p><p>我们可以将所有的数据<strong>根据id主键进行排序</strong>，然后分批次取，将<strong>当前批次的最大id作为下次筛选的条件</strong>进行查询。</p><p>可以看下伪代码：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922231706442.png" alt="image-20230922231706442"></p><p>这个操作，可以通过主键索引，每次定位到id在哪，然后往后遍历100个数据，这样不管是多少万的数据，查询性能都很稳定。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922231821926.png" alt="image-20230922231821926"></p><h4 id="如果是给用户做分页展示"><a href="#如果是给用户做分页展示" class="headerlink" title="如果是给用户做分页展示"></a>如果是给用户做分页展示</h4><p>如果深度分页背后的原始需求只是产品经理希望做一个展示页的功能，比如商品展示页，那么我们就应该好好跟产品经理battle一下了。</p><p>什么样的翻页，需要翻到10多万以后，这明显是不合理的需求。</p><p>是不是可以改一下需求，让它更接近用户的使用行为？</p><p>比如，我们在使用谷歌搜索时看到的翻页功能。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922231926176.png" alt="image-20230922231926176"></p><p>一般来说，谷歌搜索基本上都在20页以内，作为一个用户，我就很少会翻到第10页之后。</p><p>如果我们要做搜索或筛选类的页面的话，就别用mysql了，用es，并且也需要控制展示的结果数，比如一万以内，这样不至于让分页过深。</p><p>如果因为各种原因，必须使用mysql。那同样，也需要控制下返回结果数量，比如数量1k以内。</p><p>这样就能勉强支持各种翻页，跳页（比如突然跳到第6页然后再跳到第106页）。</p><p>但如果能从产品的形式上就做成不支持跳页会更好，比如只<strong>支持上一页或下一页</strong>。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922232056893.png" alt="image-20230922232056893"></p><p>通过上下页的形式我们就可以使用上面提到的<code>start_id</code>方式，采用分批获取，每批数据以<code>start_id</code>为起始位置。这个解法最大的好处是不管翻到多少页，查询速度永远稳定。</p><p>听起来很挫？</p><p>怎么会呢，把这个功能包装一下。</p><p>变成像抖音那样只能上划或下划，它有一个专业的名称叫<strong>瀑布流</strong>。</p><p>是不是瞬间就高大上了？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>limit offset, size</code> 比 <code>limit size</code> 要慢，且offset的值越大，sql的执行速度越慢。</li><li>当offset过大，会引发<strong>深度分页</strong>问题，目前不管是mysql还是es都没有很好的方法去解决这个问题。只能通过限制查询数量或分批获取的方式进行规避。</li><li>遇到深度分页的问题，多思考其原始需求，大部分时候是不应该出现深度分页的场景的，必要时多去影响产品经理。</li><li>如果数据量很少，比如1k的量级，且长期不太可能有巨大的增长，还是用<strong>limit offset, size</strong> 的方案吧，整挺好，能用就行。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/i6FL1iRECiWZ1CCf_juxQQ">https://mp.weixin.qq.com/s/i6FL1iRECiWZ1CCf_juxQQ</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>查询优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
