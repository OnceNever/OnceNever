<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/27/ThreadLocal/"/>
    <url>/2023/09/27/ThreadLocal/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JDK源码系列-HashMap</title>
    <link href="/2023/09/27/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/"/>
    <url>/2023/09/27/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-HashMap/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>HashMap</code>是Java程序员使用频率最高的用于映射(key-value键值对)处理的数据类型。</p><p>JDK1.8 之前 <code>HashMap</code> 是由 数组+链表 组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决<strong>哈希冲突</strong>而存在的（“拉链法”解决冲突）。 </p><p>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度<strong>大于等于阈值</strong>（默认为 8）（将链表转换成红黑树前会判断，如果当前<strong>数组的长度小于 64</strong>，那么会选择<strong>先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>HashMap</code>的优点是<strong>访问速度快</strong>，插入和删除操作也方便。一般来说，如果<code>HashMap</code>中的元素是均匀分布在数组中的，那么查询时间复杂度接近于O(1)；相反，那么查询的时间复杂度可能会增加，因为可能需要遍历数组中的链表或红黑树来找到对应的值。链表的查询时间复杂度是O(n)，红黑树的查询时间复杂度是O(logn)，其中n是链表或红黑树中的元素个数。因此，<code>HashMap</code>的查询时间复杂度最好是O(1)，最坏是O(n)。</p><p><code>HashMap</code>的缺点是不保证元素的顺序，不支持线程同步，也不能存储重复的键（key）。</p><p><code>HashMap</code>可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且，<code>HashMap</code>总是使用 2 的幂作为哈希表的大小。</p><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p>下图是<code>HashMap</code>的类结构关系图：</p><p>它继承了<code>AbstractMap</code>，<code>AbstractMap</code>实现了顶层接口Map中的大部分方法，只有一个抽象方法<code>entrySet()</code>需要自己实现。</p><p>实现了以下接口：</p><ul><li>Map：哈希表的顶级接口，定义了哈希表的基础操作方法，交给子类实现。</li><li>Cloneable：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li>Serializable：表明它可以进行序列化和反序列化操作，也就是即可以将<strong>对象序列化为字节流</strong>进行持久化存储或网络传输，也可以从<strong>字节流反序列化为对象</strong>，非常方便。</li></ul><p><img src="https://blog.seeyourface.cn/blog/image-20230927152729707.png" alt="image-20230927152729707"></p><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>从底层数据存储结构实现来讲，<code>HashMap</code>是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p><p><img src="https://blog.seeyourface.cn/blog/hashMap.png" alt="hashMap"></p><p>大家有没有想过：<code>HashMap</code>数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p><p>问题1：通过源码我们可以发现，<code>HashMap</code>的数据最终都保存在一个叫<code>Node&lt;K,V&gt;</code>的结构中。</p><p>什么！还有高手？？？</p><p><img src="https://blog.seeyourface.cn/blog/image-20230927170909332.png" alt="image-20230927170909332"></p><p><code>Node</code>是<code>HashMap</code>的一个内部类，实现了<code>Map.Entry</code>接口，本质是就是一个映射(键值对)。也就是上图中的长方形代表的结构。</p><p>问题2：哈希表为了解决冲突，可以采用的解决方法有开放地址法和链地址法，且<code>Java</code>中<code>HashMap</code>采用的就是链地址法。简单来说就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被<code>Hash</code>后，得到数组下标，把数据放在对应下标元素的链表上。</p><h3 id="HashMap是如何保证高性能的？"><a href="#HashMap是如何保证高性能的？" class="headerlink" title="HashMap是如何保证高性能的？"></a>HashMap是如何保证高性能的？</h3><p>前面我们说过，理想情况下<code>HashMap</code>的查询时间复杂度是O(1)，但是随着加入的对象越来越多，数组中的链表将越来越长，将严重影响HashMap的性能。</p><p>那么如何降低哈希冲突的概率呢，可以通过控制变量法进行分析：我们知道一个对象存放的位置取决于<strong>散列函数</strong>和<strong>数组容量</strong>。</p><ul><li>我们将哈希桶的容量固定，Hash算法越好，对象在哈希桶中的位置分布就越均匀，也就是哈希冲突的概率越低。</li><li>对于同一个Hash算法，哈希桶越大，对象在哈希桶中冲突的概率也越低。</li></ul><p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的Hash算法减少Hash碰撞。</p><p>而<code>HashMap</code>正是通过好的Hash算法和哈希桶的扩容机制来平衡空间与时间之间的关系。</p><h3 id="什么时候触发扩容机制"><a href="#什么时候触发扩容机制" class="headerlink" title="什么时候触发扩容机制"></a>什么时候触发扩容机制</h3><p>在介绍Hash算法和扩容流程之前，我想先提一下 <code>HashMap</code> 在什么时候会触发扩容机制。</p><p>通过查看<code>HashMap</code>源码可知，扩容机制是通过 <code>resize()</code> 方法实现的，而我们在往 <code>HashMap</code> 中放入对象时，满足条件 <code>(++size &gt; threshold)</code> 时会调用 <code>resize()</code> 方法进行扩容，<code>threshold</code> 在源码中给出的解释是：在给定 <code>Load factor</code> 和 <code>capacity</code> (数组容量)下所允许的最大元素数目，即 <code>threshold = capacity * load factor </code> ，默认的负载因子(<code>load factor</code>)是0.75。</p><p>如果使用无参构造器创建 <code>HashMap</code> 默认容量为 <code>1 &gt;&gt; 4</code> 即16，所以当添加第13个对象时就会触发<code>HashMap</code>的扩容机制。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230928134857618.png" alt="image-20230928134857618"></p><p>也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多，超过这个数目就重新resize(扩容)。</p><p>默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以适当降低负载因子 <code>loadFactor</code> 的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 <code>loadFactor</code> 的值，这个值<strong>可以大于</strong>1。</p><h3 id="为什么HashMap的容量始终为2的N次幂"><a href="#为什么HashMap的容量始终为2的N次幂" class="headerlink" title="为什么HashMap的容量始终为2的N次幂"></a>为什么HashMap的容量始终为2的N次幂</h3><p><code>HashMap</code>扩容后的容量是之前容量的两倍。并且在 <code>HashMap</code> 中，哈希桶数组table的容量大小始终为2的n次方(一定是合数)。这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，例如 <code>Hashtable</code> 初始化桶大小为11，就是桶大小设计为素数的应用（<code>Hashtable</code>扩容后不能保证还是素数）。</p><p><code>HashMap</code> 采用这种非常规设计，主要是为了在<strong>取模和扩容</strong>时做优化。</p><p>如下图在容量N为 <code>2 ^ 3 = 8</code> 的 <code>HashMap</code> 中，我们举个例子来证明素数的冲突概率要小于合数：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230928145903047.png" alt="image-20230928145903047"></p><p>首先，二进制中用位运算来执行取模操作，只适用于模数为<strong>2的倍数</strong>的情况，这里解释了<code>HashMap</code>用2的N次幂做容量的第一个原因。</p><p>K &#x3D; 28 对 N 取模的运算 28 % N 可以转化为位运算的 <code>1 1100 &amp; (N - 1)</code> ，上面的例子结果就是4；再对另一个元素 K &#x3D; 20 做同样运算，我们能得到该元素最终存储的索引也是4。</p><p>通过上图我们发现，即使 28 和 20 转化为二进制后的第四位（从右往左数）不相同，但仍然哈希到了同一个位置，也就是说这时候元素K第四位就根本不参与哈希运算，这就无法完整地反映元素 K 的特性，增大了导致冲突的几率。</p><p>取其他合数时，都会不同程度的导致c的某些位”失效”，从而在一些常见应用中导致冲突。</p><p>但是取质数，基本可以保证K的每一位都参与哈希运算，从而在常见应用中减小冲突几率（并不能完全避免）。</p><p>所以为了减少冲突，<code>HashMap</code> 定位哈希桶索引位置时，也加入了<strong>高位参与运算</strong>的过程。</p><h3 id="链表和红黑树的相互转化"><a href="#链表和红黑树的相互转化" class="headerlink" title="链表和红黑树的相互转化"></a>链表和红黑树的相互转化</h3><p>即使负载因子和 <code>Hash</code> 算法设计的再合理，也无法避免会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 <code>HashMap</code> 的性能。</p><p>于是，在 <code>JDK1.8</code> 版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长超过 <code>TREEIFY_THRESHOLD</code>（默认为8）时，会进一步判断数组容量，<strong>如果数组容量小于 <code>MIN_TREEIFY_CAPACITY</code> (默认为64)，会优先对数组进行扩容</strong>，然后将数据重新散列到新的哈希桶中；如果数组容量大于等于64，就会将链表转换为红黑树，利用红黑树快速增删改查的特点提高 <code>HashMap</code> 的性能。</p><p>在扩容过程中，如果原来数组中红黑树的节点经重新散列后<strong>小于等于</strong> <code>UNTREEIFY_THRESHOLD</code> (默认为6)时，红黑树会重新退化为链表。</p><p><img src="https://blog.seeyourface.cn/blog/img-20230928153456.png" alt="img-20230928153456"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认构造函数。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br>&#125;<br><br><span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>   <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>   putMapEntries(m, <span class="hljs-literal">false</span>);<span class="hljs-comment">//下面会分析到这个方法</span><br>&#125;<br><br><span class="hljs-comment">// 指定“容量大小”的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>   <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">// 指定“容量大小”和“负载因子”的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>   <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>   <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>       initialCapacity = MAXIMUM_CAPACITY;<br>   <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>   <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>   <span class="hljs-comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span><br>   <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>值得注意的是：上述四个构造方法中，都初始化了负载因子 <code>loadFactor</code>，由于<code>HashMap</code>中没有 <code>capacity</code> 这样的字段，即使指定了初始化容量 <code>initialCapacity</code> ，也只是通过 <code>tableSizeFor</code> 将其扩容到与 <code>initialCapacity</code> <strong>最接近的2的幂次方大小</strong>，然后暂时赋值给 <code>threshold</code> ，后续通过 <code>resize</code> 方法将 <code>threshold</code> 赋值给 <code>newCap</code> 进行 <code>table</code> 的初始化。</p></blockquote><h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor()"></a>tableSizeFor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns a power of two size for the given target capacity.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对任意十进制数转换为2的整数幂，结果是这个数本身的<strong>最高有效位的前一位变成1，最高有效位以及其后的位都变为0</strong>。</p><p>核心思想是，先<strong>将最高有效位以及其后的位都变为1</strong>，最后再+1，就进位到前一位变成1，其后所有的满2变0。所以关键是<strong>如何将最高有效位后面都变为1</strong>。</p><ul><li>右移一位，再或运算，最高有效位就有两位变为1</li><li>右移两位，再或运算，最高有效位就有四位变为1</li><li>右移16位再或运算，保证32位的int类型整数最高有效位之后的位都能变为1。</li><li>最后加1就能达到想要的效果。</li></ul><p>开始移位前先将容量先减1，是为了避免给定容量已经是8, 16这样已经是2的幂数时，不减一直接移位会导致得到的结果比预期大。比如预期16得到应该是16，直接移位的话会得到32。</p><h4 id="putMapEntries"><a href="#putMapEntries" class="headerlink" title="putMapEntries()"></a>putMapEntries()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.size();<br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 未初始化，s为m的实际元素个数，ft = s/loadFactor =&gt; s=ft*loadFactor, 跟我们前面提到的</span><br><span class="hljs-comment">             * 阈值=容量*负载因子 是不是很像，ft指的是要添加s个元素所需的最小的容量。</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> ((ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY) ?<br>                    (<span class="hljs-type">int</span>)ft : MAXIMUM_CAPACITY);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 根据构造函数可知，table未初始化，threshold实际上是存放的初始化容量，如果添加s个元素所</span><br><span class="hljs-comment">             * 需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。</span><br><span class="hljs-comment">             * 注意这里不是初始化阈值</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : m.entrySet()) &#123;<br>            <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> e.getValue();<br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h4><p>无论是增加、删除还是查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过 <code>HashMap</code> 的数据结构是数组和链表的结合，所以我们当然希望这个 <code>HashMap</code> 里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。</p><p>hash方法的离散性能直接决定了 <code>HashMap</code> 定位数组索引位置效率，我们看看源码是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK1.8</span><br><span class="hljs-comment">// 首先取得hashCode的值 h</span><br><span class="hljs-comment">// h 与 h 无符号向右位移16位做异或运算，目的是让高位参与运算，而异或运算保证0 1出现的概率相等</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br><span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">// JDK 1.7</span><br><span class="hljs-comment">// 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="确定元素在哈希桶中的位置"><a href="#确定元素在哈希桶中的位置" class="headerlink" title="确定元素在哈希桶中的位置"></a>确定元素在哈希桶中的位置</h4><p>对于任意给定的对象，只要它的 <code>hashCode()</code> 返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。</p><p>我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。</p><p>但是，模运算的消耗还是比较大的，在 <code>HashMap</code> 中是这样做的：<code>HashMap</code> 底层数组的长度总是2的n次方，这是 <code>HashMap</code> 在速度上的优化。<strong>当length总是2的n次方时</strong>，<code>h &amp; (length-1)</code> 运算<strong>等价于</strong>对 <code>length</code> 取模，也就是 <code>h % length</code>，但是**&amp;比%具有更高的效率**。</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><p><code>HashMap</code> 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对 putVal 方法添加元素的分析如下：</strong></p><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ol><p><img src="https://blog.seeyourface.cn/blog/image-20230928175621083.png" alt="image-20230928175621083"></p><p>画的有点乱，大家将就看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>        <span class="hljs-comment">// 判断插入的是否是红黑树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 不是红黑树节点则说明为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h4><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。resize方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span><br>    <span class="hljs-comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ? (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把旧哈希表中的每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 只有一个节点，直接计算元素新的位置即可</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 将红黑树拆分成2棵子树，拆分后的子树节点数小于等于6，则将树转化成链表</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 定义低位链表的头节点和尾节点</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-comment">// 定义高位链表的头节点和尾节点</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 判断原hash值有效位的高一位是0，连接到低位链表，并保持元素的相对顺序不变，节省对新数组长度重新取模的时间</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 判断原hash值有效位的高一位是0，连接到高位链表，并保持元素的相对顺序不变，节省对新数组长度重新取模的时间  </span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 低位链表的头节点连接到原索引位置的bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 高位链表的头节点连接到原索引位置 + oldCap的bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的自增主键一定是连续的吗？</title>
    <link href="/2023/09/26/MySQL%E7%9A%84%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F/"/>
    <url>/2023/09/26/MySQL%E7%9A%84%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MySQL自增主键的作用是在自增列上定义一个主键，让主键的值由数据库系统自动分配，而不需要用户输入。这样可以避免主键重复或缺失，提高插入数据的效率，保持主键索引的递增顺序，减少<em>索引的碎片化</em>。</p><blockquote><p>索引的碎片化是指索引中的数据在物理存储上不连续，而是分散在磁盘上的不同位置。这样会导致查询需要更多的磁盘I&#x2F;O操作，降低查询性能和资源利用率。</p></blockquote><p>但实际上，MySQL的自增主键并不能保证一定是连续自增的。</p><p>先创建一张表，其中id为主键且自增，字段a创建了一个唯一索引。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926112247507.png" alt="image-20230926112247507"></p><h3 id="自增值保存在哪？"><a href="#自增值保存在哪？" class="headerlink" title="自增值保存在哪？"></a>自增值保存在哪？</h3><p>执行<code>insert test_incr(a, b) values(1,1);</code>插入一条数据；再执行<code>show create table test_incr;</code>命令查看表的结构。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926113445991.png" alt="image-20230926113445991"></p><p>上述表的结构定义存放在后缀名为 <code>.frm</code> 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 <code>.frm</code> 文件：</p><p><img src="https://blog.seeyourface.cn/blog/img-20230926113940.png" alt="img-20230926113940"></p><p>从上述表结构可以看到，表定义里面出现了一个 <code>AUTO_INCREMENT=2</code>，表示下一次插入数据时，如果需要自动生成自增值，会生成 id &#x3D; 2。</p><p>但需要注意的是，自增值并不会保存在这个表结构也就是 <code>.frm</code> 文件中，不同的引擎对于自增值的保存策略不同：</p><ol><li>MyISAM 引擎的自增值保存在数据文件中</li><li>InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 <code>max(id)</code>，然后将 <code>max(id)+1</code> 作为这个表当前的自增值。</li></ol><p>举个例子：现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT&#x3D;2对吧。这时候，我们删除 id&#x3D;1 的行，AUTO_INCREMENT 还是 2。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926114409154.png" alt="image-20230926114409154"></p><p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿也就是说，MySQL 重启可能会修改一个表的 <strong>AUTO_INCREMENT</strong> 的值。</p><p>我们趁MySQL不注意，使用<code>kill -9 pid</code>杀掉MySQL服务（主打的就是一个不讲武德），然后重启服务，再次执行<code>show create table test_incr;</code></p><p><img src="https://blog.seeyourface.cn/blog/image-20230926140109271.png" alt="image-20230926140109271"></p><p>此时我们发现<strong>AUTO_INCREMENT</strong>没有显示，是因为默认等于1不会展示。</p><p>以上测试基于MySQL数据库的<strong>5.7.36</strong>版本，存储引擎为<strong>INNODB</strong>。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926140417057.png" alt="image-20230926140417057"></p><p>实际上，到了 MySQL 8.0 版本后，自增值的变更记录被放在了 <strong>redo log</strong> 中，提供了自增值持久化的能力，也就是实现了“如果发生重启，表的自增值可以根据 redo  log 恢复为 MySQL 重启前的值”。</p><p>也就是对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。</p><p>理解了 MySQL 自增值到底保存在哪里以后，再来看看自增值的修改机制，并为大家介绍一些自增值不连续的场景，以下结论基于MySQL8，存储引擎INNODB。</p><h3 id="自增列指定值"><a href="#自增列指定值" class="headerlink" title="自增列指定值"></a>自增列指定值</h3><p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ul><li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li><li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li></ul><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 <code>insert_num</code>，当前的自增值是 <code>autoIncrement_num</code>：</p><ul><li>如果 <code>insert_num &lt; autoIncrement_num</code>，那么这个表的自增值不变</li><li>如果 <code>insert_num &gt;= autoIncrement_num</code>，就需要把当前自增值修改为新的自增值</li></ul><p>也就是说，如果插入的 id 是 100，当前的自增值是 90，<code>insert_num &gt;= autoIncrement_num</code>，那么自增值就会被修改为新的自增值即 101…</p><p>一定如此吗？</p><p>凡是没有绝对~~~</p><p>MySQL中是通过<code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 这两个参数来实现主键自增的，这俩分别用来表示自增的初始值和步长，默认值都是 1。</p><p>所以，上面的例子中生成新的自增值的步骤实际是这样的：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 100  的值，作为新的自增值。</p><p>也就是说，这种情况下，当步长不等于1时，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。</p><p>更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的。</p><h3 id="唯一键冲突"><a href="#唯一键冲突" class="headerlink" title="唯一键冲突"></a>唯一键冲突</h3><p>我们之前往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT&#x3D; 2。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926152320949.png" alt="image-20230926152320949"></p><p>这时我再执行一条插入 <code>(null,1,1)</code> 的命令，很显然会报错 <code>Duplicate entry</code>，因为我们设置了一个唯一索引字段 <code>a</code>：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926152525247.png" alt="image-20230926152525247"></p><p>但是我们可以发现，虽然插入失败了，AUTO_INCREMENT的值从2变为了3！</p><p>具体原因来分析下这个 insert 语句的执行流程：</p><ol><li>执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);</li><li>InnoDB 发现用户没有指定自增 id 的值，则获取表 <code>test_pk</code> 当前的自增值 2；</li><li>将传入的记录改成 (2,1,1);</li><li>将表的自增值改成 3；</li><li>继续执行插入数据操作，由于已经存在 a&#x3D;1 的记录，所以报 Duplicate key error，语句返回。</li></ol><p>可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。</p><p>这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id &#x3D; 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。</p><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3><p>现在我们表里有一行 <code>(1,1,1)</code> 的记录，并且AUTO_INCREMENT &#x3D; 3：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926153207589.png" alt="image-20230926153207589"></p><p>然后我们手动开启事务，插入一条(null,2,2)的数据，再回滚。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926153412078.png" alt="image-20230926153412078"></p><p>显然，我们执行了插入语句，但是回滚了事务，所以数据库中并没有刚才的(null,2,2)数据。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926153917766.png" alt="image-20230926153917766"></p><p>但是我们可以发现自增值并没有同样发生回滚！如上图所示，自增值仍然固执地从 3 增加到了 4。</p><p>如果这时候我们再去插入一条数据（null, 2, 2）的时候，主键 id 就会被自动赋为 4 了：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926154213388.png" alt="image-20230926154213388"></p><p>所以，当出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去，回退回去的话不就不会发生自增 id 不连续了吗？这又是为什么呢？</p><p>其实，这么做的主要原因是为了提高性能。</p><p>我们可以假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？</p><p>现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后按请求顺序申请，对吧。</p><ol><li>假设事务 A 申请到了 id &#x3D; 1， 事务 B 申请到 id&#x3D;2，那么这时候表 t 的自增值是3，之后继续执行。</li><li>事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id &#x3D; 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id &#x3D; 2 的行，而当前的自增 id 值是 1。</li><li>接下来，继续执行的其他事务就会申请到 id&#x3D;2。这时，就会出现插入语句报错“主键冲突”。</li></ol><p><img src="https://blog.seeyourface.cn/blog/img_20230926155314.png" alt="img_20230926155314"></p><p>有两种方法可以解决这个主键冲突：</p><ol><li>每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id</li><li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id</li></ol><p>很显然，上述两个方法的成本都比较高，会导致性能问题。而原因就是我们假设的这个 “允许自增 id 回退”。</p><p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但<strong>不保证是连续的</strong>。</p><h3 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h3><p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p><ol><li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li><li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li><li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li><li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li></ol><p>注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！因为这类语句在申请自增 id 的时候，根据value的数量是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p><p>而对于 <code>insert … select</code>、<code>replace … select</code> 和 <code>load data</code> 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种<strong>批量申请</strong>的策略，毕竟一个一个申请的话实在太慢了。</p><p>举个例子，假设我们现在这个表有下面这些数据：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926162829910.png" alt="image-20230926162829910"></p><p>创建一张和当前表 <code>test_incr</code> 有相同结构定义的表 <code>test_incr2</code>：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926163210736.png" alt="image-20230926163210736"></p><p>然后使用 <code>insert...select</code> 往 <code>teset_incr2</code> 表中批量插入数据：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926163423686.png" alt="image-20230926163423686"></p><p>可以看到，成功导入了数据。</p><p>再来看下 <code>test_pk2</code> 的自增值是多少：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926163515786.png" alt="image-20230926163515786"></p><p>如上分析一致，是 8 而不是 6。</p><p>具体来说，<code>insert…select</code> 实际上往表中插入了 5 行数据 （1,1）（2,2）（3,3）（4,4）（5,5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：</p><ul><li>第一次申请到了一个 id：id&#x3D;1</li><li>第二次被分配了两个 id：id&#x3D;2 和 id&#x3D;3</li><li>第三次被分配到了 4 个 id：id&#x3D;4、id &#x3D; 5、id &#x3D; 6、id&#x3D;7</li></ul><p>由于这条语句实际只用上了 5 个 id，所以 id&#x3D;6 和 id&#x3D;7 就被浪费掉了。之后，再执行 <code>insert into test_incr2 values(null,6,6)</code>，实际上插入的数据就是（8,6,6)：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230926163809960.png" alt="image-20230926163809960"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下自增值不连续的四个场景：</p><ol><li>自增初始值和自增步长设置不为 1。</li><li>唯一键冲突。</li><li>事务回滚。</li><li>批量插入（如 <code>insert...select</code> 语句）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP缓存</title>
    <link href="/2023/09/25/HTTP%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/25/HTTP%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="为什么要使用缓存？"><a href="#为什么要使用缓存？" class="headerlink" title="为什么要使用缓存？"></a>为什么要使用缓存？</h4><p>HTTP(超文本传输协议)是一种无状态的应用程序级请求&#x2F;响应协议，使用可扩展语义和自描述消息与基于网络的超文本信息系统进行灵活的交互。对于现代互联网来说存在着大量的静态文件例如HTML、CSS和图片等资源，这些资源在后续的请求中不会发生变更。我们可以缓存存储可缓存的响应，以减少未来等效请求的响应时间和网络带宽消耗。</p><p>HTTP <strong>缓存的目标</strong>是通过重用先前的响应消息来满足当前请求，每次缓存重用新响应时，新响应都可以减少延迟和网络开销，从而显着提高性能。</p><h3 id="缓存操作概述"><a href="#缓存操作概述" class="headerlink" title="缓存操作概述"></a>缓存操作概述</h3><h4 id="缓存需要解决的主要问题是什么？"><a href="#缓存需要解决的主要问题是什么？" class="headerlink" title="缓存需要解决的主要问题是什么？"></a>缓存需要解决的主要问题是什么？</h4><p>虽然缓存是HTTP的可选功能，但我们可以假设重用缓存的响应是有效的，并且当没有要求或本地配置阻止对响应进行缓存时，这种重用是<strong>默认行为</strong>。也就是说HTTP的缓存默认是开启的。因此，<strong>HTTP 缓存实现的重点是防止缓存存储不可重用的响应或不适当地重用已存储的响应</strong>，而不是强制缓存存储和重用特定响应。</p><h4 id="本地缓存存储格式"><a href="#本地缓存存储格式" class="headerlink" title="本地缓存存储格式"></a>本地缓存存储格式</h4><p>缓存在本地是以 【请求-响应】 的key&#x2F;value键值对的形式存储的。</p><p>缓存键（key）是缓存用来选择响应的信息，至少由请求方法和用于检索存储的响应的目标 URL 组成，该方法确定在什么情况下（GET&#x2F;POST等）可以使用该响应来满足后续请求。然而，目前许多常用的 HTTP 缓存<strong>仅缓存 GET</strong> 响应，因此仅使用 URL 作为缓存键。</p><h5 id="使用Vary标头字段计算缓存键"><a href="#使用Vary标头字段计算缓存键" class="headerlink" title="使用Vary标头字段计算缓存键"></a>使用Vary标头字段计算缓存键</h5><p><strong>注意！！！</strong></p><p>虽然区分响应的方式本质上是基于它们的 URL。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230925230408064.png" alt="image-20230925230408064"></p><p>但是响应的内容并不总是相同的，即使它们具有相同的 URL。例如在执行内容协商时，来自服务器的响应可能取决于 <code>Accept</code>、<code>Accept-Language</code> 和 <code>Accept-Encoding</code> 请求标头的值。</p><p>打个比方：对于带有 <code>Accept-Language: en</code> 标头并已缓存的英语内容，不希望再对具有 <code>Accept-Language: ja 请求标头的请求重用该缓存响应。在这种情况下，可以通过在 </code>Vary<code> 标头的值中添加“</code>Accept-Language&#96;”，根据语言单独缓存响应。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Language<br></code></pre></td></tr></table></figure><p>当缓存收到可由存储响应满足的请求并且该本地存储的响应包含 Vary 标头字段时，缓存<strong>不允许</strong>在没有重新验证的情况下使用该存储的响应，除非该 Vary 字段值指定的所有呈现的请求标头字段都与原始请求中的字段匹配。这会导致缓存基于响应 URL 和 <code>Accept-Language</code>请求标头的组合进行键控——而不是仅仅基于响应 URL。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230925230553189.png" alt="image-20230925230553189"></p><p>同时，Vary标头字段值包含 “*” 的存储响应将<strong>始终无法匹配</strong>。</p><h4 id="哪些响应能被缓存？"><a href="#哪些响应能被缓存？" class="headerlink" title="哪些响应能被缓存？"></a>哪些响应能被缓存？</h4><p>并不是所有响应都能被缓存存储，响应中存在 no-store 缓存指令将不会被缓存。</p><p>最常见的是缓存请求成功的结果：即对 GET 请求200（OK）的响应，其中包含目标资源的表示。</p><p>然而，也可以存储重定向、否定结果（404 未找到）、不完整的结果（206 部分内容）、以及对 GET 以外的方法的响应如果该方法的定义允许此类缓存并定义了适合用作缓存键的内容。</p><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><p><a href="https://httpwg.org/specs/rfc9111.html#calculating.freshness.lifetime">RFC 9111 HTTP Caching</a> 标准定义了两种不同的缓存：<strong>私有缓存和共享缓存</strong>。</p><h4 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h4><p>私有缓存是与特定客户端相绑定的缓存——通常是指浏览器缓存。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。</p><p>如果响应包含个性化内容并且你只想将响应存储在私有缓存中，则必须指定 <code>private</code> 指令。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>private<br></code></pre></td></tr></table></figure><p>但是如果响应具有 <code>Authorization</code> 标头，则不能将其存储在私有缓存（或共享缓存，除非 Cache-Control 指定的是 <code>public</code>）中。</p><blockquote><p>A cache <em>MUST NOT</em> store a response to a request unless if the cache is shared: the Authorization header field is not present in the request or a response directive is present that explicitly allows shared caching;</p></blockquote><h4 id="共享缓存"><a href="#共享缓存" class="headerlink" title="共享缓存"></a>共享缓存</h4><p>共享缓存位于客户端和服务器之间，可以存储能在用户之间<strong>共享</strong>的响应。共享缓存可以进一步细分为代理缓存和托管缓存。</p><h3 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h3><p><a href="https://httpwg.org/specs/rfc9111.html#calculating.freshness.lifetime">RFC 9111 HTTP Caching</a> 规范中提到，由于源服务器并不总是提供显式过期时间，因此当未指定显式时间时，缓存<em>可以</em>分配启发式过期时间，并采用使用其他字段值（例如上次修改时间）的算法来估计合理的过期时间。该规范没有提供具体的算法，但它确实对其结果施加了最坏情况的限制。</p><p>当存储的响应中存在显式过期时间(例如<code>Cache-Control</code>)时，缓存<strong>不得</strong>使用启发式方法来确定新鲜度。也就是说<strong>启发式缓存只适用于存储响应中没有显式给出过期时间的情况</strong>。</p><p>例如，我们通过请求获取到以下响应，内容最后一次更新是在 1 年前。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 26 Sep 2022 22:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 26 Sep 2021 22:22:22 GMT<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p>通过响应我们可以推测整整一年没有更新的内容在那之后的一段时间内也将不会更新。因此，客户端决定存储此响应（尽管缺少 <code>max-age</code>）并重用它一段时间。复用多长时间取决于实现，但规范建议存储<strong>不超过自该修改时间以来至今的一部分</strong>。这个值在规范中推荐为10%，所以上面的例子中重用的时间不超过0.1年。</p><p>因此，如果源服务器希望阻止缓存，则鼓励它们发送显式指令（例如，<code>Cache-Control：no-cache</code>）</p><blockquote><p>Since origin servers do not always provide explicit expiration times, a cache <em>MAY</em> assign a heuristic expiration time when an explicit time is not specified, employing algorithms that use other field values (such as the Last-Modified time) to estimate a plausible expiration time. This specification does not provide specific algorithms, but it does impose worst-case constraints on their results.</p><p>A cache <em>MUST NOT</em> use heuristics to determine freshness when an explicit expiration time is present in the stored response. Because of the requirements in Section 3), heuristics can only be used on responses without explicit freshness whose status codes are defined as heuristically cacheable (e.g., see Section 15.1 of HTTP) and on responses without explicit freshness that have been marked as explicitly cacheable (e.g., with a public response directive).</p><p>Note that in previous specifications, heuristically cacheable response status codes were called “cacheable by default”.</p><p>If the response has a Last-Modified header field of HTTP, caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.</p></blockquote><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>命中强制缓存时，客户端不会再请求服务器，直接从重用缓存的响应，并返回HTTP状态码为200。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230927225454971.png" alt="image-20230927225454971"></p><p>强制缓存由响应标头中的<code>Expries</code>、<code>Cache-Control</code> 和 <code>Pragma</code>来控制：</p><ul><li>Expires：在 HTTP&#x2F;1.0 中，缓存的有效期是通过 <code>Expires</code> 标头来指定的。<code>Expires</code> 标头使用明确的时间而不是通过指定经过的时间来指定缓存的生命周期。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Tue, 28 Feb 2022 22:22:22 GMT<br></code></pre></td></tr></table></figure><p>这种方式存在一些问题，例如时间格式难以解析，并且客户端可能通过故意偏移系统时钟来诱发问题。</p><ul><li>Cache-Control：由于Expires可能导致的问题，在 HTTP&#x2F;1.1 中引入了<code>Cache-Control</code> 标头，它采用了 <code>max-age</code>——即用于指定经过的时间，这是一个相对时间，是自响应生成以来经过的时间。如果 <code>Expires</code> 和 <code>Cache-Control: max-age</code> 都可用，则将 <code>max-age</code> 定义为首选。因此，由于 HTTP&#x2F;1.1 已被广泛使用，无需特地提供 <code>Expires</code>。<ul><li>no-store： 禁用缓存，表明服务器希望<strong>永远都不要在客户端存储资源</strong>，总是去原始服务器去获取最新资源。</li><li>no-cache：可以在客户端存储资源，但<strong>每次都必须去服务端做新鲜度校验</strong>。</li><li>private&#x2F;public：private指的单个用户，public可以被任何中间人、CDN等缓存</li><li>max-age&#x3D;：max-age是距离请求发起的时间的秒数</li><li>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</li></ul></li><li>Pragma：<code>Pragma</code>请求标头字段是为 HTTP&#x2F;1.0 缓存定义的，以便客户端可以指定“无缓存”的请求（因为Cache-Control直到HTTP&#x2F;1.1才被定义）。然而，对 <code>Cache-Control</code> 的支持现在已经很广泛了，因此，<em>RFC 9111 - HTTP Caching</em>规范不赞成使用 Pragma。</li></ul><h4 id="强制缓存存储的位置"><a href="#强制缓存存储的位置" class="headerlink" title="强制缓存存储的位置"></a>强制缓存存储的位置</h4><table><thead><tr><th>状态</th><th>Network - Size</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>from memory cache</td><td>不请求网络资源，资源在内存，一般是脚本、字体、图片，浏览器关闭，数据将被释放</td></tr><tr><td>200</td><td>from disk cache</td><td>请求网络资源，资源在磁盘，一般是CSS等，关闭数据还在</td></tr><tr><td>200</td><td>资源大小</td><td>从服务器下载最新资源</td></tr><tr><td>304</td><td>报文大小</td><td>请求服务端发现资源未更新，使用本地资源，不从服务器携带完整响应</td></tr></tbody></table><p>比如下图返回的响应Size字段中的内容：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230927233159423.png" alt="image-20230927233159423"></p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>客户端向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源，由于此响应仅表示“没有变化”，因此没有响应主体——只有一个状态码——因此传输大小非常小。</p><p>协商缓存，响应头中有两对字段配合使用标记规则。</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified &#x2F; If-Modified-Since"></a>Last-Modified &#x2F; If-Modified-Since</h4><p>以下响应在 22:22:22 生成，<code>max-age</code> 为 1 小时，因此你知道它在 23:22:22 之前是有效的。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p>到 23:22:22 时，响应会过时并且不能重用缓存。因此，下面的请求显示客户端发送带有 <code>If-Modified-Since</code> 请求标头的请求，以询问服务器自指定时间以来是否有任何的改变。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br></code></pre></td></tr></table></figure><p>如果内容自指定时间以来没有更改，服务器将响应 <code>304 Not Modified</code>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">304</span> Not Modified<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 23:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br></code></pre></td></tr></table></figure><p>收到该响应后，客户端将存储的过期响应恢复为有效的，并可以在剩余的 1 小时内重复使用它。</p><p>这种方法同样存在一些问题：例如，时间格式复杂且难以解析，分布式服务器难以同步文件更新时间。</p><p>所以为了解决这些问题，<code>ETag</code> 响应标头被标准化作为替代方案。</p><h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a>ETag&#x2F;If-None-Match</h4><p><code>ETag</code> 响应标头的值是服务器生成的任意值。服务器对于生成值没有任何限制，因此服务器可以根据他们选择的任何方式自由设置值——例如主体内容的哈希或版本号，只需要能唯一标识这个资源即可。</p><p>举个例子，如果 <code>ETag</code> 标头使用了 hash 值，<code>index.html</code> 资源的 hash 值是 <code>deadbeef</code>，响应如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;deadbeef&quot;<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p>如果该响应是陈旧的，则客户端获取缓存响应的 <code>ETag</code> 响应标头的值，并将其放入 <code>If-None-Match</code> 请求标头中，以询问服务器资源是否已被修改：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;deadbeef&quot;<br></code></pre></td></tr></table></figure><p>如果服务器为请求的资源确定的 <code>ETag</code> 标头的值与请求中的 <code>If-None-Match</code> 值相同，则服务器将返回 <code>304 Not Modified</code>。</p><p>但是，如果服务器确定请求的资源现在应该具有不同的 <code>ETag</code> 值，则服务器将其改为 <code>200 OK</code> 和资源的最新版本进行响应。</p><p>那是不是有了<code>ETag</code>之后就没必要使用<code>Last-Modified</code>呢？答案是否定的。</p><p>引用MDN开发规范中的内容：</p><blockquote><p><strong>备注：</strong> 在评估如何使用 <code>ETag</code> 和 <code>Last-Modified</code> 时，请考虑以下几点：在缓存重新验证期间，如果 <code>ETag</code> 和 <code>Last-Modified</code> 都存在，则 <code>ETag</code> 优先。因此，如果你只考虑缓存，你可能会认为 <code>Last-Modified</code> 是不必要的。然而，<code>Last-Modified</code> 不仅仅对缓存有用；相反，它是一个标准的 HTTP 标头，内容管理 (CMS) 系统也使用它来显示上次修改时间，由爬虫调整爬取频率，以及用于其他各种目的。所以考虑到整个 HTTP 生态系统，最好同时提供 <code>ETag</code> 和 <code>Last-Modified</code>。</p></blockquote><h3 id="强制重新验证"><a href="#强制重新验证" class="headerlink" title="强制重新验证"></a>强制重新验证</h3><p>如果你是个喜新厌旧的人，不希望重复使用响应，而是希望始终从服务器获取最新内容，HTTP提供了<code>no-cache</code>指令强制验证。</p><p>通过在响应中添加 <code>Cache-Control: no-cache</code> 以及 <code>Last-Modified</code> 和 <code>ETag</code>——如下所示——如果请求的资源已更新，客户端将收到 <code>200 OK</code> 响应，否则，如果请求的资源尚未更新，则会收到 <code>304 Not Modified</code> 响应。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:22:22 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 22:00:00 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>deadbeef<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml">…</span><br></code></pre></td></tr></table></figure><p><code>max-age=0</code> 和 <code>must-revalidate</code> 的组合与 <code>no-cache</code> 具有相同的含义。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0, must-revalidate<br></code></pre></td></tr></table></figure><p><code>max-age=0</code> 意味着响应立即过时，而 <code>must-revalidate</code> 意味着一旦过时就不得在没有重新验证的情况下重用它——因此，结合起来，语义似乎与 <code>no-cache</code> 相同。</p><p>然而，<code>max-age=0</code> 的使用是解决 HTTP&#x2F;1.1 之前的许多实现无法处理 <code>no-cache</code> 这一指令——因此为了解决这个限制，<code>max-age=0</code> 被用作解决方法。</p><p>但是现在符合 HTTP&#x2F;1.1 的服务器已经广泛部署，没有理由使用 <code>max-age=0</code> 和 <code>must-revalidate</code> 组合——你应该只使用 <code>no-cache</code>。</p><h3 id="不使用缓存"><a href="#不使用缓存" class="headerlink" title="不使用缓存"></a>不使用缓存</h3><p><code>no-cache</code> 指令不会阻止响应的存储，而是阻止在没有重新验证的情况下重用响应。</p><p>如果你不希望将响应存储在任何缓存中，应使用 <code>no-store</code>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br></code></pre></td></tr></table></figure><h3 id="重新加载"><a href="#重新加载" class="headerlink" title="重新加载"></a>重新加载</h3><p>为了从页面错误中恢复或更新到最新版本的资源，浏览器为用户提供了重新加载功能。</p><p>在浏览器重新加载期间发送的 HTTP 请求的简化视图如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;deadbeef&quot;<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 20:20:20 GMT<br></code></pre></td></tr></table></figure><p>请求中的 <code>max-age=0</code> 指令指定“重用 age 为 0 或更少的响应”——因此，中间存储的响应不会被重用。</p><p>请求通过 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 进行验证。</p><h3 id="强制重新加载"><a href="#强制重新加载" class="headerlink" title="强制重新加载"></a>强制重新加载</h3><p>出于向后兼容的原因，浏览器在重新加载期间使用 <code>max-age=0</code>——因为在 HTTP&#x2F;1.1 之前的许多过时的实现中不理解 <code>no-cache</code>。但是在这个用例中，<code>no-cache</code> 已被支持，并且<strong>强制重新加载</strong>是绕过缓存响应的另一种方法。</p><p>浏览器<strong>强制重新加载</strong>期间的 HTTP 请求如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Pragma</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br></code></pre></td></tr></table></figure><h3 id="避免重新验证"><a href="#避免重新验证" class="headerlink" title="避免重新验证"></a>避免重新验证</h3><p>永远不会改变的内容应该被赋予一个较长的 <code>max-age</code>，方法是使用缓存破坏——也就是说，在请求 URL 中包含版本号、哈希值等。</p><p>但是，当用户重新加载时，即使服务器知道内容是不可变的，也会发送重新验证请求。</p><p>为了防止这种情况，<code>immutable</code> 指令可用于明确指示不需要重新验证，因为内容永远不会改变。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=31536000, immutable<br></code></pre></td></tr></table></figure><p>这可以防止在重新加载期间进行不必要的重新验证。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>如下图请求网站<a href="https://seeyourface.cn，第一次请求我们注意服务器返回的响应内容：">https://seeyourface.cn，第一次请求我们注意服务器返回的响应内容：</a></p><p>HTTP Code : 200 —— 没有使用强制缓存，同时也没有进行协商缓存。</p><p>Etag —— 协商缓存用到的标头，缓存失效时下一个请求在<code>If-None-Match</code>中携带缓存中Etag内容，服务器经过验证后，如果没有对资源进行修改，返回304 Not Modified。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230928000111033.png" alt="image-20230928000111033"></p><p>我们刷新浏览器再次请求，状态码确实是304，我这个请求是在600秒之内刷新的，那为什么第一次的请求标头中的 <code>Cache-Control : max-age=600</code> 字段没有生效呢，不应该是通过强制缓存直接重用响应吗？</p><p>这是因为请求中携带了 <code>Cache-Control : max-age=0</code> ，请求中的 <code>max-age=0</code> 指令指定“重用 age 为 0 或更少的响应”——因此，我们存储的响应不会被重用。而是通过 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 进行验证。所以请求标头<code>If-None-Match</code>中携带了上一次响应的<code>Etag</code>字段内容，服务器经过验证，认为该资源自上次请求以来没有被修改，所以返回304状态码，客户端可重用已存储的响应。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230928000248303.png" alt="image-20230928000248303"></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK源码系列-LinkedList</title>
    <link href="/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-LinkedList/"/>
    <url>/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-LinkedList/</url>
    
    <content type="html"><![CDATA[<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文内容均以JDK8为例。</p><p><code>LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。</p><p><img src="https://blog.seeyourface.cn/blog/linkedList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="linkedList数据结构"></p><p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p><p><img src="https://blog.seeyourface.cn/blog/336a2145-32ef-497e.png" alt="336a2145-32ef-497e"></p><p>另外，<strong>不要</strong>下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) ，因为都需要先遍历到对应节点再进行增删操作。</p><h4 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h4><ul><li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持<strong>随机访问</strong>（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p><h4 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h4><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p><p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p><p><code>LinkedList</code> 实现了以下接口：</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，<code>Deque</code> 的发音为 “deck” [dɛk]，这个大部分人都会读错。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化和反序列化操作，也就是即可以将<strong>对象序列化为字节流</strong>进行持久化存储或网络传输，也可以从<strong>字节流反序列化为对象</strong>，非常方便。</li></ul><p><img src="https://blog.seeyourface.cn/blog/image-20230924171241953.png" alt="image-20230924171241953"></p><p>与ArrayList不同的是，<code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>       <span class="hljs-comment">// 实际存储数据</span><br>       E item;<br>       <span class="hljs-comment">// 后继节点</span><br>       Node&lt;E&gt; next;<br>       <span class="hljs-comment">// 前驱节点</span><br>       Node&lt;E&gt; prev;<br><span class="hljs-comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span><br>       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>           <span class="hljs-built_in">this</span>.item = element;<br>           <span class="hljs-built_in">this</span>.next = next;<br>           <span class="hljs-built_in">this</span>.prev = prev;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个空的链表对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br><span class="hljs-comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>       <span class="hljs-built_in">this</span>();<br>       addAll(c);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p><code>LinkedList</code> 除了实现了 <code>List</code> 接口相关方法，还实现了 <code>Deque</code> 接口的很多方法，所以我们有很多种方式插入元素。</p><p>这里以 <code>List</code> 接口中相关的插入方法为例进行源码讲解，对应的是<code>add()</code> 方法。</p><p><code>add()</code> 方法有两个版本：</p><ul><li><code>add(E e)</code>：用于在 <code>LinkedList</code> 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。</li><li><code>add(int index, E element)</code>:用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n &#x2F; 2 个元素，时间复杂度为 O(n)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在链表尾部插入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表指定位置插入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 下标越界检查</span><br>    checkPositionIndex(index);<br><br>    <span class="hljs-comment">// 判断 index 是不是链表尾部位置</span><br>    <span class="hljs-keyword">if</span> (index == size)<br>        <span class="hljs-comment">// 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可</span><br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果不是则调用 linkBefore 方法将其插入指定元素之前</span><br>        linkBefore(element, node(index));<br>&#125;<br><br><span class="hljs-comment">// 将元素节点插入到链表尾部</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 将最后一个元素赋值（引用传递）给节点 l</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 将 last 引用指向新节点</span><br>    last = newNode;<br>    <span class="hljs-comment">// 判断尾节点是否为空</span><br>    <span class="hljs-comment">// 如果 l 是null 意味着这是第一次添加元素</span><br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span><br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span><br>        l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br><br><span class="hljs-comment">// 在指定元素之前插入元素</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br>    <span class="hljs-comment">// assert succ != null;断言 succ不为 null</span><br>    <span class="hljs-comment">// 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>    <span class="hljs-comment">// 初始化节点，并指明前驱和后继节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>    <span class="hljs-comment">// 将 succ 节点前驱引用 prev 指向新节点</span><br>    succ.prev = newNode;<br>    <span class="hljs-comment">// 判断尾节点是否为空，为空表示当前链表还没有节点</span><br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// succ 节点前驱的后继引用指向新节点</span><br>        pred.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><code>LinkedList</code>获取元素相关的方法一共有 3 个：</p><ol><li><code>getFirst()</code>：获取链表的第一个元素。</li><li><code>getLast()</code>：获取链表的最后一个元素。</li><li><code>get(int index)</code>：获取链表指定位置的元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取链表的第一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-comment">// 获取链表的最后一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> l.item;<br>&#125;<br><br><span class="hljs-comment">// 获取链表指定位置的元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>  <span class="hljs-comment">// 下标越界检查，如果越界就抛异常</span><br>  checkElementIndex(index);<br>  <span class="hljs-comment">// 返回链表中对应下标的元素</span><br>  <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br></code></pre></td></tr></table></figure><p>get(index)方法的核心在于 <code>node(int index)</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回指定下标的非空节点</span><br>Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 断言下标未越界</span><br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br>    <span class="hljs-comment">// 如果index小于size的二分之一  从前开始查找（向后查找）  反之向前查找</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-comment">// 遍历，循环向后查找，直至 i == index</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>get(int index)</code> 或 <code>remove(int index)</code> 等方法内部都调用了该方法来获取对应的节点。</p><p>从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><code>LinkedList</code>删除元素相关的方法一共有 5 个：</p><ol><li><code>removeFirst()</code>：删除并返回链表的第一个元素。</li><li><code>removeLast()</code>：删除并返回链表的最后一个元素。</li><li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li><li><code>void clear()</code>：移除此链表中的所有元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除并返回链表的第一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br><br><span class="hljs-comment">// 删除并返回链表的最后一个元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkLast(l);<br>&#125;<br><br><span class="hljs-comment">// 删除链表中首次出现的指定元素，如果不存在该元素则返回 fals</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果不为 null ,遍历链表找到要删除的节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除链表指定位置的元素</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 下标越界检查，如果越界就抛异常</span><br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的核心在于 <code>unlink(Node&lt;E&gt; x)</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>    <span class="hljs-comment">// 断言 x 不为 null</span><br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-comment">// 获取当前节点（也就是待删除节点）的元素</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<br>    <span class="hljs-comment">// 获取当前节点的下一个节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-comment">// 获取当前节点的前一个节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>    <span class="hljs-comment">// 如果前一个节点为空，则说明当前节点是头节点</span><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 维护链表头指向当前节点的下一个节点</span><br>        first = next;<br>    <span class="hljs-comment">// 如果前一个节点不为空    </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将前一个节点的 next 指针指向当前节点的下一个节点</span><br>        prev.next = next;<br>        <span class="hljs-comment">// 将当前节点的 prev 指针置为 null，，方便 GC 回收</span><br>        x.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果下一个节点为空，则说明当前节点是尾节点</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 维护链表尾指向当前节点的前一个节点</span><br>        last = prev;<br>    <span class="hljs-comment">// 如果下一个节点不为空    </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将下一个节点的 prev 指针指向当前节点的前一个节点</span><br>        next.prev = prev;<br>        <span class="hljs-comment">// 将当前节点的 next 指针置为 null，方便 GC 回收</span><br>        x.next = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将当前节点元素置为 null，方便 GC 回收</span><br>    x.item = <span class="hljs-literal">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unlink()</code> 方法的逻辑如下：</p><ol><li><p>首先获取待删除节点 x 的前驱和后继节点；</p></li><li><p>判断待删除节点是否为头节点或尾节点： </p><ul><li><p>如果 x 是头节点，则将 first 指向 x 的后继节点 next</p></li><li><p>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</p></li><li><p>如果 x 不是头节点也不是尾节点，执行下一步操作</p></li></ul></li><li><p>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</p></li><li><p>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</p></li><li><p>将待删除节点 x 的元素置空，修改链表长度。</p></li></ol><p>参考下图理解：</p><p><img src="https://blog.seeyourface.cn/blog/LinkedList%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E9%80%BB%E8%BE%91.jpg" alt="LinkedList删除节点逻辑"></p><h4 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h4><p>推荐使用<code>for-each</code> 循环来遍历 <code>LinkedList</code> 中的元素， <code>for-each</code> 循环最终会转换成迭代器形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;pear&quot;</span>);<br><br><span class="hljs-keyword">for</span> (String fruit : list) &#123;<br>    System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LinkedList</code> 的遍历的核心就是它的迭代器的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 双向迭代器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListItr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 表示上一次调用 next() 或 previous() 方法时经过的节点；</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; lastReturned;<br>    <span class="hljs-comment">// 表示下一个要遍历的节点；</span><br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; next;<br>    <span class="hljs-comment">// 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> nextIndex;<br>    <span class="hljs-comment">// 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>    …………<br>&#125;<br></code></pre></td></tr></table></figure><p>下面对迭代器 <code>ListItr</code> 中的核心方法进行详细介绍。</p><p>我们先来看下从头到尾方向的迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断还有没有下一个节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历</span><br>    <span class="hljs-keyword">return</span> nextIndex &lt; size;<br>&#125;<br><br><span class="hljs-comment">// 获取下一个节点</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查在迭代过程中链表是否被修改过</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常</span><br>    <span class="hljs-keyword">if</span> (!hasNext())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-comment">// 将 lastReturned 指向当前节点</span><br>    lastReturned = next;<br>    <span class="hljs-comment">// 将 next 指向下一个节点</span><br>    next = next.next;<br>    nextIndex++;<br>    <span class="hljs-keyword">return</span> lastReturned.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看一下从尾到头方向的迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否还有前一个节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextIndex &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取前一个节点</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">previous</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是否在迭代过程中链表被修改</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 如果没有前一个节点，则抛出异常</span><br>    <span class="hljs-keyword">if</span> (!hasPrevious())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-comment">// 将 lastReturned 和 next 指针指向上一个节点</span><br>    lastReturned = next = (next == <span class="hljs-literal">null</span>) ? last : next.prev;<br>    nextIndex--;<br>    <span class="hljs-keyword">return</span> lastReturned.item;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要删除或插入元素，也可以使用迭代器进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>list.add(<span class="hljs-literal">null</span>);<br>list.add(<span class="hljs-string">&quot;banana&quot;</span>);<br><br><span class="hljs-comment">// Collection 接口的 removeIf 方法底层依然是基于迭代器</span><br>list.removeIf(Objects::isNull);<br><br><span class="hljs-keyword">for</span> (String fruit : list) &#123;<br>    System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器对应的移除元素的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从列表中删除上次被返回的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是否在迭代过程中链表被修改</span><br>    checkForComodification();<br>    <span class="hljs-comment">// 如果上次返回的节点为空，则抛出异常</span><br>    <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br><br>    <span class="hljs-comment">// 获取当前节点的下一个节点</span><br>    Node&lt;E&gt; lastNext = lastReturned.next;<br>    <span class="hljs-comment">// 从链表中删除上次返回的节点</span><br>    unlink(lastReturned);<br>    <span class="hljs-comment">// 修改指针</span><br>    <span class="hljs-keyword">if</span> (next == lastReturned)<br>        next = lastNext;<br>    <span class="hljs-keyword">else</span><br>        nextIndex--;<br>    <span class="hljs-comment">// 将上次返回的节点引用置为 null，方便 GC 回收</span><br>    lastReturned = <span class="hljs-literal">null</span>;<br>    expectedModCount++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK源码系列-ArrayList</title>
    <link href="/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/"/>
    <url>/2023/09/24/JDK%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-ArrayList/</url>
    
    <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文内容均以JDK8为例。</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>RandomAccess</code> : 这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化和反序列化操作，也就是即可以将<strong>对象序列化为字节流</strong>进行持久化存储或网络传输，也可以从<strong>字节流反序列化为对象</strong>，非常方便。</li></ul><p><img src="https://blog.seeyourface.cn/blog/image-20230924112821522.png" alt="image-20230924112821522"></p><p><code>ArrayList</code> 的底层是数组队列，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的优点是容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这样可以减少递增式再分配的数量，提高程序执行的效率。</p><h4 id="ArrayList和Vector的区别？"><a href="#ArrayList和Vector的区别？" class="headerlink" title="ArrayList和Vector的区别？"></a>ArrayList和Vector的区别？</h4><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全。</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，通过<em>synchronized</em>关键字保证线程安全。</li></ul><h4 id="ArrayList可以添加null值吗？"><a href="#ArrayList可以添加null值吗？" class="headerlink" title="ArrayList可以添加null值吗？"></a>ArrayList可以添加null值吗？</h4><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。但是不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， 因为<code>null</code> 值无意义，会让代码难以维护例如忘记做判空处理就会导致<strong>空指针</strong>异常。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230924114702452.png" alt="image-20230924114702452"></p><h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h4><ul><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都不是同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为双向循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行<strong>向后位&#x2F;向前</strong>移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先<strong>移动到指定位置</strong>再插入和删除。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。本质是因为<code>LinkedList</code>元素的存储不是连续的。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h4 id="ArrayList核心源码"><a href="#ArrayList核心源码" class="headerlink" title="ArrayList核心源码"></a>ArrayList核心源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.UnaryOperator;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认初始容量大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空数组（用于空实例）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 用于默认大小空实例的共享空数组实例。</span><br><span class="hljs-comment">     * 目的是把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span><br><span class="hljs-comment">     */</span> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存ArrayList数据的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList 所包含的元素个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span><br>            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数等于0，创建空数组</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//其他情况，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认无参构造函数</span><br><span class="hljs-comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        <span class="hljs-comment">//将指定集合转换为数组</span><br>        elementData = c.toArray();<br>        <span class="hljs-comment">//如果elementData数组的长度不为0</span><br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                <span class="hljs-comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span><br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// elementData数组长度为0，用空数组代替</span><br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>            elementData = (size == <span class="hljs-number">0</span>)<br>              ? EMPTY_ELEMENTDATA<br>              : Arrays.copyOf(elementData, size);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//下面是ArrayList的扩容机制</span><br><span class="hljs-comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><br><span class="hljs-comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>            <span class="hljs-comment">// any size if not default element table</span><br>            ? <span class="hljs-number">0</span><br>            <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>            <span class="hljs-comment">// supposed to be at default size.</span><br>            : DEFAULT_CAPACITY;<br>        <span class="hljs-comment">//如果最小容量大于已有的最大容量</span><br>        <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>            ensureExplicitCapacity(minCapacity);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//1.得到最小扩容量</span><br>    <span class="hljs-comment">//2.通过最小容量扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>              <span class="hljs-comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span><br>            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br><br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>    <br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>            grow(minCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要分配的最大数组大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity / 2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span><br>        <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span><br>        <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br>    <br>    <span class="hljs-comment">//比较minCapacity和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回此列表中的元素数。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表不包含元素，则返回 true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//注意=和==的区别</span><br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表包含指定的元素，则返回true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br>        <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>                <span class="hljs-comment">//equals()方法比较</span><br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                    <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span><br>            v.elementData = Arrays.copyOf(elementData, size);<br>            v.modCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">// 这不应该发生，因为我们是可以克隆的</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span><br><span class="hljs-comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span><br><span class="hljs-comment">     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span><br><span class="hljs-comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span><br><span class="hljs-comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span><br><span class="hljs-comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span><br><span class="hljs-comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">if</span> (a.length &lt; size)<br>            <span class="hljs-comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span><br>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>            <span class="hljs-comment">//调用System提供的arraycopy()方法实现数组之间的复制</span><br>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-comment">// 这段逻辑的目的是在将列表元素复制到数组后，如果数组的长度大于列表的大小（即列表中的元素个数），则将数组中多余的元素位置置为 null。</span><br>        <span class="hljs-comment">// 这样做是为了避免在后续的代码中可能导致混淆或错误的情况。</span><br>        <span class="hljs-comment">// 例如 list = &#123;&quot;java&quot;, &quot;c&quot;&#125; a = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125; 返回的数组为 &#123;&quot;java&quot;, &quot;c&quot;, null, &quot;4&quot;, &quot;5&quot;&#125;</span><br>        <span class="hljs-comment">// 这样就可以避免混淆list中的元素和a数组中的旧元素</span><br>        <span class="hljs-keyword">if</span> (a.length &gt; size)<br>            a[size] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-comment">// Positional Access Operations</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用指定的元素替换此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        <span class="hljs-comment">//对index进行界限检查</span><br>        rangeCheck(index);<br><br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>        elementData[index] = element;<br>        <span class="hljs-comment">//返回原来在这个位置的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span><br>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                         size - index);<br>        elementData[index] = element;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        modCount++;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-comment">//从列表中删除的元素</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span><br><span class="hljs-comment">     * 返回true，如果此列表包含指定的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Private remove method that skips bounds checking and does not</span><br><span class="hljs-comment">     * return the value removed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// 把数组中所有的元素的值设为null</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            elementData[i] = <span class="hljs-literal">null</span>;<br><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>        rangeCheckForAdd(index);<br><br>        Object[] a = c.toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index, elementData, index + numNew,<br>                             numMoved);<br><br>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>        size += numNew;<br>        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span><br><span class="hljs-comment">     * 将任何后续元素移动到左侧（减少其索引）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123;<br>        modCount++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - toIndex;<br>        System.arraycopy(elementData, toIndex, elementData, fromIndex,<br>                         numMoved);<br><br>        <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> size - (toIndex-fromIndex);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> newSize; i &lt; size; i++) &#123;<br>            elementData[i] = <span class="hljs-literal">null</span>;<br>        &#125;<br>        size = newSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查给定的索引是否在范围内。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * add和addAll使用的rangeCheck的一个版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回IndexOutOfBoundsException细节信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Index: &quot;</span>+index+<span class="hljs-string">&quot;, Size: &quot;</span>+size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除指定集合中包含的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-comment">//如果此列表被修改则返回true</span><br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 仅保留此列表中包含在指定集合中的元素。</span><br><span class="hljs-comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>        Objects.requireNonNull(c);<br>        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span><br><span class="hljs-comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span>+index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *以正确的顺序返回该列表中的元素的迭代器。</span><br><span class="hljs-comment">     *返回的迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h4><p>先从 ArrayList 的构造函数说起，ArrayList 有三种方式来初始化，构造方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认初始容量大小</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br> &#125;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>     <span class="hljs-comment">//初始容量大于0</span><br>     <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// 创建initialCapacity大小的数组</span><br>         <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>     <span class="hljs-comment">//初始容量等于0</span><br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// 创建空数组</span><br>         <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>     <span class="hljs-comment">//初始容量小于0，抛出异常    </span><br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                            initialCapacity);<br>     &#125;<br> &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span><br><span class="hljs-comment"> * 如果指定的集合为null，throws NullPointerException。</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>     elementData = c.toArray();<br>     <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>         <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>             elementData = Arrays.copyOf(elementData, size, Object[].class);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// replace with empty array.</span><br>         <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>以无参数构造方法创建</strong> <code>ArrayList</code> <strong>时，实际上初始化赋值的是一个空数组。</strong></p><p><strong>当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </p><blockquote><p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData </p></blockquote><h5 id="逐步分析-ArrayList-扩容机制"><a href="#逐步分析-ArrayList-扩容机制" class="headerlink" title="逐步分析 ArrayList 扩容机制"></a>逐步分析 ArrayList 扩容机制</h5><p>这里以无参构造函数创建的 ArrayList 为例分析</p><h6 id="先来看-add-方法"><a href="#先来看-add-方法" class="headerlink" title="先来看 add 方法"></a>先来看 <code>add</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal方法</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h6 id="再来看看-ensureCapacityInternal-方法"><a href="#再来看看-ensureCapacityInternal-方法" class="headerlink" title="再来看看 ensureCapacityInternal() 方法"></a>再来看看 <code>ensureCapacityInternal()</code> 方法</h6><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 方法里面调用calculateCapacity获取最小容量</span><br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="calculateCapacity-方法"><a href="#calculateCapacity-方法" class="headerlink" title="calculateCapacity()方法"></a>calculateCapacity()方法</h6><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算最小容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-comment">// 如果是无参构造，elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA为true</span><br>       <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>           <span class="hljs-comment">// 这里取1和DEFAULT_CAPACITY的较大值，也就是10</span><br>           <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>       &#125;<br>       <span class="hljs-keyword">return</span> minCapacity;<br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity()方法"></a>ensureExplicitCapacity()方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       modCount++;<br><br>       <span class="hljs-comment">// overflow-conscious code</span><br>       <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>           <span class="hljs-comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>           grow(minCapacity);<br>   &#125;<br></code></pre></td></tr></table></figure><p>我们来仔细分析一下这个过程：</p><ul><li><p>当我们要 add 进第 1 个元素到 ArrayList 时，<code>elementData.length</code> 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</p></li><li><p>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</p></li><li><p>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</p></li><li><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p></li></ul><h6 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a><code>grow()</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 要分配的最大数组大小</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// ArrayList核心扩容方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>       <span class="hljs-comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity / 2，</span><br>       <span class="hljs-comment">// 因为位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍。</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>       <span class="hljs-comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span><br>       <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>           newCapacity = minCapacity;<br>       <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE, 进入`hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE</span><br>       <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>       <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>           newCapacity = hugeCapacity(minCapacity);<br>       <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>       elementData = Arrays.copyOf(elementData, newCapacity);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1), 所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数。</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt; 1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 右移了 1 位所以相当于 oldCapacity &#x2F; 2。对于大数据的 二进制运算, 位移运算符比那些普通运算符的运算要快很多，因为程序底层都是基于二进制所以程序仅仅是移动一下而已，不用去计算，这样提高了效率，节省了资源。</p></blockquote><p><strong>我们再来通过例子探究一下</strong><code>grow()</code> <strong>方法：</strong></p><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true，size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true，size 增为 11。</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li><p>java 中的 <code>length</code>属性是针对数组说的，比如说你声明了一个数组，想知道这个数组的长度则用到了 length 这个属性。</p></li><li><p>java 中的 <code>length()</code> 方法是针对字符串说的，如果想看这个字符串的长度则用到 <code>length()</code> 这个方法。</p></li><li><p>java 中的 <code>size()</code> 方法是针对泛型集合说的，如果想看这个泛型有多少个元素，就调用此方法来查看！</p></li></ul><h6 id="hugeCapacity-方法。"><a href="#hugeCapacity-方法。" class="headerlink" title="hugeCapacity() 方法。"></a><code>hugeCapacity()</code> 方法。</h6><p>从上面 <code>grow()</code> 方法源码我们知道：如果新容量大于 <code>MAX_ARRAY_SIZE</code>，进入(执行) hugeCapacity() 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>       <span class="hljs-comment">// 对minCapacity和MAX_ARRAY_SIZE进行比较</span><br>       <span class="hljs-comment">// 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br>       <span class="hljs-comment">// 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br>       <span class="hljs-comment">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>       <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>           Integer.MAX_VALUE :<br>           MAX_ARRAY_SIZE;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf()方法"></a><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h5><p>通过上面的源码，我们会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h6 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy() 方法"></a><code>System.arraycopy()</code> 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos,</span><br><span class="hljs-params">                                    Object dest, <span class="hljs-type">int</span> destPos,</span><br><span class="hljs-params">                                    <span class="hljs-type">int</span> length)</span>;<br></code></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment"> * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment"> * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheckForAdd(index);<br><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// arraycopy()方法实现数组自己复制自己</span><br>    <span class="hljs-comment">// elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Arrays-copyOf-方法"><a href="#Arrays-copyOf-方法" class="headerlink" title="Arrays.copyOf()方法"></a><code>Arrays.copyOf()</code>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 复制指定的数组，截断或填充 null（如有必要），以便副本具有指定的长度。对于在原始数组和副本中都有效的所有索引，这两个数组将包含相同的值。</span><br><span class="hljs-comment">   * 对于在副本中有效但对原始副本无效的任何索引，副本将包含 null。当且仅当指定的长度大于原始数组的长度时，此类索引才会存在。</span><br><span class="hljs-comment">   * 生成的数组与原始数组的类完全相同。 </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">* @param original 源对象数组，需要被复制的数组</span><br><span class="hljs-comment">   * @param newLength 要返回的副本的长度</span><br><span class="hljs-comment">   * @return 原始数组的副本，截断或填充空值获取指定长度</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOf(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> newLength) &#123;<br>   <span class="hljs-comment">// 申请一个新的数组</span><br>       <span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[newLength];<br><span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span><br>       System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                        Math.min(original.length, newLength));<br>       <span class="hljs-keyword">return</span> copy;<br>   &#125;<br></code></pre></td></tr></table></figure><p>再举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span><br><span class="hljs-comment"> * 返回的数组的运行时类型是指定数组的运行时类型。</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br> <span class="hljs-comment">//elementData：要复制的数组；size：要复制的长度</span><br>     <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br> &#125;<br></code></pre></td></tr></table></figure><h6 id="两者联系和区别"><a href="#两者联系和区别" class="headerlink" title="两者联系和区别"></a>两者联系和区别</h6><p><strong>联系：</strong>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h5 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a><code>ensureCapacity</code>方法</h5><p><code>ArrayList</code> 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 <code>ArrayList</code> 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>        <span class="hljs-comment">// any size if not default element table</span><br>        ? <span class="hljs-number">0</span><br>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>        <span class="hljs-comment">// supposed to be at default size.</span><br>        : DEFAULT_CAPACITY;<br><br>    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>意思是，我们在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity</code> 方法将容量扩容至可以容纳元素的大小，以减少增量时重新分配的次数。</p><p>通过下面的代码实际测试以下这个方法的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>           list.add(i);<br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;使用ensureCapacity方法前：&quot;</span> + (endTime - startTime));<br>   &#125;<br><br><span class="hljs-comment">// 执行五次分别获得的结果</span><br><span class="hljs-comment">// 使用ensureCapacity方法前：2295, 2291, 2308, 2305, 2306</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">startTime1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>   <span class="hljs-comment">// 使用ensureCapacity方法</span><br>       list.ensureCapacity(N);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>           list.add(i);<br>       &#125;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">endTime1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>       System.out.println(<span class="hljs-string">&quot;使用ensureCapacity方法后：&quot;</span> + (endTime1 - startTime1));<br>   &#125;<br><br><span class="hljs-comment">// 执行五次分别获得的结果</span><br><span class="hljs-comment">// 使用ensureCapacity方法前：2163, 2113, 2156, 2150, 2164</span><br></code></pre></td></tr></table></figure><p>通过运行结果，可以看出向 <code>ArrayList</code> 添加大量元素之前使用<code>ensureCapacity</code> 方法可以稍稍提升性能。</p><p>不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 <code>ArrayList</code> 里面添加这么多元素。</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么ConcurrentHashMap的key/value不能为空，HashMap可以？</title>
    <link href="/2023/09/23/%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E7%9A%84keyvalue%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8CHashMap%E5%8F%AF%E4%BB%A5%EF%BC%9F/"/>
    <url>/2023/09/23/%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E7%9A%84keyvalue%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8CHashMap%E5%8F%AF%E4%BB%A5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么ConcurrentHashMap的key-value不能为空，HashMap可以？"><a href="#为什么ConcurrentHashMap的key-value不能为空，HashMap可以？" class="headerlink" title="为什么ConcurrentHashMap的key&#x2F;value不能为空，HashMap可以？"></a>为什么ConcurrentHashMap的key&#x2F;value不能为空，HashMap可以？</h3><p>以JDK8为例，在ConcurrentHashMap源码的<code>putVal</code>方法中当传入的参数key或者value为null时，会抛出<code>NullPointerException</code></p><img src="https://blog.seeyourface.cn/blog/image-20230923222339494.png" alt="image-20230923222339494" style="zoom: 67%;" /><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。</p><p>null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 ConcurrentHashMap 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 ConcurrentHashMap 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，<strong>存在</strong>一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以<strong>无法通过</strong> <code>containsKey(key)</code> 来判断否存在这个键值对，也就没<strong>办法解决二义性</strong>问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，<strong>不存在</strong>一个线程操作该 <code>HashMap</code> 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，<strong>多线程下无法正确判定键值对是否存在</strong>（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果确实需要在 <code>ConcurrentHashMap</code> 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">NULL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><hr><p>关于<code>ConcurrentHashMap</code> 作者本人 (Doug Lea)对于这个问题做出的回答：</p><blockquote><p>The main reason that nulls aren’t allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) is that ambiguities that may be just barely tolerable in non-concurrent maps can’t be accommodated. The main one is that if map.get(key) returns null, you can’t detect whether the key explicitly maps to null vs the key isn’t mapped. In a non-concurrent map, you can check this via map.contains(key), but in a concurrent one, the map might have changed between calls.</p></blockquote><p>翻译：</p><p>ConcurrentMaps（ConcurrentHashMaps、ConcurrentSkipListMaps）中不允许使用 null 的主要原因是，无法容纳在非并发映射中勉强可以容忍的歧义。主要的一点是，如果map.get(key)返回null，你无法检测该键是否显式映射到null与该键是否未映射。在非并发映射中，您可以通过 map.contains(key) 检查这一点，但在并发映射中，映射可能在<strong>调用之间</strong>发生了变化。</p><h4 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h4><p>那么<strong>问题来了</strong>，你有可能会问：八股我都背烂了<code>ConcurrentHashMap</code>不是线程安全的吗，为什么会有其他线程造成影响？</p><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证<strong>多个线程同时对它进行读写操作</strong>时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 HashMap 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p><p>复合操作是指由多个<strong>基本操作</strong>(如put、get、remove、containsKey等)组成的操作，例如先判断某个键是否存在<strong>containsKey(key)<strong>，然后根据结果进行插入或更新</strong>put(key, value)<strong>。这种操作在执行过程中可能会被其他线程</strong>打断</strong>，导致结果不符合预期。</p><p>例如，有两个线程 A 和 B 同时对 <code>ConcurrentHashMap</code> 进行复合操作，如下：</p><img src="https://blog.seeyourface.cn/blog/image-20230923224919178.png" alt="image-20230923224919178" style="zoom: 67%;" /><p>如果线程 A 和 B 的执行顺序是这样：</p><ol><li>线程 A 判断 map 中不存在 key</li><li>线程 B 判断 map 中不存在 key</li><li>线程 B 将 (key, anotherValue) 插入 map</li><li>线程 A 将 (key, value) 插入 map</li></ol><p>那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是<strong>复合操作的非原子性</strong>导致的问题。</p><h4 id="那如何保证-ConcurrentHashMap-复合操作的原子性呢？"><a href="#那如何保证-ConcurrentHashMap-复合操作的原子性呢？" class="headerlink" title="那如何保证 ConcurrentHashMap 复合操作的原子性呢？"></a>那如何保证 ConcurrentHashMap 复合操作的原子性呢？</h4><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 putIfAbsent、compute、computeIfAbsent 、computeIfPresent、merge等。</p><p>这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p><img src="https://blog.seeyourface.cn/blog/image-20230923225542922.png" alt="image-20230923225542922" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ConcurrentHashMap</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK工具使用指南</title>
    <link href="/2023/09/23/JDK%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/09/23/JDK%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="JDK工具使用指南"><a href="#JDK工具使用指南" class="headerlink" title="JDK工具使用指南"></a>JDK工具使用指南</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p><strong>该命令用于打印当前JVM中运行的Java进程状态信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jps [options] [<span class="hljs-built_in">hostid</span>]<br></code></pre></td></tr></table></figure><p><code>options</code>表示命令可选参数：</p><ul><li>-q：仅显示pid</li><li>-m：显示进程pid及main方法参数</li><li>-l：打印进程对应JAR文件所在的完整路径名</li><li>-v：查看进程pid及JVM参数</li><li>-h：打印帮助信息</li></ul><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p><strong>用于打印全部参数和系统属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jinfo [options] &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-[pid]：输出全部参数</li><li>-flag [name] pid：打印对应名称的参数内容</li><li>-flag [+|-] [name] pid：不重启虚拟机的情况下，动态修改JVM参数</li><li>-flag [name]&#x3D;[value]：不重启虚拟机的情况下，动态修改JVM参数</li></ul><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p><strong>对Java应用程序的性能和资源进行实时监控，包括Heap和垃圾回收状态的监控</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstat -[options] [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]<br></code></pre></td></tr></table></figure><p>其中，vmid为虚拟机id，Liunx&#x2F;Unix一般为pid，interval为采样间隔（ms），count为采样数</p><p><code>jstat -gc 54231 1000 3</code> 表示每隔1000ms打印一次pid为54231的进程GC信息，总共打印三次</p><p>options表示命令可选参数：</p><ul><li><p>-class：显示加载class的数量及所占空间等信息</p></li><li><p>-compiler：JIT即时编译器相关的统计信息</p></li><li><p>-gc：打印GC信息（展开查看参数说明）</p></li><li><p>-gccapacity：打印各个内存池分代空间的容量</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>NGCMN</td><td>年轻代(young)中初始化(最小)的大小(字节)</td></tr><tr><td>NGCMX</td><td>年轻代(young)的最大容量(字节)</td></tr><tr><td>NGC</td><td>年轻代(young)中当前的容量(字节)</td></tr><tr><td>S0C</td><td>年轻代中第一个survivor（幸存区）的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个survivor（幸存区）的容量(字节)</td></tr><tr><td>EC</td><td>年轻代中Eden（伊甸园）的容量(字节)</td></tr><tr><td>OGCMN</td><td>old代中初始化(最小)的大小(字节)</td></tr><tr><td>OGCMX</td><td>old代的最大容量(字节)</td></tr><tr><td>OGC</td><td>old代当前新生成的容量(字节)</td></tr><tr><td>OC</td><td>Old代的容量(字节)</td></tr><tr><td>MCMN</td><td>Metaspace 区初始化 ( 最小 ) 容量 (字节)</td></tr><tr><td>MCMX</td><td>Metaspace 区的最大容量(字节)</td></tr><tr><td>MC</td><td>当前 Metaspace 的容量(字节)</td></tr><tr><td>CCSMN</td><td>最小压缩类空间大小(字节)</td></tr><tr><td>CCMSX</td><td>最大压缩类空间大小(字节)</td></tr><tr><td>CCSC</td><td>当前压缩类空间大小(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中GC(minor GC)次数</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时old代GC(full GC)次数</td></tr></tbody></table></li><li><p>-gcutil：GC相关区域的使用率统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>S0</td><td>年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</td></tr><tr><td>S1</td><td>年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</td></tr><tr><td>E</td><td>年轻代中Eden（伊甸园）已使用的占当前容量百分比</td></tr><tr><td>O</td><td>old代已使用的占当前容量百分比</td></tr><tr><td>M</td><td>Metaspace代已使用的占当前容量百分比</td></tr><tr><td>CCS</td><td>压缩区已使用的占当前容量百分比</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中gc所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时gc用的总时间(s)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时old代(全gc)gc次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时old代(全gc)gc所用时间(s)</td></tr></tbody></table></li><li><p>-gccause：查看上次GC和本次GC（如果正在GC）产生的原因，参数同-gcutil</p></li><li><p>-gcnew：年轻代的统计信息</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>S0C</td><td>年轻代中第一个survivor（幸存区）的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个survivor（幸存区）的容量(字节)</td></tr><tr><td>S0U</td><td>年轻代中第一个survivor（幸存区）目前已使用空间(字节)</td></tr><tr><td>S1U</td><td>年轻代中第二个survivor（幸存区）目前已使用空间(字节)</td></tr><tr><td>TT</td><td>持有次数限制(默认15)</td></tr><tr><td>MTT</td><td>Maximum tenuring threshold，可以通过-XX:MaxTenuringThreshold&#x3D;N设置，默认为15</td></tr><tr><td>DSS</td><td>Desired survivor size，单位为KB，这个值默认为Survivor区的50%</td></tr><tr><td>EC</td><td>年轻代中Eden（伊甸园）的容量(字节)</td></tr><tr><td>EU</td><td>年轻代中Eden（伊甸园）目前已使用空间(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中gc所用时间(s)</td></tr></tbody></table></li><li><p>-gcoldcapacity：老年代空间大小统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>OGCMN</td><td>老年代最小容量</td></tr><tr><td>OGCMX</td><td>老年代最大容量</td></tr><tr><td>OGC</td><td>当前老年代大小</td></tr><tr><td>OC</td><td>老年代大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table></li><li><p>-gcmetacapacity：meta区大小统计</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>MCMN</td><td>最小元数据容量</td></tr><tr><td>MCMX</td><td>最大元数据容量</td></tr><tr><td>MC</td><td>当前元空间大小</td></tr><tr><td>CCSMN</td><td>最小压缩类空间大小</td></tr><tr><td>CCSMX</td><td>最大压缩类空间大小</td></tr><tr><td>CCSC</td><td>当前压缩类空间大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table></li><li><p>-printcompilation：打印JVM编译统计信息</p></li></ul><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p><strong>用于查看堆内存的情况，或者将堆内存输出为二进制文本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap [option] &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li><p>-heap：打印堆内存配置和使用情况</p></li><li><p>-histo：打印堆内存中的对象大小、数量</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>num</td><td>序号</td></tr><tr><td>instances</td><td>实例个数</td></tr><tr><td>bytes</td><td>字节数</td></tr><tr><td>class_name</td><td>类名</td></tr></tbody></table></li><li><p><code>-dump:format=b,file=[filename].hprof</code> ：dump堆内存到hprof文件</p></li></ul><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p><strong>用于访问jmap命令生产的dump文件，通过浏览器访问</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jhat [options] &lt;dump-file&gt;<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-port：指定jhat的http服务端口，默认7000</li></ul><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p><strong>用于查看指定Java进程pid的堆栈信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstack [options]<br></code></pre></td></tr></table></figure><p>options表示命令可选参数：</p><ul><li>-F：强制线程转储。当jstack 没有响应(进程挂起)时使用</li><li>-m：打印Java和底层C&#x2F;C++框架所有栈信息</li><li>-l(小写L)：长列表模式，打印锁的附加信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL分页怎么优化？</title>
    <link href="/2023/09/22/MySQL%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F/"/>
    <url>/2023/09/22/MySQL%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>我们刷网站的时候，我们经常会遇到需要分页查询的场景。</p><p>比如下图谷歌的翻页功能。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922223517480.png" alt="image-20230922223517480"></p><p>我们很容易能联想到可以用MySQL实现。</p><p>假设我们的建表SQL是这样的:</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922224514427.png" alt="image-20230922224514427"></p><p>建表SQL大家也不用扣细节，只需要知道<strong>id是主键，并且在user_name建了个非主键索引</strong>就够了，其他都不重要。</p><p>为了实现分页。</p><p>很容易联想到下面这样的SQL语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-keyword">offset</span>, size;<br></code></pre></td></tr></table></figure><p>打个比方我们一页需要10条数据。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922224640869.png" alt="image-20230922224640869"></p><p>第一页就是下面这样的sql语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>第一百页就是:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">990</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>那么问题来了。</p><p>用这种方式，<strong>同样都是拿10条数据，查第一页和第一百页的查询速度是一样的吗？为什么？</strong></p><h3 id="两种limit的执行过程"><a href="#两种limit的执行过程" class="headerlink" title="两种limit的执行过程"></a>两种limit的执行过程</h3><p>上面的两种查询方式。对应 <code>limit offset, size</code> 和 <code>limit size</code> 两种方式。</p><p>而其实 <code>limit size</code> ，相当于 <code>limit 0, size</code>。也就是从0开始取size条数据</p><p>也就是说，两种方式的<strong>区别在于offset是否为0</strong>。</p><p>先来看下<code>limit sql</code>的内部执行逻辑。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922225317030.png" alt="image-20230922225317030"></p><p>mysql内部分为<strong>server层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用innodb。</p><p>server层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件</p><p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他where条件），则会放到<strong>结果集</strong>中，最后返回给调用mysql的<strong>客户端（go、java写的应用程序）</strong>。</p><p>我们可以对下面的sql先执行下 <code>explain</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>可以看到，explain中提示 key 那里，执行的是<strong>PRIMARY</strong>，也就是走的<strong>主键索引</strong>。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922225605773.png" alt="image-20230922225605773"></p><p>主键索引本质是一棵B+树，它是放在innodb中的一个数据结构。</p><p>我们可以回忆下，B+树大概长这样。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922225637429.png" alt="image-20230922225637429"></p><p>在这个树状结构里，我们需要关注的是，最下面一层节点，也就是<strong>叶子结点</strong>。而这个叶子结点里放的信息会根据当前的索引是<strong>主键索引还是非主键索引</strong>有所不同。</p><ul><li>如果是<strong>主键索引</strong>，它的叶子节点会存放完整的行数据信息。</li><li>如果是<strong>非主键索引</strong>，那它的叶子节点则会存放主键，如果想获得行数据信息，则需要再跑到主键索引去拿一次数据，这叫<strong>回表</strong>。</li></ul><p>比如执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">where</span> user_name <span class="hljs-operator">=</span> &quot;小白10&quot;;<br></code></pre></td></tr></table></figure><p>会通过非主键索引去查询<strong>user_name</strong>为”小白10”的数据，然后在叶子结点里找到**”小白10**”的数据对应的<strong>主键为10</strong>。</p><p>此时回表到<strong>主键索引</strong>中做查询，最后定位到<strong>主键为10的行数据</strong>。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922230006225.png" alt="image-20230922230006225"></p><p>但不管是主键还是非主键索引，他们的叶子结点数据都是<strong>有序的</strong>。比如在主键索引中，这些数据是根据主键id的大小，从小到大，进行排序的。</p><h4 id="基于主键索引的limit执行过程"><a href="#基于主键索引的limit执行过程" class="headerlink" title="基于主键索引的limit执行过程"></a>基于主键索引的limit执行过程</h4><p>回到文章开头的问题里，当我们去掉<code>explain</code>，执行这条sql。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sq">select * from page order by id limit 0, 10;<br></code></pre></td></tr></table></figure><p>上面select后面带的是<strong>星号</strong>，也就是要求获得行数据的所有字段信息。</p><p>server层会调用innodb的接口，在innodb里的主键索引中获取到第0到10条<strong>完整行数据</strong>，依次返回给server层，并放到server层的结果集中，返回给客户端。</p><p>而当我们把<code>offset</code>搞离谱点，比如执行的是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">6000000</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>server层会调用innodb的接口，由于这次的offset&#x3D;6000000，会在innodb里的主键索引中获取到第0到（6000000 + 10）条<strong>完整行数据，返回给server层之后根据offset的值挨个抛弃，最后只留下最后面的size条</strong>，也就是10条数据，放到server层的结果集中，返回给客户端。</p><p>可以看出，当offset非0时，server层会从引擎层获取到很多无用的数据，而获取的这些无用数据都是要耗时的。</p><p>因此，我们就知道了文章开头的问题的答案，<strong>mysql查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出1000+10条数据，并抛弃前1000条，这部分耗时更大</strong>。</p><p><strong>那这种case有办法优化吗？</strong></p><p>可以看出，当offset非0时，server层会从引擎层获取到很多无用的数据，而当select后面是**<em><strong>号时，就需要拷贝完整的行信息，</strong>拷贝完整数据跟只拷贝行数据里的其中一两个列字段耗时是不同的</em>*，这就让原本就耗时的操作变得更加离谱。</p><p>因为前面的offset条数据最后都是不要的，就算将完整字段都拷贝来了又有什么用呢，所以我们可以将sql语句修改成下面这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">6000000</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>上面这条sql语句，里面先执行子查询 <code>select id from page order by id limit 6000000, 1</code>, 这个操作，其实也是将在innodb中的主键索引中获取到<code>6000000+1</code>条数据，然后server层会抛弃前6000000条，只保留最后一条数据的id。</p><p>但不同的地方在于，在返回server层的过程中，只会拷贝数据行内的id这一列，而不会拷贝数据行的所有列，当数据量较大时，这部分的耗时还是比较明显的。</p><p>在拿到了上面的id之后，假设这个id正好等于6000000，那sql就变成了这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page  <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span>(<span class="hljs-number">6000000</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这样innodb再走一次<strong>主键索引</strong>，通过B+树<strong>快速定位</strong>到id&#x3D;6000000的行数据，时间复杂度是log(n)，然后向后取10条数据。</p><p>这样性能确实是提升了，亲测能快一倍左右，属于那种耗时从3s变成1.5s的操作。</p><p>啊这······</p><p>属实有些杯水车薪，有点搓，属于没办法中的办法。</p><h4 id="基于非主键索引的limit执行过程"><a href="#基于非主键索引的limit执行过程" class="headerlink" title="基于非主键索引的limit执行过程"></a>基于非主键索引的limit执行过程</h4><p>上面提到的是主键索引的执行过程，我们再来看下基于非主键索引的limit执行过程。</p><p>比如下面的sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> user_name limit <span class="hljs-number">0</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>server层会调用innodb的接口，在innodb里的非主键索引中获取到第0条数据对应的主键id后，<strong>回表</strong>到主键索引中找到对应的完整行数据，然后返回给server层，server层将其放到结果集中，返回给客户端。</p><p>而当offset&gt;0时，且offset的值较小时，逻辑也类似，区别在于，offset&gt;0时会丢弃前面的offset条数据。</p><p>也就是说<strong>非主键索引的limit过程，比主键索引的limit过程，多了个回表的消耗</strong>。</p><p>但当offset变得非常大时，比如600万，此时执行explain。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922231012627.png" alt="image-20230922231012627"></p><p>可以看到type那一栏显示的是<strong>ALL</strong>，也就是<strong>全表扫描</strong>。</p><p>这是因为server层的<strong>优化器</strong>，会在执行器执行sql语句前，判断下哪种执行计划的代价更小。</p><p>很明显，优化器在看到非主键索引的<strong>600w次回表</strong>之后，摇了摇头，我还不如全表一条条记录去判断算了，于是选择了全表扫描。</p><p>因此，当<strong>limit offset过大时，非主键索引查询非常容易变成全表扫描。是真·性能杀手</strong>。</p><p>这种情况也能通过一些方式去优化。比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page t1, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> page <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> user_name limit <span class="hljs-number">6000000</span>, <span class="hljs-number">100</span>) t2  <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> t2.id;<br></code></pre></td></tr></table></figure><p>通过<code>select id from page order by user_name limit 6000000, 100</code>。先走innodb层的user_name非主键索引取出id，因为只拿主键id，不需要回表，所以这块性能会稍微快点，在返回server层之后，同样抛弃前600w条数据，保留最后的100个id。然后再用这100个id去跟t1表做id匹配，此时走的是主键索引，将匹配到的100条行数据返回。这样就绕开了之前的600w条数据的回表。</p><p>当然，跟上面的case一样，还是没有解决要白拿600w条数据然后抛弃的问题，这也是非常挫的优化。</p><p>像这种，当offset变得超大时，比如到了百万千万的量级，问题就突然变得严肃了。</p><p>这里就产生了个专门的术语，叫<strong>深度分页</strong>。</p><h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>深度分页问题，是个很恶心的问题，恶心就恶心在，这个问题，它其实<strong>无解</strong>。</p><p>不管你是用mysql还是es，你都只能通过一些手段去”减缓”问题的严重性。</p><p>遇到这个问题，我们就该回过头来想想。</p><p>为什么我们的代码会产生深度分页问题？</p><p><strong>它背后的原始需求是什么</strong>，我们可以根据这个做一些规避。</p><h4 id="如果你是想取出全表的数据"><a href="#如果你是想取出全表的数据" class="headerlink" title="如果你是想取出全表的数据"></a>如果你是想取出全表的数据</h4><p>有些需求是这样的，我们有一张数据库表，但我们希望将这个数据库表里的所有数据取出，异构到es，或者hive里，这时候如果直接执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> page;<br></code></pre></td></tr></table></figure><p>这个sql一执行，狗看了都摇头。</p><p>因为数据量较大，mysql根本没办法一次性获取到全部数据，妥妥<strong>超时报错</strong>。</p><p>于是不少mysql小白会通过<code>limit offset size</code>分页的形式去分批获取，刚开始都是好的，等慢慢地，哪天数据表变得奇大无比，就有可能出现前面提到的<code>深度分页</code>问题。</p><p>这种场景是最好解决的。</p><p>我们可以将所有的数据<strong>根据id主键进行排序</strong>，然后分批次取，将<strong>当前批次的最大id作为下次筛选的条件</strong>进行查询。</p><p>可以看下伪代码：</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922231706442.png" alt="image-20230922231706442"></p><p>这个操作，可以通过主键索引，每次定位到id在哪，然后往后遍历100个数据，这样不管是多少万的数据，查询性能都很稳定。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922231821926.png" alt="image-20230922231821926"></p><h4 id="如果是给用户做分页展示"><a href="#如果是给用户做分页展示" class="headerlink" title="如果是给用户做分页展示"></a>如果是给用户做分页展示</h4><p>如果深度分页背后的原始需求只是产品经理希望做一个展示页的功能，比如商品展示页，那么我们就应该好好跟产品经理battle一下了。</p><p>什么样的翻页，需要翻到10多万以后，这明显是不合理的需求。</p><p>是不是可以改一下需求，让它更接近用户的使用行为？</p><p>比如，我们在使用谷歌搜索时看到的翻页功能。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922231926176.png" alt="image-20230922231926176"></p><p>一般来说，谷歌搜索基本上都在20页以内，作为一个用户，我就很少会翻到第10页之后。</p><p>如果我们要做搜索或筛选类的页面的话，就别用mysql了，用es，并且也需要控制展示的结果数，比如一万以内，这样不至于让分页过深。</p><p>如果因为各种原因，必须使用mysql。那同样，也需要控制下返回结果数量，比如数量1k以内。</p><p>这样就能勉强支持各种翻页，跳页（比如突然跳到第6页然后再跳到第106页）。</p><p>但如果能从产品的形式上就做成不支持跳页会更好，比如只<strong>支持上一页或下一页</strong>。</p><p><img src="https://blog.seeyourface.cn/blog/image-20230922232056893.png" alt="image-20230922232056893"></p><p>通过上下页的形式我们就可以使用上面提到的<code>start_id</code>方式，采用分批获取，每批数据以<code>start_id</code>为起始位置。这个解法最大的好处是不管翻到多少页，查询速度永远稳定。</p><p>听起来很挫？</p><p>怎么会呢，把这个功能包装一下。</p><p>变成像抖音那样只能上划或下划，它有一个专业的名称叫<strong>瀑布流</strong>。</p><p>是不是瞬间就高大上了？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>limit offset, size</code> 比 <code>limit size</code> 要慢，且offset的值越大，sql的执行速度越慢。</li><li>当offset过大，会引发<strong>深度分页</strong>问题，目前不管是mysql还是es都没有很好的方法去解决这个问题。只能通过限制查询数量或分批获取的方式进行规避。</li><li>遇到深度分页的问题，多思考其原始需求，大部分时候是不应该出现深度分页的场景的，必要时多去影响产品经理。</li><li>如果数据量很少，比如1k的量级，且长期不太可能有巨大的增长，还是用<strong>limit offset, size</strong> 的方案吧，整挺好，能用就行。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/i6FL1iRECiWZ1CCf_juxQQ">https://mp.weixin.qq.com/s/i6FL1iRECiWZ1CCf_juxQQ</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>查询优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
